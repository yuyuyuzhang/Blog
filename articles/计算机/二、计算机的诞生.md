# 二、计算机的诞生

## 1. 图灵机的贡献

1936 年，人工智能之父阿兰·图灵提出了图灵机，图灵机是一种`不断执行指令的抽象计算机`，之所以说抽象，是因为这不是一台真正的计算机，而只是一个探讨可计算问题的`理论`

如果一个问题是可计算的，那么这个问题的解决方案就可以被具象化为`一条条指令`由图灵机处理，例如一个马达的控制程序可以被抽象为一条条指令，程序可以先读取传感器的数据，然后再根据数据计算出接下来要加速还是减速

### (1) 可计算理论

图灵机定义了`可计算理论`，也就是`计算能力的边界`

### (2) 计算机的诞生

图灵机定义了`计算机的组成`和`工作原理（程序的执行）`

#### ① 图灵机的内部构造

* **纸带**：图灵机拥有一条无限长的纸带，纸带上是一个个挨着的格子，格子中可以写字符
  * **格子**：相当于计算机的内存
  * **字符**：相当于内存中的程序和数据
* **读写头**：图灵机有一个读写头，可以读取和改写任意格子上的字符
* **零件**：图灵机读写头上面的盒子里有一些精密的零件，包括图灵机的存储单元、控制单元、运算单元

![图灵机的构造](https://github.com/yuyuyuzhang/Blog/blob/master/images/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E5%9B%BE%E7%81%B5%E6%9C%BA%E7%9A%84%E6%9E%84%E9%80%A0.png)

#### ② 图灵机的工作原理

计算 11+15 的值，图灵机的具体运算步骤如下

* 将 11、15、+ 分别写入纸带上的三个格子，将读写头停在 11 的位置
* 图灵机通过读写头将 11 读入到存储单元，图灵机是假定读写头可以做到这点
* 读写头向右移动一个格子，将 15 读入到存储单元
* 读写头向右移动一个格子，将 + 读入到控制单元
* 运算单元从存储单元读入 11、15 并进行计算，将结果 26 存储到存储单元
* 运算单元将 26 传输给控制单元
* 控制单元将 26 传输给读写头
* 读写头向右移动，将 26 写入到格子

这样我们就通过图灵机计算出了 11+15 的值，图灵机的设计原理和如今的计算机是一样的

因此图灵机定义了计算机的组成和工作原理（程序的执行），但是没有给出具体的实现

## 2. 冯诺依曼模型

1945 年，冯诺依曼在著名的 101 页报告中提出了图灵机的具体实现，提出使用`电子元件`构造计算机，约定用`二进制`进行计算和存储，并将计算机结构分成如下 5 个部分

* 中央处理器
* 内存
* 输入设备
* 输出设备
* 总线

这就是著名的冯诺依曼模型

![冯诺依曼模型](https://github.com/yuyuyuzhang/Blog/blob/master/images/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E5%86%AF%E8%AF%BA%E4%BE%9D%E6%9B%BC%E6%A8%A1%E5%9E%8B.png)

### (1) CPU

冯诺依曼模型中 CPU 负责控制和计算

#### ① 控制单元

控制单元专门负责控制 CPU 工作

#### ② 逻辑运算单元

逻辑运算单元专门负责计算

#### ③ 寄存器

CPU 距离内存太远，因此需要一种近距离的存储方式来`暂存操作数据和中间结果`，寄存器就在 CPU 内，距离控制单元和运算单元都非常近，因此速度很快

* **通用寄存器**：存储操作数据和中间结果
* **程序指针寄存器**：存储 CPU 将要执行的下一条指令的`内存地址`
* **指令寄存器**：存储 CPU 将要执行的`下一条指令`

#### ④ CPU 的位宽

CPU 每次可以计算多少`位`的数据

* **32 位 CPU**：32 位 CPU 每次可以计算 `4` 个字节，都是 `32` 位寄存器，通常操作 `32` 位地址总线和数据总线，最多寻址 `2^32 = 4G` 内存
* **64 位 CPU**：64 位 CPU 每次可以计算 `8` 个字节，都是 `64` 位寄存器，通常操作 `40` 位地址总线和数据总线，最多寻址 `2^40 = 1T` 内存（没有那么大的寻址需求，没有 64 位地址总线和数据总线）

一个字节的最大表示范围是 0~255，但是要计算 20000*50 就超出了一个字节的最大表示范围，因此 CPU 需要支持多个字节一起计算，CPU 位宽越大，可计算的数值就越大

32 位 CPU 控制 40 位地址总线和数据总线会非常麻烦，因为 32 位 CPU 最多只有 32 位寄存器，无法一次给出 40 个信号，需要双方指定协议，因此 32 位 CPU 通常控制 32 位地址总线和数据总线，最多操作 2^32 = 4G 内存地址

32 位 CPU 加和两个 64 位数字，必须将 64 位数字拆成 32 位数字计算，例如先加和两个低位的 32 位数字，算出进位，再加和两个高位的 32 位数字，最后再加上进位，而 64 位 CPU 可以一次读入 64 位数字

### (2) 内存

冯诺依曼模型中，`程序`和`数据`都被存储在内存，内存是一个线性排列存储区域

* **存储的数据单位**：位 bit
* **最小的存储单位**：字节 byte = 8 bit

#### ① 内存地址
  
* 每个字节都对应一个内存地址，内存地址由 0 开始编号，依次自增 1，最后一个地址等于内存的字节数减 1

#### ② 随机存储器

* 内存属于随机存储器，读写任何一个地址数据的速度是一样的

### (3) 输入输出设备

通过输入设备向计算机输入数据，计算机经过计算通过输出设备向外界传达结果

### (4) 总线

总线就是用于 CPU、内存、其他设备之间进行通信控制的设备

* **地址总线**：指定将要操作的内存地址
* **数据总线**：读写内存中的数据
* **控制总线**：发送和接受关键信号，例如中断信号、设备复位信号、设备就绪信号等等

CPU 需要读写内存的时候，先通过地址总线指定内存地址，再通过数据总线传递数据  

#### ① 线路并行

数据如何通过线路传输，其实是通过`操作电压`，低电压是 0，高电压是 1

* **串行**：只有一条线路，每次只能传递一个信号，一位一位发送，例如传递一个数字 10，就需要传递信号 1100，这种传递相当慢，因为需要传递 4 次
* **并行**：多条线路并行发送

#### ② 线路位宽问题

* **32 位地址总线和数据总线**
  * 32 位地址总线可以操作 2^32 即 `4G` 内存
  * 32 位 CPU 通常操作 32 位地址总线和数据总线
* **64 位地址总线和数据总线**
  * 64 位地址总线可以操作 2^64 即 `8G` 内存
  * 64 位 CPU 通常操作 64 位地址总线和数据总线

## 3. 程序在冯诺依曼模型上的执行过程

### (1) 程序在冯诺依曼模型上的执行过程

* CPU 读取程序指针寄存器中内存地址指向的指令到指令寄存器
  * CPU 的控制单元操作地址总线指定需要访问的内存地址（CPU 控制单元将程序指针寄存器中内存地址拷贝到地址总线）
  * CPU 通知内存准备数据，内存准备好后将数据通过数据总线传给 CPU
  * CPU 收到内存传递的数据后，将其存入指令寄存器
* CPU 分析指令确定其类型和参数
* CPU 将不同类型指令交给 CPU 对应单元执行
  * 计算类型的指令：逻辑运算单元
  * 存储类型的指令：控制单元
* 程序指针寄存器`自增`，CPU 准备获取下一条指令
  * 32 位 CPU：指令是 32 位，需要 4 个内存地址存储，程序指针寄存器自增 4
  * 64 位 CPU：指令是 64 位，需要 8 个内存地址存储，程序指针寄存器自增 8

![程序在冯诺依曼模型上的执行过程](https://github.com/yuyuyuzhang/Blog/blob/master/images/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%A8%8B%E5%BA%8F%E5%9C%A8%E5%86%AF%E8%AF%BA%E4%BE%9D%E6%9B%BC%E6%A8%A1%E5%9E%8B%E4%B8%8A%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B.png)

### (2) 详解 a = 11 + 15 的执行过程

#### ① 指令的编码 - 编译器

程序员写的程序 a = 11 + 15 是一个字符串，CPU 不能执行字符串，只能执行指令，因此需要编译器将一种程序语言翻译成另一种程序语言

* 编译器通过分析，发现 11、15 是数据，因此编译后的程序启动时，会在内存专门开辟一个区域存储这样的常数，也就是`数据段`
* 编译器将字符串 a = 11 + 15 转换成 4 条指令，程序启动时，会在内存专门开辟一个区域存储这样的指令，也就是`正文段`
  * 0x200 位置的 load 指令将地址 0x100 中的数据 11 导入寄存器 R0
  * 0x204 位置的 load 指令将地址 0x104 中的数据 15 导入寄存器 R1
  * 0x208 位置的 add 指令将寄存器 R0 和 R1 中的值相加，存入寄存器 R2
  * 0x20c 位置的 store 指令将寄存器 R2 中的值存回数据区域中的 0x1108 位置
* 程序执行时，程序指针寄存器首先指向 0x200 位置，然后依次执行这 4 条指令

load 指令如下图：

6 位指令编码 + 4 位寄存器编号 + 22 位数据内存地址

![load指令](https://github.com/yuyuyuzhang/Blog/blob/master/images/%E8%AE%A1%E7%AE%97%E6%9C%BA/load%E6%8C%87%E4%BB%A4.png)

add 指令如下图：

6 位指令编码 + 4 位寄存器编号 + 4 位寄存器编号 + 4 位寄存器编号 + 14 位未使用

![add指令](https://github.com/yuyuyuzhang/Blog/blob/master/images/%E8%AE%A1%E7%AE%97%E6%9C%BA/add%E6%8C%87%E4%BB%A4.png)

#### ② 指令的解码 - CPU

CPU 的指令周期

* Fetch：CPU 通过程序指针寄存器读取指令到指令寄存器
* Decode：CPU 对指令解码
* Execution：CPU 执行指令
* Store：CPU 将结果存入寄存器或内存

![CPU的指令周期](https://github.com/yuyuyuzhang/Blog/blob/master/images/%E8%AE%A1%E7%AE%97%E6%9C%BA/CPU%E7%9A%84%E6%8C%87%E4%BB%A4%E5%91%A8%E6%9C%9F.png)

## 4. 64 位比起 32 位的优势

### (1) 64 位 CPU

* 64 位 CPU 都是 64 位寄存器，32 位 CPU 都是 32 位寄存器
* 64 位 CPU 可以执行更大数值的运算
* 64 位 CPU 可以寻址更大的内存空间

### (2) 64 位程序

* 64 位程序都是 64 位指令，32 位程序都是 32 位指令
* 64 位指令在 32 位 CPU 上运行很困难，因为 32 位寄存器无法存下指令
* 32 位指令在 64 位 CPU 上运行可以兼容，需要一套兼容机制

### (2) 64 位操作系统

操作系统也是一种程序

* 64 位操作系统，操作系统程序都是 64 位指令，因此不能安装在 32 位 CPU 的计算机上
