# 四、操作系统

## 1. 操作系统的作用

### (1) 管理计算机系统的资源

计算机系统包含多种硬件资源和软件资源，归纳起来可分为 4 类：CPU、内存、IO 设备（磁盘、输入设备、输出设备）、文件（程序、数据）

操作系统的主要功能就是管理这四类资源

#### ① CPU 管理

#### ② 内存管理

#### ③ IO 设备管理

#### ④ 文件管理

### (2) 抽象计算机硬件系统的物理接口

一台完全没有软件的计算机裸机，向用户提供的仅仅是`硬件的物理接口`，用户对硬件的物理接口的实现细节没有了解就无法使用计算机

#### ① 硬件设备管理软件

硬件设备管理软件实现了对硬件进行操作的细节，并向上将硬件抽象为`一组数据结构及操作命令`，用户就可以直接利用这些数据结构和操作命令来操纵计算机硬件

#### ② 虚机器

通常把覆盖了硬件设备管理软件的计算机称作虚机器，向用户提供了一个硬件操作的抽象模型，用户利用模型提供的接口使用计算机，无需了解物理接口实现的细节，使用户更容易地使用计算机硬件资源

#### ③ 操作系统

可以在硬件设备管理软件上再次覆盖一层面向用户的窗口软件，用户可以在窗口环境下更方便地使用计算机，从而形成一台功能更强的虚机器

由此可见操作系统就是铺设在计算机硬件上的多层硬件设备管理软件的集合，实现了对计算机硬件操作的多个层级的抽象模型，随着抽象层次的提高，抽象接口提供的功能也就越强，用户使用也就越方便

![抽象物理接口](https://github.com/yuyuyuzhang/Blog/blob/master/images/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%8A%BD%E8%B1%A1%E7%89%A9%E7%90%86%E6%8E%A5%E5%8F%A3.png)

### (3) 用户与计算机硬件系统之间的接口

用户在操作系统的帮助下能够快速便捷地运行自己的程序或者操纵计算机硬件，用户能够通过三种方式实现与操作系统的通信

#### ① 系统调用（应用程序）

系统调用是为了应用程序在执行过程中访问系统资源而设置的，是`应用程序获得操作系统服务`的唯一途径

每一个系统调用都是一个能完成特定功能的`子程序`，每当应用程序要求操作系统提供某种服务时，就调用具有相应功能的系统调用，在高级程序语言中，往往提供了与各个系统调用一一对应的`库函数`

#### ② 命令（用户）

用户通过向应用程序发出`命令`以控制应用程序的运行

用户在`终端或控制台`键入一条命令后，`命令解释程序`立即对该命令加以解释执行，完成指定功能后又返回到终端或控制台，等待用户键入下一条命令，这样用户便可以通过先后键入不同命令的方式控制应用程序的执行

* **命令行形式**
  * 命令行形式以`行`为单位，输入和显示不同的命令，以`回车符`作为一个命令的结束标记
  * 命令行方式采用`间断式的串行执行方式`，前一个命令执行结束并且操作系统发出新的命令输入提示符，用户才能输入下一个命令
* **批命令形式**
  * 实际使用过程中，经常会遇到对多条命令的连续使用，对若干命令的重复使用，对不同命令选择性使用的情况，因此操作系统都支持批命令形式
  * 批命令形式允许用户预先把一系列的命令组织在`批命令文件 .bat` 中，实现一次建立，多次执行，既节省了时间减少了出错概率，又方便了用户

#### ③ 图形化用户接口 GUI（用户）

GUI 采用了图形化的操作界面，将窗口、图标、菜单、鼠标和面向对象技术集成到一起，引入形象的各种图标，将操作系统的各项功能、各种应用程序、各种文件直观逼真的表示出来，形成一个图文并茂的视窗操作环境

有了 GUI，可以直接在系统桌面上显示各种常用图标，每个图标对应一个应用程序，用户只需双击图标就可以启动应用程序（无需键入命令），用户还可以通过选择窗口、菜单、对话框、滚动条，完成对应用程序的各种控制和操作

![用户与计算机硬件之间的接口](https://github.com/yuyuyuzhang/Blog/blob/master/images/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%94%A8%E6%88%B7%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6%E4%B9%8B%E9%97%B4%E7%9A%84%E6%8E%A5%E5%8F%A3.png)

### (4) 计算机系统安全

操作系统需要确保在计算机系统中存储和传输数据的`保密性、完整性、可用性`

#### ① 认证技术

确认用户的真实性，防止入侵者进行假冒和篡改

#### ② 密码技术

对计算机系统中存储和传输的数据进行加密

#### ③ 访问控制技术

* 通过对用户存取权限的设置，限定用户对计算机系统资源的访问范围
* 通过对文件属性的设置，保障指定文件的安全性，例如设置文件属性为只读，该文件就不能被修改

#### ④ 反病毒技术

反病毒软件安装到计算机后，对磁盘上的所有可执行文件进行扫描，若发现有病毒，就立即清除

### (5) 网络通信

① 操作系统需要`支持用户联网`以取得各类网络所提供的服务，如 Web 服务、电子邮件服务等

② 在源主机和目标主机之间，实现`无差错的数据传输`，协议是计算机间通过网络实现通信时事先达成的一种约定，这种约定使不同厂商的设备，不同的 CPU，不同的操作系统组成的计算机之间，只要能够支持相同的协议，并且遵循相同的协议进行处理，就能够实现通信，反之则无法实现通信

## 2. 操作系统的内核

### (1) OS 内核

现代操作系统一般将 OS 划分为若干层次，再将 OS 的不同功能软件分别设置在不同的层次中，通常将一些与硬件紧密相关的功能软件、各种常用设备的驱动程序、运行频率较高的功能软件（时钟管理、进程调度等），安排在紧靠硬件的软件层次中，将其`常驻内存`，被称为 OS 内核

设置 OS 内核的原因

* 对 OS 内核的软件进行保护，防止遭受其他应用程序的破坏
* 提高 OS 的运行效率

### (2) CPU 的执行状态

#### ① 内核态

内核态具有较高的特权，能够执行`一切`指令，访问`所有 CPU 寄存器和所有内存`

`系统程序`（操作系统、语言处理程序）都在`内核态`运行

#### ② 用户态

用户态具有较低的特权，仅能执行`规定`指令，访问`指定 CPU 寄存器和指定内存`

`应用程序`都在`用户态`运行

### (3) 内核态线程和用户态线程

线程分配 CPU 的方式就是由操作系统调度线程，操作系统创建一个进程后，进程的`入口程序`被分配到了一个`主线程`执行，这样看上去是操作系统在调度进程，实际上是调度进程的主线程

这种被操作系统直接调度的线程，称为`内核态线程`，有的应用程序程序员自己还实现了线程，相当于操作系统调度主线程，主线程的程序用算法实现了子线程，这种子线程就被称为`用户态线程`

#### ① 内核态线程

内核态线程通过`系统调用`创建，由`操作系统`直接调度

优势

* 可以利用多核 CPU 优势：内核拥有较高权限，可以在多个 CPU 核心上执行内核态线程
* 操作系统级优化：内核态线程操作 I/O 无需进行系统调用，一个内核态线程阻塞，可以立即更换执行另一个

缺陷

* 创建成本高：创建内核态线程需要系统调用，也就是需要切换到内核态
* 扩展性差：内核态线程不可能数量太多
* 切换成本高：切换内核态线程，需要内核操作，也就是需要切换到内核态
  
#### ② 用户态线程

用户态线程通过 `API` 创建，操作系统完全不知道它的存在，由所属进程的`主线程`调度

优势

* 管理开销小：创建和销毁无需系统调用
* 切换成本低：应用程序自己维护，无需走操作系统调用

缺陷

* 与内核协作成本高：用户态线程完全是应用程序管理，进行 I/O 时无法利用内核优势，需要频繁进行用户态和内核态的切换
* 线程间协作成本高：线程间通信需要 I/O，I/O 需要系统调用，用户态线程协作需要支付额外的系统调用成本
* 无法利用多核优势：操作系统调度的仍然是该用户态线程所属的进程，无论该进程有多少个用户态线程，都只能并发执行一个，无法利用多核优势
* 操作系统无法针对线程调度进行优化：当一个进程的用户态线程阻塞，操作系统无法及时发现和处理阻塞问题，不会更换执行其他线程，从而造成资源浪费

### (4) 系统调用过程

如果应用程序需要执行系统调用，由于系统调用牵扯到`特权指令`，应用程序权限不足，需要切换到内核态，因此会`中断`执行，CPU 跳转到中断处理程序，开始处理系统调用，处理完成后主动触发中断，切换到用户态工作

![系统调用过程](https://github.com/yuyuyuzhang/Blog/blob/master/images/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B.png)

## 3. 操作系统的特征

### (1) 并发

#### ① 程序的并发执行

多个程序在`同一时间间隔内`执行

内存中存在多个应用程序，每个应用程序都有输入程序 I、计算程序 C、打印程序 P 这三个子程序，I1 输入数据后，C1 进行计算，然后通过 `CPU 时间片轮转等调度方式`，执行 I2，从而使得 C1 和 I2 `并发`执行，也就使得第一个应用程序和第二个应用程序`并发`执行

![并发执行](https://github.com/yuyuyuzhang/Blog/blob/master/images/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E5%B9%B6%E5%8F%91%E6%89%A7%E8%A1%8C.png)

程序并发执行的特征如下

* **间断性**：应用程序间的并发执行，虽然提高了系统的吞吐量和资源的利用率，但由于其共享资源，致使并发程序间必然形成`相互制约`的关系，例如计算程序 C1 完成后，输入程序 I2 尚未完成，那么计算程序 C2 就只能暂停执行，等待输入程序 I2 完成后才能恢复执行，由此可见，相互制约将导致并发程序具有 `执行-暂停-执行` 这种间歇性的活动规律

* **失去封闭性**：内存中存在多个并发程序时，系统的各种资源将被共享，致使任一程序运行时，环境都必然会受到其他程序的影响，例如 CPU 分配给一个程序时，其他程序必须等待

* **不可再现性**：由于失去封闭性，将导致不可再现性

#### ② 进程的并发执行

多个进程在`同一时间间隔内`执行

进程并发执行的特性如下

* **间断性**：系统的各种资源被并发进程共享，致使并发进程间形成`相互制约`的关系，相互制约将导致并发进程具有 `执行-暂停-执行` 这种间歇性的活动规律，例如进程 A 请求使用打印机，而操作系统已经将打印机分配给其他进程，则进程 A 自动进入阻塞状态，等待打印机空闲时才被中断处理程序唤醒
* **失去封闭性**：系统的各种资源被并发进程共享，致使任一进程运行时，环境都必然会受到其他进程的影响，例如将 CPU 分配给一个进程，其他进程则必须等待
* **可再现性**：并发进程之间通过`同步机制`保证可再现性

#### ③ 线程的并发执行

多个进程之间可以并发执行，同一进程的多个线程之间也可以并发执行，例如文字处理进程可以设置三个线程，一个用于从键盘读取数据，一个用于在后台进行拼写和语法检查，一个用于显示文字和图片

### (2) 进程

#### ① 进程的概念

由于并发执行的程序具有间断性，并且失去封闭性和可再现性，因此一般的程序是无法参与并发执行的，为了能对并发执行的程序加以控制，引入了进程这个概念

**进程控制块 PCB**：描述进程的基本情况和活动过程，进而控制和管理进程

**进程实体**：PCB、程序代码、相关的数据

**进程**：进程实体通常简称为进程，进程也被定义为`能独立运行并作为资源分配的基本单位`

创建进程实际上就是创建 PCB，撤销进程实际上就是撤销 PCB

#### ② 进程的特征

* **动态性**：程序是`一组有序指令的集合`，存放于磁盘等介质上，程序本身是静态的，并不具有活动的意义
  
  进程是`程序及其数据的一次执行过程`，具有一定的生命期，进程由创建而产生，由调度而执行，由撤销而消亡

* **并发性**：多个进程同时存在于内存中，并且能在一段时间间隔内并发执行，凡是未建立 PCB 的程序都不能参与并发执行
  
  进程并发执行的特性如下
  * **间断性**：系统的各种资源被并发进程共享，致使并发进程间形成`相互制约`的关系，相互制约将导致并发进程具有 `执行-暂停-执行` 这种间歇性的活动规律，例如进程 A 请求使用打印机，而操作系统已经将打印机分配给其他进程，则进程 A 自动进入阻塞状态，等待打印机空闲时才被中断处理程序唤醒
  * **失去封闭性**：系统的各种资源被并发进程共享，致使任一进程运行时，环境都必然会受到其他进程的影响，例如将 CPU 分配给一个进程，其他进程则必须等待
  * **可再现性**：并发进程之间通过`线程同步机制`保证可再现性

* **独立性**：进程是一个能`独立运行、独立获得资源、独立接收调度`的基本单位，凡是未建立 PCB 的程序都不能作为一个独立的单位参与运行

* **异步性**：进程是按异步方式运行的，即进程是按各自独立的、不可预知的速度向前推进，而`进程同步机制`保证了进程并发执行的结果是`可再现`的

#### ③ 线程的诞生

进程是一个资源的拥有者，因此在创建、撤销、切换进程时，操作系统必须为之付出较大的开销，这就限制了并发进程的数目，并且进程切换也不宜过于频繁，从而限制了并发程度的进一步提高，因此引入了线程的概念，线程是为了减少并发进程执行时操作系统付出的开销，使操作系统具有更好的并发性

引入线程的实质就是`将进程的两个基本属性分开`，由操作系统分开处理

引入多线程的操作系统中，进程将不再作为可独立调度的基本单位，因此`进程也就不再作为可执行的实体`，但是进程仍然具有五种状态，例如进程处于执行状态，表示进程至少有一个线程处于执行状态

* **进程**：进程是一个`可拥有资源`的基本单位
* **线程**：线程是一个`可独立调度`的基本单位（从进程的 2 个基本属性中分离出）

进程和线程的比较如下

* **拥有资源**：进程作为拥有资源的基本单位，线程本身并不拥有`系统资源`，而是拥有自己的必不可少的、能保证独立运行的`资源`（线程控制块 TCB、程序代码、相关数据），但是同一进程的所有线程共享该进程拥有的系统资源
* **调度的基本单位**：线程作为调度的基本单位，进程不再作为调度的基本单位，同一进程中线程的切换不会引起进程的切换，而从一个进程中的线程切换到另一个进程中的线程会引起进程的切换
* **并发性**：多个进程之间可以并发执行，同一进程的多个线程之间也可以并发执行，例如文字处理进程可以设置三个线程，一个用于从键盘读取数据，一个用于在后台进行拼写和语法检查，一个用于显示文字和图片
* **独立性**：不同进程间都拥有独立的地址空间和其他资源，除了共享全局变量外，不允许其他进程的访问，而同一进程的所有线程共享该进程的所有资源，因此线程的独立性更低

### (3) 共享

#### ① 线程同步机制

线程同步机制是为了保证进程和线程的`可再现性`，对多个并发线程的执行次序进行协调，使并发线程能按照一定的规则共享系统资源

* **原子操作**：原子操作就是`操作不可分`，在多线程环境下，一个原子操作的操作过程`无法被中断`

  例如 i++ 就是由三个原子操作组成的非原子操作

  * 读取 i
  * 计算 i+1
  * 写入新值

  这种非原子操作在`多线程 + 多核环境`下会造成`竞争条件`

* **竞争条件**：多个线程对同一资源的读写存在竞争，因此这个资源的最终值不可预测，取决于竞争时的具体执行顺序

  例如 2 个线程并发执行 i++，如果按照以下顺序执行，即使执行 2 次 i++，但最终 i=1

  ![竞争条件](https://github.com/yuyuyuzhang/Blog/blob/master/images/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%AB%9E%E4%BA%89%E6%9D%A1%E4%BB%B6.png)

* **临界资源**：一段时间内只允许`指定数量线程`访问的资源
  * 软件临界资源：变量、表格、栈等
  * 硬件临界资源：打印机等诸多物理设备
* **临界区**：每个线程中访问临界资源的`程序代码片段`

  例如 i++ 这段程序访问了共享资源变量 i，那么 i++ 这个程序片段就是临界区

线程同步机制应遵循的规则

* **空闲让进**：当无线程处于临界区时，表示临界资源处于空闲状态，应该允许一个请求进入临界区的线程进入自己的临界区，访问临界资源
* **忙则等待**：当已有线程处于临界区时，表示临界资源正在被访问，因此所有请求进入临界区的线程都必须等待
* **有限等待**：请求进入临界区的线程，应保证在有限时间内进入自己的临界区，避免死等
* **让权等待**：当线程不能进入自己的临界区时，应立即释放 CPU，避免忙等

#### ② 互斥/悲观锁

悲观锁同时只允许 `1` 个线程进入临界区，让临界区互斥，具有强烈的排他性，对修改持保守态度

#### ③ 信号量

信号量同时允许`给定数量`的线程进入临界区，其实就是给临界资源上 n 把锁，先到的线程就取一把钥匙，出来时再把钥匙挂回原处，后到的线程发现钥匙架空了就在门口排队

#### ④ 乐观锁

乐观锁同时允许`所有`线程进入临界区，例如版本控制工具 Git，允许大家一起编辑，各自将结果存在本地，但都可以向远程仓库提交，如果没有版本冲突就可以提交成功，否则会提交失败，先提交的人被采纳，后提交的人负责解决冲突

例如 Git 仓库当前版本为 100，A 和 B 将版本 100 拷贝到本地同时修改代码，A 修改到版本 101，B 修改到版本 102，如果 A 先提交，当前 Git 仓库版本为 101，此时 B 再提交就会失败，因为版本已经不是 100 而是 101，B 就需要将最新版本 101 的代码 fetch 到本地，然后合并冲突，再尝试提交一个更新的版本 103

```js
cas(&version, 100, 101); // 成功
cas(&version, 100, 102); // 失败，因为此时 version 是 101
```

#### ⑤ 区块链

传统的架构之所以害怕并发，是因为`中心化`

例如淘宝双十一，用户可以直接和商家下单，而不需要通过淘宝的中心系统，这就相当于实现了同步，这是一个去中心化的方案，让业务不需要集中处理

* **信用问题**：`电子合同`技术实现了用户直接和商家签订合同，无需平台的中心系统下单
  
  例如 A 向苹果店 B 购买了一个 iphone，那么双方签订的电子合同 C 如下

  ```js
  //A同意给B转10000块钱，如果A收到了phone不给B打钱，B就可以拿着这个电子合同去法院告A，因为这个电子合同具有A的签名
  1、from=A，to=B，price=10000，signature=A的签名

  //B同意给A一个phone，如果B收到了A的钱不给A一个phone，A就可以拿着这个电子合同去法院告B，因为这个电子合同具有B的签名
  2、from=B，to=A，object=phone，signature=B的签名
  ```

* **货币和库存的问题**：A 如何证明自己有足够的钱买 iphone？B 如何证明自己有足够的 iphone？
  
  在某个对外开放的节点中记录了以下信息，假如全世界所有人的钱都放在这个系统里，这样就无需关心钱从哪里来，这样的结构也叫做区块链，每个 block 下可以存储一些数据，每个 block 知道上一个节点是谁，也有上一个节点的摘要签名，可以证明上一个节点的数据没有被篡改过

  区块链构成了一个`基于历史版本的事实链`，前一个版本是后一个版本的历史

  ```js
  1、account=A，money=20000
  2、account=B，iphone=100
  ...
  ```

  ![货币和库存的问题](https://github.com/yuyuyuzhang/Blog/blob/master/images/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%B4%A7%E5%B8%81%E5%92%8C%E5%BA%93%E5%AD%98%E7%9A%84%E9%97%AE%E9%A2%98.png)

* **购买转账的问题**：A 向苹果店 B 购买了 iphone，需要提交电子合同的 2 条新数据到上面的区块链
  
  那么我们可以在末端节点上再增加一个区块表示这次交易，例如 A 先在本地完成这件事，本地的区块链就会像上图所示，假如有一个中心化服务器，专门接受这些区块数据，A 接下来就可以将数据提交到中心化服务器，苹果店 B 从中心化服务器看到这条信息，认为交易被 A 执行了，就可以准备发货

  如果世界上有很多人同时在这个末端节点上写新的 block，就可以考虑由一个可信任的中心服务帮助合并新增的区块数据，例如 Git 由很多人同时修改代码，先提交的被采纳，后提交的负责解决冲突，避免同时操作产生混乱

  ![购买转账的问题](https://github.com/yuyuyuzhang/Blog/blob/master/images/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%B4%AD%E4%B9%B0%E8%BD%AC%E8%B4%A6%E7%9A%84%E9%97%AE%E9%A2%98.png)

* **欺诈问题**：正常情况下所有记录都可以被合并，例如 A 在一家苹果店 B 购买了 1 个 iphone，在另一家苹果店 C 购买了 2 个 iphone，而 A 只有 20000 块钱，这时 A 的钱就不够付款了，如果 A 想用 20000 块钱买 3 个 iphone，就需要修改自己的余额，那么 A 如何做？

  A 需要新增一个末端节点，在末端节点上修改自己的余额为 999999，那么 A 的余额就和之前的 block 记录冲突，简单一查就知道 A 在欺诈，如果 A 想要修改之前节点的数据，这个节点的摘要签名就会发生变化，通过验证签名就知道 A 在欺诈，如果 A 修改了之前所有节点的数据以及所有的摘要签名，通过验证其中几个节点和中心服务的签名就知道 A 在欺诈

  因此`区块链一旦写入就不能修改`，这样可以防止很多欺诈行为

* **并发问题**：假如全球几十亿人都在下单，那么每次下单都需要创建一个新的 block，这种情况下会导致后面的 block 产生很多分支

  ![并发问题1](https://github.com/yuyuyuzhang/Blog/blob/master/images/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%981.png)

  这时会发现，这里有同步问题，最傻的方案就是使用锁解决，例如用一个集中式方法接收所有请求，这样又回到中心化设计

  高明的方案就是允许商家开分支，用户和苹果店签合同，苹果店独立做一个分支联合本店所有用户的合同，这样苹果店先维护自己的区块链，等待合适的时机合并到主干分支，如果有合同合并不进去（例如余额不足），就直接作废这个合同（不发货）

  ![并发问题2](https://github.com/yuyuyuzhang/Blog/blob/master/images/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%982.png)

  如果全世界每天有 1000 亿笔订单要处理，可以先拆分成 100 个区域，每个区域 10 万家店，这样最终每家店的并发量在 10000 单，可以考虑每过多长时间，就进行一次逐级合并，这样整体上每个节点的压力就不是很大了

### (4) 虚拟

通过`时分复用技术`将一个物理实体变成若干个逻辑上的虚拟实体

#### ① 虚拟 CPU

为内存中的每个应用程序建立至少一个进程，让多个应用程序`并发`执行，此时虽然计算机只有一个 CPU，但是通过时分复用的虚拟 CPU 技术，能够实现宏观上的同时为多个用户服务，使每个终端用户都认为有一个 CPU 专门为其服务

#### ② 虚拟设备

将一台物理 IO 设备虚拟为多台逻辑 IO 设备，并让每个用户占用一台逻辑 IO 设备，这样就可以让`独占资源变成共享资源`，宏观上实现为多个用户服务

### (5) 异步

对于内存中的每个进程，何时能够获得 CPU 运行，何时因提出某种资源请求而暂停，进程以怎样的速度推进，进程需要多少时间才能完成，这些都是不可预知的

由于各个应用程序的性能不同，比如有的侧重于计算而有的侧重于 IO，因此很有可能先进入内存的应用程序后完成，而后进入内存的应用程序先完成，这就是`进程的异步性`
