# 六、内存管理

[[_TOC_]]

## 1. 存储器分级策略

### (1) 为什么会有存储器分级策略

#### ① 我们的需求是什么

我们希望存储器`速度快、体积小、空间大、能耗低、断电数据不丢失`

#### ② 需求的实现制约

现实中我们往往无法实现所有需求

* 存储器体积小 => 存储控件收到制约
* 存储器电子元件密度很大 => 散热会有问题
* 存储器距离 CPU 远 => 传输会有延迟，传输速度下降
  * 信号是以`光速`传输的，宏观世界里光速很快，但在计算机世界里光速并没有想象的那么快，时钟信号为 1GHz 的 CPU，时钟信号的一个周期为 1/10 亿秒，光速为 3 亿米每秒，因此一个时钟周期内，光只能前进 30 厘米，因此即使存储器距离 CPU 稍微远了一点，运行速度也会下降非常明显
  * 为什么不将内存放到 CPU：CPU 整个电路的散热和体积会出现问题，并且服务器无法再定制内存，也就是说 CPU 在出场时就决定了其内存大小，如果想更换更大的内存就必须更换 CPU，而`组装定制化`是非常重要的诉求

#### ③ 需求的分级实现

既然无法用一块存储器实现所有的需求，那就将需求`分级实现`

根据`数据的使用频率`使用不同的存储器，高频使用的数据，使用最贵的材料放到距离 CPU 最近的位置，读写速度最快，低频使用的数据，使用便宜的材料放到距离 CPU 较远的位置，读写速度较慢

### (2) 存储器分级策略

通常将存储器分成以下几个级别

#### ① 寄存器

* 寄存器紧挨 CPU 的控制单元和逻辑运算单元
* 寄存器主要用于暂存 `CPU 执行计算机程序时的操作数据和中间结果`，寄存器具有与 CPU 相同的速度，完全能与 CPU 协调工作

#### ② L1-Cache

* L1-Cache 位于 CPU，相比寄存器位置距离 CPU 核心更远，但造价更低，通常 L1-Cache 大小在几十 Kb 到几百 Kb 不等，读写速度在 `2~4` 个 CPU 时钟周期
* L1-Cache 主要用于存放 `CPU 将要运行或刚运行过的程序和数据`，也就是备份内存中 CPU 常用的数据，减少 CPU 对内存的访问次数，用于`解决 CPU 和内存间的速度匹配问题`

#### ③ L2-Cache

* L2-Cache 位于 CPU，相比 L1-Cache 位置距离 CPU 核心更远，但造价更低，大小比 L1-Cache 更大但具体大小要看 CPU 型号，读写速度在 `10~20` 个 CPU 周期
* L2-Cache 主要用于存放 `CPU 将要运行或刚运行过的程序和数据`，也就是备份内存中 CPU 常用的数据，减少 CPU 对内存的访问次数，用于`解决 CPU 和内存间的速度匹配问题`

#### ④ L3-Cache

* L3-Cache 位于 CPU，相比 L2-Cache 位置距离 CPU 核心更远，但造价更低，大小比 L2-Cache 更大但具体大小要看 CPU 型号，读写速度在 `20~60` 个 CPU 周期
* L3-Cache 主要用于存放 `CPU 将要运行或刚运行过的程序和数据`，也就是备份内存中 CPU 常用的数据，减少 CPU 对内存的访问次数，用于`解决 CPU 和内存间的速度匹配问题`

#### ⑤ 内存

* 内存的主要材料是`半导体硅`，插在主板上工作，距离 CPU 有一段距离，因此需要用`总线`和 CPU 连接
* 内存有了独立的空间，因此体积更大，造价也比上面的缓存更低，个人电脑的内存通常是 16G，有些服务器内存可以到几个 T
* 内存的读写速度大概在 `200~300` 个 CPU 周期
* 内存主要用于存放`运行中的程序和数据`，CPU 能够直接访问内存

#### ⑥ 磁盘、固态硬盘 SSD

* 磁盘、固态硬盘 SSD 的结构和内存类似，优点在于`断电后数据不丢失`，寄存器、缓存、内存断点后数据就丢失了
* 磁盘主要用于存放`未运行的程序和数据`，磁盘的信息必须`调入内存`后才能被 CPU 使用

![存储器分级策略]()

### (3) 内存数据查找

CPU 需要`内存`中某个数据时，按照以下顺序查找，最后没有才从`内存`中拿

![数据查找]()

### (4) 缓存条目结构

#### ① 线性存储器

缓存和内存都是线性存储器，也就是`数据一个个挨着存储`，如果把内存想象成一个只有`一列`的表格，那么缓存就是一个`多列`的表格，表格的每一行就是一个缓存条目

#### ② 2 列缓存条目

缓存本质上是存储 key-value 键值对，key - 内存地址，value - 对应内存地址中的值，因此我们可以将一个缓存条目设计成 2 列，CPU 读取到一个内存地址，就增加一个缓存条目，当 CPU 需要内存中某个数据时，先遍历 L1-Cache 每个缓存条目中的内存地址是否与查询的内存地址一致，一致就取出对应缓存条目中的值

这个方法需要遍历 L1-Cache 中的每个缓存条目，因此速度非常慢，最坏的情况下需要检查所有的缓存条目，因此该方案不可行

#### ③ 哈希函数映射缓存条目

我们需要一个更好的方法，让我们看到内存地址，就知道其在哪个缓存条目

例如有 1000 个内存地址编号为 0~999，10 个缓存条目编号为 0~9，每个内存编号用`数学方法`映射到一个缓存条目，例如内存地址 701 整除 10 得到缓存条目 1，这就构成了一个简单的`哈希函数：地址 % 10`，知道缓存条目后，再比较第一列内存地址和查询的内存地址是否相同

### (5) L1-Cache 指令预读

#### ① 为什么需要指令预读

* CPU 顺序执行内存中的指令，CPU 执行指令的速度一般在 `2~6` 个 CPU 时钟周期
* 由于存储器分级策略，内存的读写速度一般在 `200~300` 个 CPU 时钟周期
* 因此 CPU 不能从内存中一条条读取指令再执行，否则执行每条指令都需要 200~300 个 CPU 时钟周期

#### ② 指令预读的实现

* CPU 将内存中的指令预读几十上百条到 `L1-Cache`，因为 L1-Cache 的读写速度一般在 `2~4` 个时钟周期，可以跟的上 CPU 的指令执行速度
* 如果指令和数据都缓存在 L1-Cache，当数据缓存覆盖了指令缓存，就会造成很严重的后果，因此 L1-Cache 通常会分成`指令区`和`数据区`
* L2-Cache、L3-Cache 无需协助处理指令预读的问题，因此无需分成指令区和数据区

### (6) 缓存命中率

#### ① 命中

在缓存中找到需要的数据

#### ② 穿透

未从缓存中找到需要的数据

#### ③ 缓存命中率

* L1-Cache 的命中率在 `80%`，L1-Cache、L2-Cache、L3-Cache 加起来的命中率在 `95%`
* CPU 缓存的设计相当合理，95% 能名字缓存，只有 5% 会穿透到内存
* 正是由于缓存保证了很高的命中率，所以程序语言逐渐取消了让程序员操作寄存器的语法，多余的优化意义不大，而且容易出错

### (7) 缓存置换问题

L1-Cache 的缓存条目已满，CPU 又读取了内存，需要增加一个缓存条目到 L1-Cache，那么这个时候就需要一个算法计算 L1-Cache 中哪个旧的缓存条目被置换出去，这就是缓存置换问题

## 2. 虚拟内存

### (1) 虚拟内存的定义

用户看到应用程序能在操作系统中正常运行，认为计算机的内存容量比应用程序大，也就是说用户感受到的内存容量比实际内存容量大的多，但用户看到的大容量只是一种错觉，是虚的，这就是虚拟内存

虚拟内存是指具有`请求调入和置换功能`，能从逻辑上对内存容量加以扩充的一种方式，虚拟内存的逻辑容量由`内存容量和磁盘容量之和`决定

### (2) 虚拟内存的特征

#### ① 多次性

要执行的应用程序的程序和数据无需一次性装入内存，只需将当前要运行的那部分程序和数据装入内存即可开始运行，每当要运行到尚未装入内存的程序时，再将需要的程序和数据装入内存

#### ② 对换性

正在执行的应用程序的程序和数据，无需一直常驻内存，可以在执行过程中换进（从磁盘装入内存）、换出（从内存调至磁盘），也就是将暂不使用的程序和数据换出，等待将要使用时再换进

#### ③ 虚拟性

从逻辑上扩充内存容量，使用户看到的内存容量远大于实际内存容量

## 3. 内存保护

① 确保每个应用程序仅在自己的内存空间内运行，彼此互不干扰

② 不允许应用程序访问操作系统的程序和数据

## 4. 内存分类

当我们在电脑上双击打开 QQ 时，通过鼠标向 CPU 发送一条指令，CPU 接收到指令后将 QQ 程序从磁盘加载到内存，加载完成后 CPU 开始执行 QQ 程序，执行完成后 CPU 让 QQ 程序显示在显示器上，也就是用户看到的最终结果

CPU 在内存中运行应用程序时，需要内存空间存放数据，操作系统会划分出两种不同的内容空间用于存放数据，一种是堆，一种是栈

### (1) 进程和线程

* **进程**：进程是一个`可拥有资源`的基本单位
  
  **进程实体**：进程控制块 PCB、程序代码、相关的数据

  **进程资源**：进程可拥有的资源指的是计算机系统资源，主要是指 内存、IO 设备 ( 磁盘、输入设备、输出设备 )

* **线程**：线程是一个`可独立调度`的基本单位 ( 从进程的 2 个基本属性中分离出的 )
  
  **线程实体**：线程控制块 TCB、程序代码，相关的数据

### (2) 堆内存（Heap）

* 每个`进程`分配一个堆，堆是该进程的所有线程共享的
* 堆的大小不确定，需要的话可以不断增加
* 堆是没有结构的，数据可以任意存放

### (3) 栈内存（Stack）

* 每个`线程`分配一个栈，栈是每个线程独占的
* 栈的大小确定，数据超过这个大小，就会发生栈溢出
* 栈是有结构的，数据按照一定次序存放，可以明确知道每个数据的大小
