# 一、语法

[[_TOC_]]

## 1. 语法

### (1) 标识符

变量、函数、属性的名字，或者函数的参数

① 不能将关键字、保留字、null、true、false用作标识符

### (2) 关键字

用于表示控制语句的开始或结束、用于执行特定操作等

### (3) 保留字

没有特定的用途，可能在将来被用作关键字

### (4) 命名规范

① 文件名：下划线 ( my_file.js )

② css 类名：连字符 ( .my-class )

③ js 常量：所有字母均大写，下划线 ( MY_CONST )

④ js 变量 & 函数：小驼峰法 ( myVar、myFun )

⑤ js 构造函数 & 类：小驼峰法 ( MyConstructor、myClass )

⑥ js 类成员：

公有属性、方法：小驼峰法 ( myAttr、myFun )

私有属性、方法：下划线 + 小驼峰法 (  _myAttr、_myFun)

⑦ 注释：

```javascript
//单行注释


/* 多行注释

 * @param

 * @author

 * @date 

 */
```

## 2. 操作符

### (1) 加性操作符

#### +

① 对于undefined、null、布尔值调用Number()，执行数值加法 

① 若一个操作符是字符串，则将另一个操作符转换成字符串，执行`字符串拼接`

② 若一个操作数是对象，调用valueOf()、没有则调用toString()后再转换成数值，执行数值加法

#### -

① 对于undefined、null、布尔值、字符串调用Number()，执行数值减法 

② 若一个操作数是对象，调用valueOf()、没有则调用toString()后再转换成数值，执行数值减法

```javascript
var num1 = 1;
var num2 = 2;
console.log("sum is" + num1 + num2);   //"sum is 12"
console.log("sum is" + (num1 + num2)); //"sum is 3"
```

### (2) 关系操作符

#### <、<=、>、>=

① 执行数值比较

② 若两个操作数都是字符串，依次比较两个字符串对应位置的`字符编码`

③ 若一个操作数是对象，则调用 valueOf()，没有调用 toString()，然后按照上述比较

```javascript
//若要按字母表顺序比较,须将两个字母字符串转换成相同的大小写形式
console.log("Bite" > "ack"); //false
console.log("Bite".toLowerCase() > "ack".toLowerCase()); //true

//比较两个数字字符串时,须将其中一个数字字符串转换成数值形式
console.log("20" < "3"); //true
console.log(parseInt("20", 10) < "3"); //false
```

### (3) 相等操作符

#### ==、!=

① undefined、null比较之前无需转换成数值类型，并且`undefined == null`

② 其他基本数据类型操作数比较之前，需将操作数转换成`数值`

③ 引用类型操作数，则比较是否为`同一个对象`

④ NaN与任何值不相等 

⑤ 因为相等操作符比较会进行`强制类型转换`，不推荐使用相等操作符

### (4) 全等操作符

#### ===、!==

① 全等操作符比较之前不进行数据类型转换，推荐使用全等操作符

### (5) 条件操作符

var x = bool_expression  ?  value1  :  value2;

① bool_expression为true，则x=value1，否则，x=value2

## 3. 语句

### (1) return

**① return**：终止当前函数并返回undefined，将控制权返回给主调函数继续执行 

**② return value**：终止当前函数并返回value，将控制权返回给主调函数继续执行 

**③ return true**：终止当前函数并返回true，`执行默认行为` 

**④ return false**：终止当前函数并返回flase，`阻止默认行为`

```javascript
<a href="https://fanyi.baidu.com" onclick="return true">百度翻译</a>
<a href="https://fanyi.baidu.com" onclick="return false">百度翻译</a>

//<a href="https://fanyi.baidu.com" id="a">百度翻译</a>
//<a href="https://fanyi.baidu.com" id="b">百度翻译</a>
var a = document.getElementById('a');
var b = document.getElementById('b');
a.onclick = function(){
  console.log(this.id);
  return true;
}
b.onclick = function(){
  console.log(this.id);
  return false;
}
```

### (2) switch

**①** 比较值时使用全等操作符`===`，不会发生类型转换 

**②** switch语句可以使用`任意数据类型`，无论数值、字符串、对象等等，case值也可以是常量、变量甚至表达式 

**③** break关键字会使`执行流跳出switch语句`，省略break会导致执行完当前case，继续执行下一个case

```javascript
switch(n){
  case 1:
    console.log(1);
    break;
  case 2:
    console.log(2);
    break;
  default:
    console.log('haha'); //default语句无需break
}
```

### (3) for

ES5 中没有块级作用域，for 循环参数变量i和循环体内的变量 i 都是全局作用域

```javascript
//情况1
for(var i=0; i<5; i++){
  console.log(i); //0 1 2 3 4
}

//情况2
for(var i=0; i<5; i++){
  var i = 4;
  console.log(i); //4
}

//情况3
for(var i=0; i<5; i++){
  var i = 3;
  console.log(i); //3...,无限循环,浏览器卡死
}
```

### (4) break

① switch：跳出switch 

② 单层 for/for-in/while/do-while：跳出循环 

③ 多层 for：跳出最近的内层循环

```javascript
var num = 0;
for(var i=0; i<10; i++){
  for(var j=0; j<10; j++){
    if(i == 5 && j == 5){
      break; 
    }
    num++;
  }
}
console.log(num); //95
```

### (5) continue

① 单层 for/for-in/while/do-while：跳出本次循环，执行下次循环 

② 多层 for：跳出所在层次本次循环，执行所在层次下次循环

```javascript
var num = 0;
for(var i=0; i<10; i++){
  for(var j=0; j<10; j++){
    if(i == 5 && j == 5){
      continue; 
    }
    num++;
  }
}
console.log(num); //99
```

### (6) label

**① break**：跳出标签outer，执行`outer下一语句`

**② continue**：跳出至标签outer处，执行`outer`

```javascript
var num = 0;
outer:for(var i=0; i<10; i++){
        for(var j=0; j<10; j++){
          if(i == 5 && j == 5){
            break outer; 
          }
          num++;
        }
      }
console.log(num); //55

var num = 0;
outer:for(var i=0; i<10; i++){
        for(var j=0; j<10; j++){
          if(i == 5 && j == 5){
            continue outer; 
          }
          num++;
        }
      }
console.log(num); //95
```

### (7) with

① 将代码的作用域设置到`一个特定的对象`中，并且可以简化多次编写同一个对象的工作 

② with语句内部，每个变量首先被认为是所在函数的局部变量，若函数执行环境中找不带该变量的声明，则查询with语句的关联对象中是否有同名属性，若有，则以其属性值作为变量值 

③ with语句无法在编译时确定，属性归属于哪个对象，属于`动态绑定`，因此会导致性能下降，也会给调试代码造成困难，不推荐使用with语句

```javascript
var hostName = location.hostName;
var url = location.href;

//简化为：
with(location){ //with语句关联Location对象
  var hostName = hostName;
  var url = href;
}
```

## 4. 严格模式

严格模式为ES提供了一种`不同的解析与执行模型`，严格模式下，ES5的一些不确定行为将得到处理，某些不安全的操作也会禁止，支持严格模式的引擎遇到编译指令会启动严格模式，而不支持的引擎就当遇到了一个未赋值的字符串字面量，会忽略这个编译指令

```javascript
//整个JS脚本,必须放在脚本文件第一行
'use strict';

//单个函数,必须放在函数体第一行
function f(){
  'use strict';
}
```

### (1) 增强的安全措施

#### ① 禁止前缀0的八进制表示法

正常模式下，整数第一位为0，表示八进制数，严格模式下，禁止这种表示法，整数第一位为0将报错

```javascript
'use strict';

console.log(0100); //SyntaxError, 正常模式:1
```

### (2) 对象

#### ① 禁止对象有重名属性

正常模式下，对象后声明的属性会`覆盖`先声明的重名属性，严格模式下抛出语法错误

```javascript
'use strict';

var obj = {
  a: 1,
  a: 2
}
console.log(obj.a); //SyntaxError, 正常模式:2
```

### (3) 变量

#### ① 禁止使用新增的保留字作为变量名

#### ② 禁止创建意外的全局变量

正常模式下，变量未声明就赋值，默认全局变量，严格模式下会抛出语法错误

```javascript
'use strict';

a = 1; //ReferenceError
```

#### ③ 禁止使用delete操作符删除变量

正常模式下，使用delete删除变量，会静默失败并返回false，严格模式下会抛出语法错误，delete只能删除属性描述对象设置可写的对象属性

```javascript
'use strict';

var b = 2;
delete b; //SyntaxError
```

### (4) 函数

#### ① 禁止使用新增的保留字作为函数名

#### ② 禁止在非函数代码块声明函数

正常模式下，可以在非函数代码块声明函数（如if语句），为了与ES6的块级作用域接轨，严格模式下会抛出语法错误

```javascript
'use strict';

if(true){
  function f(){} //SyntaxError
}
```

#### ③ 禁止函数有重名参数

正常模式下，函数的重名参数使用`arguments[i]`读取，严格模式下会抛出语法报错

```javascript
'use strict';

function f(a, a){
  console.log(arguments[0] + arguments[1]);
}
f(1, 2); //SyntaxError, 正常模式:3
```

#### ④ 禁止使用函数的caller属性

正常模式下，函数的caller属性指向`调用当前函数的函数`，严格模式下会抛出语法错误

```javascript
'use strict';

function f1(){
  function f2(){
      console.log(f2.caller);
  }
  f2();
}
f1(); //TypeError, 正常模式:function f1(){}
```

#### ⑤ 禁止函数内的this指针指向全局对象

正常模式下，函数内的this指针未指定时，指向全局对象，使用 call()、apply() 时，undefined和null值也会被转换成全局对象，严格模式下，this始终指向指定的值，无论什么值，未指定则`默认undefined`

```javascript
'use strict';

function f(){
  console.log(this);
}
f();               //undefined, 正常模式:window
f.call(undefined); //undefined, 正常模式:window
f.call(null);      //null,      正常模式:window
```

### (5) arguments对象

#### ① 禁止对arguments对象赋值

正常模式下，可以对arguments对象赋值，严格模式下会静默失败

```javascript
'use strict';

function f(a){
  arguments[0] = 2;
  console.log(a);
}
f(1); //1, 正常模式:2
```

#### ② 禁止arguments对象追踪函数参数变化

正常模式下，arguments对象与函数参数间存在`联动关系`，值永远保持`同步`，严格模式下arguments对象无法再追踪函数参数的变化

```javascript
'use strict';

function f(a){
  a = 2;
  console.log(arguments[0]);
}
f(1); //1, 正常模式:2
```

#### ③ 禁止使用arguments.callee

正常模式下，arguments.callee属性指向`当前函数`，严格模式下会抛出语法错误

```javascript
'use strict';

function factorial(num){ 
  if(num < 2){
    return 1;
  } else{
    return num * arguments.callee(num-1);
  }
}
console.log(factorial(2)); //TypeError, 正常模式:2
```

### (6) 静态绑定

某些情况下，ES5允许动态绑定，即某些属性和方法归属于哪个对象，可以在运行时确定，严格模式下，仅允许静态绑定，即属性和方法归属于哪个对象，必须在编译时确定，有利于编译效率的提高，使代码更易阅读，更少出现意外 

#### ① 禁止使用with语句

正常模式下，可以使用with语句，严格模式下会抛出语法错误

```javascript
'use strict';

with(location){ //SyntaxError
  var hostName = hostName;
  var url = href;
}
```

#### ② 创建eval作用域

正常模式下，eval语句中创建的变量和函数会被添加到所在执行环境，严格模式下，eval语句会`创建自身的执行环境`

```javascript
'use strict';

eval("function sayhi(){console.log('hi')}");
sayhi(); //ReferenceError, 正常模式:"hi"
```
