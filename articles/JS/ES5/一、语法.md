# 一、语法

[[_TOC_]]

## 1. 语法

### (1) 标识符

变量、函数、属性的名字，或者函数的参数

① 不能将关键字、保留字、null、true、false用作标识符

### (2) 关键字

用于表示控制语句的开始或结束、用于执行特定操作等

### (3) 保留字

没有特定的用途，可能在将来被用作关键字

### (4) 命名规范

① 文件名：下划线 ( my_file.js )

② css 类名：连字符 ( .my-class )

③ js 常量：所有字母均大写，下划线 ( MY_CONST )

④ js 变量 & 函数：小驼峰法 ( myVar、myFun )

⑤ js 构造函数 & 类：小驼峰法 ( MyConstructor、myClass )

⑥ js 类成员：

公有属性、方法：小驼峰法 ( myAttr、myFun )

私有属性、方法：下划线 + 小驼峰法 (  _myAttr、_myFun)

⑦ 注释：

```javascript
//单行注释

/* 多行注释
 * @param
 * @author
 * @date
 */
```

## 2. 操作符

### (1) 位操作符 ( 不推荐使用 )

ES 中所有数值都按照 `IEEE-754 64 位`格式存储，位操作符按内存中数值的位来操作数值，但位操作符并不直接操作 64 位数值，而是将 64 位数值转换成 `32 位整数`，然后执行操作，最后再将结果转换回 64 位

* 按位非 ~  
* 按位与 &
* 按位或 |
* 按位异或 ^
* 左移 <<
* 有符号右移 >>
* 无符号右移 >>>

### (2) 一元操作符

`只能操作一个操作数`的操作符叫做一元操作符

#### ① 递增 ++、递减 --

递增和递减操作符直接借鉴自 C，各有前置性和后置型两个版本

* 前置性：递增和递减操作在`语句求值之前`执行
* 后置型：递增和递减操作在`语句求值之后`执行

```javascript
//前置性
var a = 20;
var b = --a + 2;
console.log(a); //19
console.log(b); //21

//后置型
var a = 20;
var b = a++ + 2;
console.log(a); //21
console.log(b); //22
```

递增递减操作符应用于不同数据类型时，遵循以下规则

* 应用于 undefined 时，变量值为 `NaN`
* 应用于 null 时，先将其转换为数字 `0`，再执行递增递减操作
* 应用于布尔值时，先将其转换为数字 `0 或 1`，再执行递增递减操作
* 应用于`仅包含`数字字符的字符串时，先将其转换为数字，再执行递增递减操作
* 应用于`其他`字符串时，变量值为 `NaN`
* 应用于对象时，先调用对象的 `valueOf()` 方法应用上述规则，如果结果是 `NaN`，在调用对象的 `toString()` 方法应用上述规则

```javascript
var a = undefined;
var b = null;
var c = false;
var d = NaN;
var e = 11;
var f = '22';
var g = 's11s';
var h = {aa: 33}
var i = {
  valueOf(){
    return 33
  }
}

console.log(++a); //NaN
console.log(++b); //1
console.log(++c); //1
console.log(++d); //NaN
console.log(++e); //12
console.log(++f); //23
console.log(++g); //NaN
console.log(++h); //NaN
console.log(++i); //34
```

#### ② 一元加 +、一元减 -

一元加减操作符的作用如下

* 一元加操作符放在`数值`前面，`不会对数值产生任何影响`
* 一元减操作符放在`数值`前面，用于表示`负数`

```javascript
console.log(+1); //1
console.log(-1); //-1
```

一元加减操作符应用于不同数据类型时，需要遵循以下规则

* 应用于 undefined 时，变量值为 `NaN`
* 应用于 null 时，先将其转换为数字 `0`，再执行一元加减操作
* 应用于布尔值时，先将其转换为数字 `0 或 1`，再执行一元加减操作
* 应用于`仅包含`数字字符的字符串时，先将其转换为数字，再执行一元加减操作
* 应用于`其他`字符串时，变量值为 `NaN`
* 应用于对象时，先调用对象的 `valueOf()` 方法应用上述规则，如果结果是 `NaN`，在调用对象的 `toString()` 方法应用上述规则

```javascript
var a = undefined;
var b = null;
var c = false;
var d = NaN;
var e = 11;
var f = '22';
var g = 's11s';
var h = {aa: 33}
var i = {
  valueOf(){
    return 33
  }
}

console.log(+a); //NaN
console.log(+b); //0
console.log(+c); //0
console.log(+d); //NaN
console.log(+e); //11
console.log(+f); //22
console.log(+g); //NaN
console.log(+h); //NaN
console.log(+i); //33

console.log(-a); //NaN
console.log(-b); //-0
console.log(-c); //-0
console.log(-d); //NaN
console.log(-e); //-11
console.log(-f); //-22
console.log(-g); //NaN
console.log(-h); //NaN
console.log(-i); //-33
```

### (3) 布尔操作符

#### ① 逻辑非 !

逻辑非操作符会先调用 `Boolean()` 将操作数转换为`布尔值`，再对其求反

```javascript
var a = undefined;
var b = null;
var c = false;
var d = NaN;
var e = 11;
var f = '22';
var g = 's11s';
var h = {aa: 33}
var i = {
  valueOf(){
    return 33
  }
}

console.log(!a); //true
console.log(!b); //true
console.log(!c); //true
console.log(!d); //true
console.log(!e); //false
console.log(!f); //false
console.log(!g); //false
console.log(!h); //false
console.log(!i); //false
```

#### ② 逻辑与 &&

逻辑与操作符是`短路操作符`，如果第一个操作符求值结果为 false，就不会对第二个操作符求值

* 第一个操作数求值结果为 false，返回 false
* 第一个操作数求值结果为 true，返回第二个操作数
* 第一个操作数是 undefined，返回 undefined
* 第一个操作数是 null，返回 null
* 第一个操作数是 NaN，返回 NaN
* 第一个操作数是对象，返回第二个操作数

```javascript
var a = undefined;
var b = null;
var c = false;
var d = true;
var e = NaN;
var f = 0;
var g = 1;
var h = '22';
var i = 's11s';
var j = {aa: 33}
var k = {
  valueOf(){
    return 33
  }
}

console.log(a && a); //undefined
console.log(b && b); //null
console.log(c && i); //false
console.log(d && i); //{aa: 33}
console.log(e && e); //NaN
console.log(f && f); //11
console.log(g && g); //'22'
console.log(h && h); //'s11s'
console.log(i && i); //{aa: 33}
console.log(j && j); //{valueOf: {return 33}}
```

#### ③ 逻辑或 ||

逻辑与操作符是`短路操作符`，如果第一个操作符求值结果为 true，就不会对第二个操作符求值

* 第一个操作数求值结果为 true，返回 true
* 第一个操作数求值结果为 false，返回第二个操作数
* 两个操作数都是 undefined，返回 undefined
* 两个操作数都是 null，返回 null
* 两个操作数都是 NaN，返回 NaN
* 第一个操作数是对象，返回第一个操作数

```javascript
var a = undefined;
var b = null;
var c = false;
var d = true;
var e = NaN;
var f = 11;
var g = '22';
var h = 's11s';
var i = {aa: 33}
var j = {
  valueOf(){
    return 33
  }
}

console.log(a || a); //undefined
console.log(b || b); //null
console.log(c || i); //{aa: 33}
console.log(d || i); //true
console.log(e || e); //NaN
console.log(f || f); //11
console.log(g || g); //'22'
console.log(h || h); //'s11s'
console.log(i || i); //{aa: 33}
console.log(j || j); //{valueOf(){return 33}}

// console.log(false || a); //undefined
// console.log(false || b); //null
// console.log(false || c); //false
// console.log(false || d); //NaN
// console.log(false || e); //11
// console.log(false || f); //'22'
// console.log(false || g); //'s11s'
// console.log(false || h); //{aa: 33}
// console.log(false || i); //{valueOf(){return 33}}

console.log(a || false); //false
console.log(b || false); //false
console.log(c || false); //false
console.log(d || false); //false
console.log(e || true);  //true
console.log(f || false);  //true
console.log(g || false);  //true
console.log(h || false);  //true
console.log(i || false);  //true

console.log(a || true); //undefined
console.log(b || true); //null
console.log(d || true); //NaN

console.log(h || true); //{aa: 33}
console.log(i || false); //{valueOf(){return 33}}
```

### (3) 加性操作符

#### 加 +、减 -

* 对于 undefined、null、布尔值调用 Number()，执行数值加减法
* 若一个操作数是字符串，则将另一个操作数转换成字符串，执行`字符串拼接`
* 若一个操作数是对象，调用 valueOf()、没有则调用 toString()，之后再转换成数值，执行数值加减法

```javascript
//情况1

//情况2
var num1 = 1;
var num2 = 2;
console.log("sum is " + num1 + num2);   //"sum is 12"
console.log("sum is " + (num1 + num2)); //"sum is 3"

//情况3
```

```javascript
var a = undefined;
var b = null;
var c = false;
var d = NaN;
var e = 11;
var f = '22';
var g = 's11s';
var h = {aa: 33}
var i = {
  valueOf(){
    return 33
  }
}
```

### (4) 乘性操作符

乘性操作符会先调用 `Number()` 将操作数转换为数值

#### 乘法 *

#### 除法 /

#### 求模 %

### (5) 赋值操作符

赋值操作符的作用就是将右侧的值赋给左侧的变量

每个主要算术操作符都有对应的复合赋值操作符

* 加赋值 +=
* 减赋值 -=
* 乘赋值 *=
* 除赋值 /=
* 模赋值 %=
* 左移赋值 <<=
* 有符号右移赋值 >>=
* 无符号右移赋值 >>>=

### (6) 关系操作符

#### 小于 <、小于等于<=、大于>、大于等于>=

* 执行数值比较
* 若两个操作数都是字符串，依次比较两个字符串对应位置的`字符编码`
* 若一个操作数是对象，则调用 valueOf()，没有调用 toString()，然后按照上述比较

```javascript
//若要按字母表顺序比较,须将两个字母字符串转换成相同的大小写形式
console.log("Bite" > "ack"); //false
console.log("Bite".toLowerCase() > "ack".toLowerCase()); //true

//比较两个数字字符串时,须将其中一个数字字符串转换成数值形式
console.log("20" < "3"); //true
console.log(parseInt("20", 10) < "3"); //false
```

### (7) 相等操作符

#### ① 相等 ==、不相等 !=

* undefined、null 比较之前无需转换成数值类型，并且`undefined == null`
* 其他基本数据类型操作数比较之前，需将操作数转换成`数值`
* 引用类型操作数，则比较是否为`同一个对象`
* NaN 与任何值不相等
* 因为相等操作符比较会进行`强制类型转换`，不推荐使用相等操作符

#### ② 全等 ===、不全等 !==

* 全等操作符比较之前不进行数据类型转换，推荐使用全等操作符

### (8) 条件操作符

var x = bool_expression  ?  value1  :  value2;

* bool_expression为true，则x=value1，否则，x=value2

### (9) 逗号操作符

逗号操作符可以在`一条语句中执行多个操作`

* 声明多个变量

```javascript
var a = 1, b = 2, c= 3;
```

* 使用最后一项赋值：逗号操作符用于赋值时，总会返回表达式的最后一项

```javascript
var num = (1, 2, 3)
console.log(num); //3
```

## 3. 表达式

①②③④⑤⑥⑦⑧⑨⑩

## 4. 语句

### 语句

### (1) return

**① return**：终止当前函数并返回undefined，将控制权返回给主调函数继续执行 

**② return value**：终止当前函数并返回value，将控制权返回给主调函数继续执行 

**③ return true**：终止当前函数并返回true，`执行默认行为` 

**④ return false**：终止当前函数并返回flase，`阻止默认行为`

```javascript
<a href="https://fanyi.baidu.com" onclick="return true">百度翻译</a>
<a href="https://fanyi.baidu.com" onclick="return false">百度翻译</a>

//<a href="https://fanyi.baidu.com" id="a">百度翻译</a>
//<a href="https://fanyi.baidu.com" id="b">百度翻译</a>
var a = document.getElementById('a');
var b = document.getElementById('b');
a.onclick = function(){
  console.log(this.id);
  return true;
}
b.onclick = function(){
  console.log(this.id);
  return false;
}
```

### (2) switch

**①** 比较值时使用全等操作符`===`，不会发生类型转换 

**②** switch语句可以使用`任意数据类型`，无论数值、字符串、对象等等，case值也可以是常量、变量甚至表达式 

**③** break关键字会使`执行流跳出switch语句`，省略break会导致执行完当前case，继续执行下一个case

```javascript
switch(n){
  case 1:
    console.log(1);
    break;
  case 2:
    console.log(2);
    break;
  default:
    console.log('haha'); //default语句无需break
}
```

### (3) for

ES5 中没有块级作用域，for 循环参数变量i和循环体内的变量 i 都是全局作用域

```javascript
//情况1
for(var i=0; i<5; i++){
  console.log(i); //0 1 2 3 4
}

//情况2
for(var i=0; i<5; i++){
  var i = 4;
  console.log(i); //4
}

//情况3
for(var i=0; i<5; i++){
  var i = 3;
  console.log(i); //3...,无限循环,浏览器卡死
}
```

### (4) break

① switch：跳出switch 

② 单层 for/for-in/while/do-while：跳出循环 

③ 多层 for：跳出最近的内层循环

```javascript
var num = 0;
for(var i=0; i<10; i++){
  for(var j=0; j<10; j++){
    if(i == 5 && j == 5){
      break; 
    }
    num++;
  }
}
console.log(num); //95
```

### (5) continue

① 单层 for/for-in/while/do-while：跳出本次循环，执行下次循环 

② 多层 for：跳出所在层次本次循环，执行所在层次下次循环

```javascript
var num = 0;
for(var i=0; i<10; i++){
  for(var j=0; j<10; j++){
    if(i == 5 && j == 5){
      continue; 
    }
    num++;
  }
}
console.log(num); //99
```

### (6) label

**① break**：跳出标签outer，执行`outer下一语句`

**② continue**：跳出至标签outer处，执行`outer`

```javascript
var num = 0;
outer:for(var i=0; i<10; i++){
        for(var j=0; j<10; j++){
          if(i == 5 && j == 5){
            break outer; 
          }
          num++;
        }
      }
console.log(num); //55

var num = 0;
outer:for(var i=0; i<10; i++){
        for(var j=0; j<10; j++){
          if(i == 5 && j == 5){
            continue outer; 
          }
          num++;
        }
      }
console.log(num); //95
```

### (7) with

① 将代码的作用域设置到`一个特定的对象`中，并且可以简化多次编写同一个对象的工作 

② with语句内部，每个变量首先被认为是所在函数的局部变量，若函数执行环境中找不带该变量的声明，则查询with语句的关联对象中是否有同名属性，若有，则以其属性值作为变量值 

③ with语句无法在编译时确定，属性归属于哪个对象，属于`动态绑定`，因此会导致性能下降，也会给调试代码造成困难，不推荐使用with语句

```javascript
var hostName = location.hostName;
var url = location.href;

//简化为：
with(location){ //with语句关联Location对象
  var hostName = hostName;
  var url = href;
}
```

## 5. 严格模式

严格模式为 ES5 提供了一种`不同的解析与执行模型`，严格模式下，ES5 的一些不确定行为将得到处理，某些不安全的操作也会禁止，支持严格模式的引擎遇到编译指令会启动严格模式，而不支持的引擎就当遇到了一个未赋值的字符串字面量，会忽略这个编译指令

```javascript
//整个JS脚本,必须放在脚本文件第一行
'use strict';

//单个函数,必须放在函数体第一行
function f(){
  'use strict';
}
```

### (1) 增强的安全措施

#### ① 禁止前缀 0 的八进制表示法

正常模式下，整数第一位为 0，表示八进制数，严格模式下，禁止这种表示法，整数第一位为 0 将报错

```javascript
'use strict';

console.log(0100); //SyntaxError, 正常模式:1
```

### (2) 对象

#### ① 禁止对象有重名属性

正常模式下，对象后声明的属性会`覆盖`先声明的重名属性，严格模式下抛出语法错误

```javascript
'use strict';

var obj = {
  a: 1,
  a: 2
}
console.log(obj.a); //SyntaxError, 正常模式:2
```

### (3) 变量

#### ① 禁止使用新增的保留字作为变量名

#### ② 禁止创建意外的全局变量

正常模式下，变量未声明就赋值，默认全局变量，严格模式下会抛出语法错误

```javascript
'use strict';

a = 1; //ReferenceError
```

#### ③ 禁止使用 delete 操作符删除变量

正常模式下，使用 delete 删除变量，会静默失败并返回 false，严格模式下会抛出语法错误，delete只能删除属性描述对象设置可写的对象属性

```javascript
'use strict';

var b = 2;
delete b; //SyntaxError
```

### (4) 函数

#### ① 禁止使用新增的保留字作为函数名

#### ② 禁止在非函数代码块声明函数

正常模式下，可以在非函数代码块声明函数（如if语句），为了与ES6的块级作用域接轨，严格模式下会抛出语法错误

```javascript
'use strict';

if(true){
  function f(){} //SyntaxError
}
```

#### ③ 禁止函数有重名参数

正常模式下，函数的重名参数使用`arguments[i]`读取，严格模式下会抛出语法报错

```javascript
'use strict';

function f(a, a){
  console.log(arguments[0] + arguments[1]);
}
f(1, 2); //SyntaxError, 正常模式:3
```

#### ④ 禁止使用函数的 caller 属性

正常模式下，函数的caller属性指向`调用当前函数的函数`，严格模式下会抛出语法错误

```javascript
'use strict';

function f1(){
  function f2(){
      console.log(f2.caller);
  }
  f2();
}
f1(); //TypeError, 正常模式:function f1(){}
```

#### ⑤ 禁止函数内的 this 指针指向全局对象

正常模式下，函数内的this指针未指定时，指向全局对象，使用 call()、apply() 时，undefined和null值也会被转换成全局对象，严格模式下，this始终指向指定的值，无论什么值，未指定则`默认undefined`

```javascript
'use strict';

function f(){
  console.log(this);
}
f();               //undefined, 正常模式:window
f.call(undefined); //undefined, 正常模式:window
f.call(null);      //null,      正常模式:window
```

### (5) arguments 对象

#### ① 禁止对 arguments 对象赋值

正常模式下，可以对arguments对象赋值，严格模式下会静默失败

```javascript
'use strict';

function f(a){
  arguments[0] = 2;
  console.log(a);
}
f(1); //1, 正常模式:2
```

#### ② 禁止 arguments 对象追踪函数参数变化

正常模式下，arguments对象与函数参数间存在`联动关系`，值永远保持`同步`，严格模式下arguments对象无法再追踪函数参数的变化

```javascript
'use strict';

function f(a){
  a = 2;
  console.log(arguments[0]);
}
f(1); //1, 正常模式:2
```

#### ③ 禁止使用 arguments.callee

正常模式下，arguments.callee属性指向`当前函数`，严格模式下会抛出语法错误

```javascript
'use strict';

function factorial(num){
  if(num < 2){
    return 1;
  } else{
    return num * arguments.callee(num-1);
  }
}
console.log(factorial(2)); //TypeError, 正常模式:2
```

### (6) 静态绑定

某些情况下，ES5允许动态绑定，即某些属性和方法归属于哪个对象，可以在运行时确定，严格模式下，仅允许静态绑定，即属性和方法归属于哪个对象，必须在编译时确定，有利于编译效率的提高，使代码更易阅读，更少出现意外

#### ① 禁止使用 with 语句

正常模式下，可以使用with语句，严格模式下会抛出语法错误

```javascript
'use strict';

with(location){ //SyntaxError
  var hostName = hostName;
  var url = href;
}
```

#### ② 创建 eval 作用域

正常模式下，eval语句中创建的变量和函数会被添加到所在执行环境，严格模式下，eval语句会`创建自身的执行环境`

```javascript
'use strict';

eval("function sayhi(){console.log('hi')}");
sayhi(); //ReferenceError, 正常模式:"hi"
```
