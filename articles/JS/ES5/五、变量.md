# 五、变量

[[_TOC_]]

## 1. 变量声明

### (1) 重复声明

① ES5会`覆盖`同名函数的再次声明

② ES5会`忽略`同名变量的再次声明

③ ES5认为函数名也是变量，由于函数声明提升的优先级高于变量声明提升，所以当函数名和变量同名时，ES5会`忽略`变量的声明

```javascript
//情况1
function f(){
  console.log(1);
}
function f(){
  console.log(2);
}
f(); //2

//情况2
var x = 1;
var x;
console.log(x); //1

//情况3
var f;
function f(){}
console.log(f); //function f(){}
```

### (2) 声明提升

> function函数声明提升的优先级高于var变量声明提升

① ES会将函数的声明过程在编译阶段提升到`所在执行上下文顶部`

② ES会将变量的声明过程在编译阶段提升到`所在执行上下文顶部`，并初始化为`undefined`，变量的其他操作如赋值等则留在原地等待执行

③ 函数表达式属于变量声明，匿名函数的赋值操作留在原地等待执行

```javascript
//情况1
var a = 1;
function f(){
  a = 2;
  console.log(a); //2
  var a = 3;
  console.log(a); //3
}
f();

//情况2
console.log(a);
var a =1;
function a() {
  a = 3;
  console.log(a);
  var a = 4;
}
console.log(a);
a = 5;
console.log(a);
//等价于：
function a(){
  var a;
  a = 3;
  console.log(a);
  a = 4;
}
var a; //同名变量重复声明被忽略
console.log(a); //function a(){}
a = 1;
console.log(a); //1
a = 5;
console.log(a); //5
```

函数表达式声明提升

```javascript
//情况1
var f = function(){
  console.log(1);
};
function f(){
  console.log(2);
}
f();
//等价于：
function f(){
  console.log(2);
}
var f; //同名变量重复声明被忽略
f = function(){
  console.log(1);
}
f(); //1

//情况2
var f = function(){
  console.log(1);
};
function f(){
  console.log(2);
}   
function f1(){
  f = function(){
    console.log(3);
  }
}
f1();
f();
//等价于：
function f(){
  console.log(2);
}
function f1(){ //f1仅声明,未调用,内部代码块的赋值操作未执行
  f = function(){
    console.log(3);
  }
}
var f; //同名变量重复声明被忽略
f = function(){
  console.log(1);
}
f1(); //调用f1，变量f的值被覆盖
f(); //3
```

立即执行的函数表达式声明提升

```javascript
//情况1
var a = 1;
function f(){
  var a = 2;
  (function f1(){
    var a = 3;
    console.log(a); //3,块级作用域
  })();
  console.log(a); //2,函数作用域
}
f();
console.log(a); //1,全局作用域

//情况2
var a = 1;
function f(){
  var a = 2;
  (function f1(){
    a = 3;
    console.log(a); //3
    var a = 4;
    console.log(a); //4
  })();
  console.log(a); //2
}
f();
console.log(a); //1
```

## 2. 执行上下文

JS 引擎并非一行一行地分析和执行程序，而是`一段一段地`分析和执行程序，段就是根据可执行代码来划分的

### (1) 可执行代码类型

① 全局代码

② 函数代码

③ eval() 代码

### (2) 执行上下文属性

当 JS 引擎执行一段可执行代码时，会创建对应的执行上下文，每个可执行上下文都有三个重要属性

① 变量对象

② 作用域链

③ this

### (3) 全局上下文

### (4) 函数上下文

执行上下文也叫作用域，是指程序源代码中`定义变量的区域`，规定了如何查找变量，也就是确定当前执行代码对变量的访问权限

#### ① 静态作用域

函数的作用域在`函数定义时`确定，ES采用`静态作用域`，

#### ② 动态作用域

函数的作用域在`函数调用时`才确定，

```javascript
var value = 1;
function f1(){
  console.log(value);
}
function f2(){
  var value = 2;
  f1(); 
}
f2(); //静态作用域：1, f1执行时,先查找f1内部是否有局部变量value,没有则根据书写位置,查找全局上下文中是否有全局变量value
      //动态作用域：2, f1执行时,先查找f1内部是否有局部变量value,没有则在调用f1的执行上下文,即f2内部查找是否有局部变量value
```

## 3. 变量对象

变量对象存储了执行上下文中定义的函数声明和变量声明，

#### 全局上下文的变量对象

① 全局上下文的变量对象就是`全局对象`，

② 全局对象是预定义的对象，作为 JS 的全局属性、全局函数的占位符，通过使用全局对象，可以访问其他所有预定义的对象、属性、函数，在顶层 JS 代码中，可以用关键字 this 引用全局对象，因为全局对象是作用域链的头，这意味着所有非限定性的变量和函数名都会作为全局对象的属性来查询

### (1) 初始化函数上下文

#### 创建活动对象

用函数的 `Arguments 对象`创建函数上下文的活动对象

#### 初始化活动对象

给活动对象添加以下初始属性值

① 函数的所有形参

由名称和对应值组成一个变量对象的属性被创建

没有实参，属性值设为 undefined

② 函数声明

由名称和对应值 ( 函数对象 ( function-object ) ) 组成一个变量对象的属性被创建

如果函数名跟已经声明的函数名相同，则`覆盖`已声明的函数名

③ 变量声明

由名称和对应值 ( undefined ) 组成一个变量对象的属性被创建

如果变量名跟已经声明的函数名相同，则`忽略`当前的变量名

### (2) 执行函数代码

`顺序`执行函数代码，根据代码修改活动对象的对应属性值    

```javascript
function f(a){
  var b = 2;
  function c(){}
  var d = function(){};
  b = 3;
}
f(1);

//创建活动对象
AO = {
  arguments: {
    0: 1,
    length: 1
  },
}

//初始化活动对象
AO = {
  arguments: {
    0: 1,
    length: 1
  },
  a: 1,
  b: undefined,
  c: reference to function c(){},
  d: undefined
}

//执行函数代码
AO = {
  arguments: {
    0: 1,
    length: 1
  },
  a: 1,
  b: 3,
  c: reference to function c(){},
  d: reference to FunctionExpression "d"
}
```

## 4. 作用域链

作用域链就是由多个执行上下文的`变量对象`构成的链表

### (1) 函数创建

函数创建时，保存函数所有父变量对象到函数内部的 `[[scope]]属性`，可以认为 [[scope]] 是函数所有父变量对象的层级链，但 [[scope]] 属性并不代表完整的作用域链

### (2) 初始化函数上下文

初始化函数上下文时，使用 Arguments 对象创建函数活动对象，并初始化活动对象，即给活动对象添加函数形参、函数声明、变量声明等初始属性值，然后将活动对象添加到`作用域链前端`，

```javascript
var a = "global";
function f1(){
  var a = "local";
  function f2(){
    return a;
  }
  return f2();
}
f1(); //'local'

//函数创建
f1.[[scope]] = [
  globalContext.VO
];

//初始化函数上下文
f1Context = {
  AO: {
    arguments: {
      length: 0
    },
    a: undefined,
    f2: reference to function f2(){}
  },
  Scope: [AO, globalContext.VO],
  this: undefined
}
```

## 5. 执行上下文栈

JS引擎创建执行上下文栈来管理执行上下文

#### ① 情况1

```javascript
var a = "global";
function f1(){
  var a = "local";
  function f2(){
    return a;
  }
  return f2();
}
f1(); //'local'
//ECStack.push(globalContext);
//ECStack.push(<f1> functionContext);
//ECStack.push(<f2> functionContext);
//ECStack.pop();
//ECStack.pop();


//创建全局执行上下文,全局上下文被压入执行上下文栈
ECStack = [
  globalContext
];

//全局上下文初始化
globalContext = {
  VO: [global],
  Scope: [globalContext.VO],
  this: globalContext.VO
}

//同时f1函数被创建,保存作用域链到f1函数内部属性[[scope]]
f1.[[scope]] = [
  globalContext.VO
];

//创建f1函数执行上下文,f1函数上下文被压入执行上下文栈
ECStack = [
  f1Context,
  globalContext
];

//f1函数上下文初始化
//1. 复制函数[[scope]]属性创建作用域链
//2. 用函数Arguments对象创建活动对象
//3. 初始化活动对象,即加入函数形参、函数声明、变量声明
//4. 将活动对象压入函数作用域链顶端
f1Context = {
  AO: {
    arguments: {
      length: 0
    },
    scope: undefined,
    f2: reference to function f2(){}
  },
  Scope: [AO, globalContext.VO],
  this: undefined
}

//同时f2函数被创建,保存当前作用域链到f2函数内部属性[[scope]]
f2.[[scope]] = [
  f1Context.AO,
  globalContext.VO
];

//创建f2函数执行上下文,f2函数上下文被压入执行上下文栈
ECStack = [
  f2Context,
  f1Context,
  globalContext
];

//f2函数上下文初始化
f2Context = {
  AO: {
    arguments: {
      length: 0
    }
  },
  Scope: [AO, f1Context.AO, globalContext.VO],
  this: undefined
}

//f2函数执行,沿着作用域链查找a值,返回a值

//f2函数执行完毕,f2函数上下文从执行上下文栈中弹出
ECStack = [
  f1Context,
  globalContext
];

//f1函数执行完毕,f1函数上下文从执行上下文栈中弹出
ECStack = [
  globalContext
];
```

#### ② 情况2

```javascript
var a = "global";
function f1(){
  var a = "local";
  function f2(){
    return a;
  }
  return f2;
}
f1()(); //'local'
//ECStack.push(globalContext);
//ECStack.push(<f1> functionContext);
//ECStack.pop();
//ECStack.push(<f2> functionContext);
//ECStack.pop();


//创建全局执行上下文,全局上下文被压入执行上下文栈
ECStack = [
  globalContext
];

//全局上下文初始化
globalContext = {
  VO: [global],
  Scope: [globalContext.VO],
  this: globalContext.VO
}

//同时f1函数被创建,保存作用域链到f1函数内部属性[[scope]]
f1.[[scope]] = [
  globalContext.VO
];

//创建f1函数执行上下文,f1函数上下文被压入执行上下文栈
//虽然f1的执行上下文从执行上下文栈中弹出,但f2的作用域链中仍然存有f1的活动对象
ECStack = [
  f1Context,
  globalContext
];

//f1函数上下文初始化
//1. 复制函数[[scope]]属性创建作用域链
//2. 用函数Arguments对象创建活动对象
//3. 初始化活动对象,即加入函数形参、函数声明、变量声明
//4. 将活动对象压入函数作用域链顶端
f1Context = {
  AO: {
    arguments: {
      length: 0
    },
    scope: undefined,
    f2: reference to function f2(){}
  },
  Scope: [AO, globalContext.VO],
  this: undefined
}

//f1函数执行完毕,f1函数上下文从执行上下文栈中弹出
ECStack = [
  globalContext
];

//f2函数被创建,保存当前作用域链到f2函数内部属性[[scope]]
f2.[[scope]] = [
  f1Content.AO,
  globalContext.VO
];

//创建f2函数执行上下文,f2函数上下文被压入执行上下文栈
ECStack = [
  f2Context,
  globalContext
];

//f2函数上下文初始化
f2Context = {
  AO: {
    arguments: {
      length: 0
    }
  },
  Scope: [AO, f1Content.AO, globalContext.VO],
  this: undefined
}

//f2函数执行完毕,f2函数上下文从执行上下文栈中弹出
ECStack = [
  globalContext
]
```
