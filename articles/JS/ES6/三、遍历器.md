# 三、遍历器

[[_TOC_]]

## 1. 同步遍历器

### (1) 遍历器接口 Iterable

遍历器接口就是`遍历器对象生成函数`，调用遍历器接口，就可以得到遍历器对象

#### 遍历器接口的作用

① 为各种不同的数据结构提供统一的访问机制

② 使得数据结构的成员可以按照`各个成员被添加进数据结构的顺序`遍历

③ 创造一种新的遍历命令，for-of 循环，任何数据结构，只要部署了遍历器接口，就可以使用 for-of 循环遍历

### (2) 遍历器对象 Iterator

遍历器对象是一个一定具有 next() 方法，可能具有 return()、throw() 方法的对象，其根本特征是 `next()方法`，

#### 遍历过程

① 创建一个遍历器对象，指向数据结构的`起始位置`

② 不断调用遍历器对象的 next() 方法，指向数据结构的`当前成员`

③ 最后一次调用遍历器对象的 next() 方法，指向数据结构的`结束位置`

```javascript
//ES5模拟实现遍历器接口
function createIterator(items){
  var i = 0;
  //返回遍历器对象
  return { 
    //next(): 返回数据结构当前成员的信息对象,done属性表示遍历是否结束,value属性表示当前成员值
    next: function(){
      var done = i >= items.length;
      var value = !done ? items[i++] : undefined;
      return { 
        done: done,
        value: value
      };
    },
    //return(): 适用于for-of循环提前退出(出错/break/continue)
    return: function(){
      return {
        done: true,
        value: undefined
      }
    },
    //throw(): 主要用于配合generator函数
    throw: function(){}
  }
}
```

#### 遍历分离

遍历器接口与遍历的数据结构是`分离`的，完全可以写出没有对应数据结构的遍历器接口，或者用遍历器接口模拟数据结构

```javascript
//没有对应数据结构的遍历器接口
function createIterator(items){
  var i = 0;
  return {
    next: function(){
      return {
        done: false,
        value: ++i
      }
    }
  }
}
const iterator = createIterator();
iterator.next(); //{done: false, value: 1}
iterator.next(); //{done: false, value: 2}
iterator.next(); //{done: false, value: 3}
...


//用遍历器接口模拟数据结构
function createIterator(items){
  var i = 0;
  return { 
    next: function(){
      var done = i >= items.length;
      var value = !done ? items[i++] : undefined;
      return { 
        done: done,
        value: value
      };
    }
  }
}
const iterator = createIterator([1, 2]);
iterator.next(); //{done: false, value: 1}
iterator.next(); //{done: false, value: 2}
iterator.next(); //{done: true, value: undefined}
```

### (3)默认部署遍历器接口的数据结构

① Map

② Array

③ Set

④ 类数组对象 ( String、NodeList、HTMLCollection、NamedNodeMap )

并非所有数组对象都默认部署遍历器接口，最简便的方法就是使用 Array.from()，将没有部署遍历器接口的类数组对象转换成数组

⑤ Generator 对象

```javascript
//Map
const map = new Map([[1, 'a'], [2, 'b']]);
const iter = mapSymbol.iterator;
console.log(iter.next()); //{done: false, value: [1, 'a']}
console.log(iter.next()); //{done: false, value: [2, 'b']}
console.log(iter.next()); //{done: true, value: undefined}

//Array
const arr = [1, 'a'];
const iter = arrSymbol.iterator;
console.log(iter.next()); //{done: false, value: 1}
console.log(iter.next()); //{done: false, value: 'a'}
console.log(iter.next()); //{done: true, value: undefined}

//Set
const set = new Set([1, 'a']);
const iter = setSymbol.iterator;
console.log(iter.next()); //{done: false, value: 1}
console.log(iter.next()); //{done: false, value: 'a'}
console.log(iter.next()); //{done: true, value: undefined}

//类数组对象：String
const str = 'ab';
const iter = strSymbol.iterator;
console.log(iter.next()); //{done: false, value: 'a'}
console.log(iter.next()); //{done: false, value: 'b'}
console.log(iter.next()); //{done: true, value: undefined}

//类数组对象：NodeList
const nodes = document.getElementById('block').childNodes;
const iter = nodesSymbol.iterator;
console.log(iter.next()); //{done: false, value: text}
console.log(iter.next()); //{done: false, value: span}
console.log(iter.next()); //{done: false, value: text}
console.log(iter.next()); //{done: true, value: undefined}

//类数组对象：HTMLCollection
const elems = document.getElementsByTagName('div');
const iter = elemsSymbol.iterator;
console.log(iter.next()); //{done: false, value: div#block}
console.log(iter.next()); //{done: false, value: div}
console.log(iter.next()); //{done: true, value: undefined}

//类数组对象：NamedNodeMap 
const attrs = document.getElementById('block').attributes;
const iter = attrsSymbol.iterator;
console.log(iter.next()); //{done: false, value: id}
console.log(iter.next()); //{done: false, value: class}
console.log(iter.next()); //{done: true, value: undefined}

//Generator对象
function* f(){
  yield 1;
  yield 2;
}
console.log(iter.next()); //{done: false, value: 1}
console.log(iter.next()); //{done: false, value: 2}
console.log(iter.next()); //{done: true, value: undefined}
```

### (4) for-of 循环

一个数据结构只要部署了遍历器接口，就可以使用 for-of 循环遍历，for-of 循环本质上就是调用遍历器接口生成的遍历器对象

```javascript
//内建遍历器：ES6为Map、Array、Set 集合内建了以下三种遍历器接口
keys()    //返回键名的遍历器对象
values()  //返回键值的遍历器对象
entries() //返回键值对的遍历器对象
```

```javascript
//Map：默认entries()
const map = new Map([[1, 'a'], [2, 'b']]);
for(const item of map.keys()){
  console.log(item); //1     2
}
for(const item of map.values()){
  console.log(item); //'a'  'b'
}
for(const item of map.entries()){
  console.log(item); //Array [1, 'a']  [2, 'b']
}

//Array：默认values()
const arr = [1, 'a'];
for(const item of arr.keys()){
  console.log(item); //0   1
}
for(const item of arr.values()){
  console.log(item); //1  'a'
}
for(const item of arr.entries()){
  console.log(item); //Array [0, 1]  [1, a]
}

//Set：默认values(),键名和键值相同
const set = new Set([1, 'a']);
for(const item of set.keys()){
  console.log(item); //1  'a'
}
for(const item of set.values()){
  console.log(item); //1  'a'
}
for(const item of set.entries()){
  console.log(item); //Array [1, 1]  ['a', 'a']
}

//类数组对象：String
const str = 'ab';
for(const item of str){
  console.log(item); //'a'  'b'
}

//类数组对象：NodeList
const nodes = document.getElementById('block').childNodes;
for(const item of nodes){
  console.log(item); //Node #text  span  #text
}

//类数组对象：HTMLCollection
const elems = document.getElementsByTagName('div');
for(const item of elems){
  console.log(item); //Node div#block  div
}

//类数组对象：NamedNodeMap 
const attrs = document.getElementById('block').attributes;
for(const item of attrs){
  console.log(item); //id="block"  class="red"
}

//Generator对象
function* f(){
  yield 1;
  yield 2;
}
for(let item of f()){
  console.log(item); //1 2
}
```

### (5) 默认调用遍历器接口的场合

#### ① 数组作为参数

数组的遍历会调用遍历器接口，所有任何接受数组作为参数的场合都调用了遍历器接口

```javascript
//Array.from()
//new Map()
//new WeakMap()
//new Set()
//new WeakSet()
//for-of
//Promise.all()
//Promise.race()
```

#### ② 扩展运算符...

扩展运算符会调用默认的遍历器接口，这提供了一种简便机制，只要某个数据结构部署了遍历器接口，就可以使用扩展运算符，将其转换为数组

```javascript
const str = 'hello';
const arr = [...str]; //Array ['h', 'e', 'l', 'l', 'o']
```

#### ③ 解构赋值

对 Array、Set 进行解构赋值，会默认调用遍历器接口

```javascript
//Array
const arr = [1, 2, 3];
const [first, ...rest] = arr; //first=1, rest=[2, 3]

//Set
const set = new Set().add(1).add(2).add(3);
const [first, ...rest] = set; //first=1, rest=[2, 3]
```

#### ④ yield*

yield* 后跟一个可遍历的数据结构，会调用该数据结构的默认遍历器接口

```javascript
function* f1(){
  yield 1;
  yield 2;
}
function* f2(){
  yield 3;
  yield* f1();
  yield 4;
}
for(let item of f2()){
  console.log(item); //3 1 2 4
}
```

## 2. 异步遍历器

同步遍历器：同步遍历器的 next 方法必须是同步的，只要调用就必须返回值，也就是说，一旦调用 next 方法，就必须同步得到 value 和 done 属性，

异步遍历器：ES6 提供了异步遍历器，为异步操作提供了原生的遍历器接口，即调用 next 方法时，异步得到 value 和 done 两个属性，

dd

异步遍历器调用 next 方法，返回 Promise 实例，因此，可以使用 then 方法指定，Promise 实例状态变为已成功 \( fulfilled \) 时的回调函数，回调函数参数，则是一个具有 value 和 done 属性的对象，

对象的异步遍历器接口，部署在对象的 Symbol.asyncIterator 属性上，无论什么对象，只要它的 Symbol.asyncIterator 属性有值，就应该对其进行异步遍历
