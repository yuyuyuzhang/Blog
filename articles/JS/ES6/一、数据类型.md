# 一、数据类型

[[_TOC_]]

## 1. 类型检测

### (1) JS 内置类型检测机制

使用 typeof 操作符检测基本数据类型，使用 instanceof 操作符检测引用数据类型

#### 限制

① typeof 操作符检测基本数据类型，但是`无法区分 Null 与 Object`

② instanceof 操作符通过检测`指定构造函数的原型是否存在于实例的原型链中`，从而得知数据类型，若为多 iframe 页面，则页面存在多个全局上下文，每个全局上下文中针对每个引用数据类型都有不同的构造函数，当在一个全局上下文中通过 instanceof 操作符检测从另一个全局上下文传入的引用数据类型值时，返回 false

③ constructor 属性通过检测`实例的原型的 constructor 属性`来获知实例的构造函数，从而得知数据类型，但是`无法检测 Undefined 与 Null`，并且当开发者自定义对象且重写原型后，若未定义新原型的 constructor 属性，则无法检测出实例的正确构造函数，也就无法检测出实例的正确数据类型

```javascript
基本数据类型：
typeof x     x           返回值
             Undefined   "undefined"   未声明、使用var声明但未初始化
             Null        "object"      空指针
             Boolean     "boolean"     
             Number      "number"      
             String      "string"  
             Symbol      "symbol"    
             Object      "object" 
             Function    "function"

引用数据类型：
x instanceof Null        TypeError
             Object      true
             Map         true
             WeakMap     true
             Array       true
             Set         true
             WeakSet     true
             Date        true
             Function    true
             RegExp      true

基本、引用数据类型：
x.constructor   Undefined   TypeError
                Null        TypeError
                Boolean     ƒ Boolean(){}
                Number      ƒ Number(){}
                String      ƒ String(){}
                Object      ƒ Object(){}
                Map         f Map(){}
                WeakMap     f WeakMap(){}
                Array       ƒ Array(){}
                Set         f Set(){}
                WeakSet     f WeakSet(){}
                Date        ƒ Date(){}
                Function    ƒ Function(){}
                RegExp      ƒ RegExp(){}
```

### (2) 常用类型检测机制

① 包含原生对象和宿主对象在内的所有对象都有一个`内部属性 [[class]]`，属性值为对象的`原生构造函数名`，用于 JS 引擎线程判断对象的真实内置数据类型

② 调用对象的 toString() 方法时，获取 this 对象的 [[class]] 属性值，然后返回 `[object, NativeConstructorName]` 格式的字符串，原生构造函数名与全局上下文无关，能够保证返回一致的值

③ Array、Data、Function、RegExp 等类型作为 Object 的实例，分别重写了 toString() 方法，返回数组每项以逗号分割的字符串、日期的字符串、函数内容体的字符串、正则表达式的字符串等，而 Map、WeakMap、Set、WeakSet 未曾重写 toString() 方法

![检测数据类型](https://github.com/yuyuyuzhang/Blog/blob/master/images/JS/ES/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/ES5/%E6%A3%80%E6%B5%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.png)

```javascript
function type(x){
    return (typeof x) !== "object" && (typeof x) !== "function" ? typeof x : Object.prototype.toString.call(x);
}

x          返回值
Undefined  "undefined"
Null       "[object Null]"
Boolean    "boolean"
Number     "number"
String     "string"
Object     "[object Object]"
Map        "[object Map]"
WeakMap    "[object WeakMap]"
Array      "[object Array]"
Set        "[object Set]"
WeakSet    "[object WeakSet]"
Date       "[object Date]"
Function   "[object Function]"
RegExp     "[object RegExp]"
```

## 2. 基本数据类型

#### 基本数据类型

保存在`栈内存`中的简单数据段

#### 基本包装类型

基本包装类型属于`引用数据类型`的一种，当读取一个基本数据类型值时，后台就会自动创建一个对应的基本包装类型的实例，并在实例上调用一些方法来操作这些基本数据类型值，基本包装类型与引用类型的主要区别在于`对象的生存期`，自动创建的基本包装类型的实例，只存在于`一行代码的执行瞬间`，然后立即销毁，这意味着不能在执行时为基本包装类型的实例添加属性和方法

### (1) Undefined

未声明、使用 var 声明但未初始化

> 未声明的变量只能执行一项操作，即使用 typeof 操作符检测其数据类型

```javascript
var a  //未声明
var b; //使用var声明但未初始化
console.log(typeof a); //undefined
console.log(typeof b); //undefined
```

### (2) Null

空指针，意在保存对象但还未保存对象

> 如果声明的变量准备在将来用于保存对象，就应该明确地将其初始化为 null，不仅可以体现 null 作为空对象指针的惯例，也有助于进一步区分 null 和 undefined

### (3) Boolean

```javascript
Boolean值
全局方法：Boolean(x) //将任意数据类型值x转换为布尔值


Boolean基本包装对象 
永远不要使用Boolean对象
```

#### Boolean的方法

```javascript
let x;
Boolean(x);    //false
Boolean(null); //false
Boolean(NaN);  //false
Boolean(0);    //false
Boolean(1);    //true
Boolean("");   //false
Boolean("ha"); //true
```

### (4) Number

ES 使用 `IEEE754 64 位`格式存储所有 Number 数值

```javascript
Number值
全局方法：Number(x)             //返回数值,将任意数据类型值x转换为数值


Number基本包装对象
属性：Number.MIN_VALUE  
     Number.MAX_VALUE  
     Number.MAX_SAFE_INTEGER
     Number.MIN_SAFE_INTEGER
方法：对象方法：
     Number.isNaN(num)         //返回布尔值,表示num是否为NaN
     Number.isFinite(num)      //返回布尔值,表示num是否有限
     Number.parseInt(str,n)    //返回数值,将n进制字符串str转换成十进制整数,忽略字符串前面的空格,直到第一个非空格字符,若第一个字符不是负号或数字,返回NaN,
                               //否则继续解析第二个字符,遇到非数字字符则停止解析
     Number.parseFloat(str)    //返回数值,将十进制字符串str转换成十进制浮点数
     Number.isSafeInteger(int) //返回布尔值,表示整数int是否位于ES能够准确表示的整数范围内
     继承方法：
     num.valueOf()             //返回num
     num.toString(n)           //返回num的n进制字符串表示
     num.toLocaleString(n)     //返回num的n进制本地字符串表示
     表示方法：
     num.toFixed(n)            //按照n位小数四舍五入以固定大小格式返回num的字符串表示
     num.toExponential(n)      //按照n位小数四舍五入以科学表示法返回num的字符串表示
     num.toPrecision(n)        //按照n位数值以最合适的格式返回num的字符串表示
```

#### ① NaN

非数值 NaN 表示`本来要返回数值的操作数未返回数值的情况`，NaN 有两个特点：任何涉及 NaN 的操作都会返回 NaN、NaN 与自身在内的任何值都不相等

#### ② 范围

`ES 能够表示的数值范围`为 5e<sup>-324</sup>~1.7976931348623157e<sup>+308</sup>，该范围的上限保存在 `Number.MAX_VALUE` 属性，下限保存在 `Number.MIN_VALUE` 属性

如果某次计算得到了一个超出 ES 数值范围的值，值为正会被自动转换为 +Infinity（正无穷），值为负会被自动转换为 -Infinity（负无穷）， Infinity 无法参与下次计算

`ES 能够准确表示的整数范围`为 -2<sup>53</sup>  ~2<sup>53</sup>（不含两个端点），该范围的上限保存在 `Number.MAX_SAFE_INTEGER` 属性，下限保存在 `Number.MIN_SAFE_INTEGER` 属性，`Number.isSafeInteger()` 函数是用来判断某个整数是否位于该范围内，常用于`验证运算的每个值和结果`

```javascript
//若只验证运算结果,不验证参与运算的每个参数,也可能导致错误的结果
function trusty(a, b, result){
  if(Number.isSafeInteger(a) && Number.isSafeInteger(b) && Number.isSafeInteger(result)){
    return result;
  }
  throw new RangeError('Operation can not be trusted!');
}
```

#### ③ 整数

ES6 中整数的字面量格式有二进制（`0b...`）、八进制（`0o...`）、十进制、十六进制（`0x...`），进行算术计算时，二进制、八进制、十六进制表示的整数都会被转换成十进制

```javascript
console.log(0b11); //3
console.log(0o11); //9
console.log(0x11); //17
```

#### ④ 浮点数

对于极大和极小的数，推荐使用`科学表示法`形式的浮点数来表示，浮点数的最高精度是 `17 位`，但进行算术计算时其精度远远不如整数，会产生舍入误差，因此永远不要测试某个特定的浮点数

保存浮点数所需的内存空间是整数的 `2 倍`，因此 ES5 会在以下两种情况下将浮点数转换成整数保存：小数点后没有数字、浮点数本身表示的就是整数

```javascript
const x1 = 0.12; 
const x2 = .12;    //不推荐省略小数点前导0的写法 
const x3 = 1.2e5;  //表示整数120000
const x4 = 1.2e-5; //表示浮点数0.000012
const x5 = 1.;     //小数点后无数字,保存为整数1
const x6 = 1.0;    //浮点数本身表示的就是整数,保存为整数1

(0.1 + 0.2) === 0.3; //false, 0.1+0.2=0.30000000000000004
```

#### ⑤ Number的方法

全局方法

```javascript
let x;
Number(x);     //NaN
Number(null);  //0
Number(false); //0
Number(true);  //1
Number('');    //0
Number('1');   //1
```

对象方法：

ES6 将全局方法 isNaN()、isFinity()、parseInt()、parseFloat() 移植到了 `Number 对象`上，目的是`减少全局性方法，使语言逐步模块化`

```javascript
Number.isNaN(NaN);           //true
Number.isNaN('NaN');         //true

Number.isFinite(1);          //true
Number.isFinite('1');        //true

Number.parseInt("");         //NaN
Number.parseInt("ha");       //NaN
Number.parseInt("-10");      //-10
Number.parseInt("010");      //10,忽略前导0
Number.parseInt("10.6");     //10,小数点无效
Number.parseInt("10ha");     //10,字母无效
Number.parseInt("070", 8);   //56,八进制
Number.parseInt("0xf", 16);  //15,十六进制

Number.parseFloat("");       //NaN
Number.parseFloat("ha");     //NaN
Number.parseFloat("-1.20");  //-1.2
Number.parseFloat("01.20");  //1.2
Number.parseFloat("10.6.6"); //10.6,第二个小数点无效
Number.parseFloat("1.2ha");  //1.2,字母无效
Number.parseFloat("070");    //70,不能解析八进制
Number.parseFloat("0xf");    //0,不能解析十六进制,x无效
```

继承方法

```javascript
const num = 10.125;
num.valueOf();         //10.125
num.toString(2);       //"1010.001"
num.toLocaleString(2); //"1010.001"
```

表示方法

```javascript
const num = 10.125;
num.toFixed(2);       //"10.13"
num.toExponential(2); //"1.01e+1"
num.toPrecision(1);   //"1e+1"
num.toPrecision(2);   //"10"
num.toPrecision(3);   //"10.1"
```

### (5) String

ES 使用` 2 字节的 UTF-16 编码`存储每个字符

```javascript
String值
全局方法：String(x)                 //将任意数据类型值x转换为字符串


String基本包装对象
属性：str.length              
方法：对象方法：
     String.fromCharCode(u1,...)  //返回u1,...等字符编码表示的字符串
     String.fromCodePonit(u1,...) //返回u1,...等字符编码表示的字符串（能够正确识别码点大于\uFFFF的字符）
     继承方法：
     str.valueOf()                //返回str
     str.toString()               //返回str
     str.toLocaleString()         //返回str
     空格方法：
     str.trim()                   //返回新字符串,创建str副本并删除所有前置及后缀空格
     分割方法：
     str.split(x,maxLength)       //返回数组,将str转换成以字符串或正则x分割的数组
     大小写转换方法：
     str.toUpperCase()            //返回str,将str全部字符转换为大写
     str.toLowerCase()            //返回str,将str全部字符转换为小写
     str.toLocaleUpperCase()      //针对地区,对少数语言要应用特殊规则
     str.toLocaleLowerCase()      //针对地区,对少数语言要应用特殊规则
     字符方法：
     str.charAt(n)                //以单字符字符串形式返回str中索引n处字符
     str.at(n)提案                 //以单字符字符串形式返回str中索引n处字符（能够正确识别码点大于\uFFFF的字符）
     str.charCodeAt(n)            //以单字符字符串形式返回str中索引n处字符编码
     str.codePointAr(n)           //以单字符字符串形式返回str中索引n处字符编码（能够正确识别码点大于\uFFFF的字符）
     补全方法：
     str.repeat(m)                //返回新字符串,将str重复m次
     str.padStart(m,str1)         //返回新字符串,使用子串str1在str头部补全至指定长度m,若省略str1,则用空格补全
     str.padEnd(m,str1)           //返回新字符串,使用子串str1在str尾部补全至指定长度m,若省略str1,则用空格补全
     操作方法：
     str.concat(str1,...)         //返回新字符串,创建str副本并在末尾连续添加任意个项
     str.slice(n1,n2)             //返回新字符串,由str的索引n1到索引n2前一项构成
     str.substring(n1,n2)         //返回新字符串,由str的索引n1到索引n2前一项构成
     str.substr(n,m)              //返回新字符串,由str的索引n处开始的m个字符构成
     查询方法：
     str.startsWith(str1,n)       //返回布尔值,子串str1是否位于str由索引n处到尾部的子串的头部
     str.endsWith(str1,n)         //返回布尔值,子串str1是否位于str由头部到索引n前一项的子串的尾部
     str.includes(str1,n)         //返回布尔值,str是否包含str1,由索引n处向后搜索
     str.indexOf(str1,n)          //返回查到的第一个子串str1的索引,由索引n处向后搜索
     str.lastIndexOf(str1,n)      //返回查到的第一个子串str1的索引,由索引n处向前搜索
     比较方法：
     str.localeCompare(str1)      //返回数值,比较str,str1在字母表中排序,str位于str1之前返回负数,之后返回正数,相等返回0,具体数值由实现而定
     Unicode正规化方法：
     str.normalize(arg)           //返回1或多个字符,根据arg指定的格式正规化str
```

#### ① 字符串长度

扩展运算符 ...、Array.from() 可以将字符串转换成数组，并且能够正确识别 4 个字节的字符，故可以正确返回字符串长度

```javascript
//字符串转换成数组
[...'hello'];        //Array ["h", "e", "l", "l", "o"]
Array.from('hello'); //Array ["h", "e", "l", "l", "o"]

//返回字符串长度
function strLength(str){
  return [...str].length;
  或者
  return Array.from(str).length;
}
'𠮷a'.length;     //3
strLength('𠮷a'); //2
```

#### ② 字符串遍历

ES6 为字符串添加了 `Iterator 接口`，可以使用 for-of 循环遍历字符串，并且可以正确识别 4 个字节的字符

```javascript
const str = '𠮷a';
for(let i of str){
  console.log(i); //'𠮷' 'a'
}
```

#### ③ 模板字符串

模板字符串是增强版的字符串，用反引号标识，可以用作普通字符串、定义多行字符串、在字符串中嵌入变量，模板字符串中的`空格和缩进都会被保留到输出，模板字符串中使用反引号需用反斜杠转义

```javascript
const a = 1;
const person = {
  getName(){
    return this.name;
  }
};
const str1 = `the sum is ${(a + 1) * 2}`; //'the sum is 4'
const str2 = `she's name is ${person.getName()}`; //'she's name is 张三'
```

#### ④ String 方法

全局方法：

String() 通过调用值本身的 `toString()` 将其转换为字符串

```javascript
let x;
String(x);     //"undefined"
String(null);  //"null"
String(false); //"false"
String(true);  //"true"
String(NaN);   //"NaN"
String(0);     //"0"
String(1);     //"1"
```

空格方法：

仅去除字符串的所有前置及后缀空格，中间空格不计

```javascript
"   hello world   ".trim(); //'hello world'
```

分割方法

```javascript
const str = 'haha#hehe';
const arr = str.split(/#/g); //Array ['haha', 'hehe']
```

字符方法：

ES5 不能正确识别码点大于 \uFFFF 的需 4 个字节存储的字符，而 ES6 能够正确识别，ES6 使用`大括号表示法`表示一个字符，可以正确表示码点超过\ uFFFF 的需 4 个字节存储的字符

```javascript
//大括号表示法
console.log('\u20BB7');   //'7'
console.log('\u{20BB7}'); //'𠮷'

//对象方法
String.fromCharCode(0x20BB7);  //'ஷ',ES5
String.fromCodePoint(0x20BB7); //'𠮷',ES6

//字符方法：4字节字符
const str = '𠮷';
str.length;         //2
str.charAt(0);      //""
str.charAt(1);      //""
str.charCodeAt(0);  //55362
str.charCodeAt(1);  //57271
str.codePointAt(0); //134071

//测试一个字符是否为4个字节
function is4Byte(x){
 return x.codePointAt(0) > 0xFFFF;
}
is4Byte('𠮷'); //true
```

补全方法：

补全方法常用于为数值补全指定位数、提示字符串格式

```javascript
//为数值补全指定位数
'1'.padStart(10, '0'); //'0000000001'

//提示字符串格式
'09-12'.padStart(10, 'YYYY-MM-DD'); //'YYYY-09-12'
```

操作方法：

参数 n 代表索引，参数 m 代表个数，索引参数为负则加上字符串长度，个数参数为负则以 0 计算

substring：索引参数为负则以 0 计算，n1>n2，则交换 n1、n2（不推荐使用，规则特殊，不容易记住）

```javascript
str.concat(str1,...) //返回新字符串,创建str副本并在末尾连续添加任意个项
str.slice(n1,n2)     //返回新字符串,由str的索引n1到索引n2前一项构成
str.substring(n1,n2) //返回新字符串,由str的索引n1到索引n2前一项构成
str.substr(n,m)      //返回新字符串,由str的索引n处开始的m个字符构成
```

```javascript
const str = "hello world";

str.concat();         //'hello world'
str.concat('haha');   //'hello worldhaha'

str.slice(-3);        //'rld'          slice(-3)=slice(8, 10)
str.slice(3, -4);     //"lo w"         slice(3, -4)=slice(3, 7)

str.substring(-3);    //'hello world'  substring(-3)=substring(0, 10)
str.substring(3, -4); //"hel"          substring(3, -4)=substring(3, 0)=substring(0, 3)

str.substr(-3);       //'rld'          substr(-3)=substr(8)
str.substr(3, -4);    //''             substr(3, -4)=substr(3, 0)
```

查询方法：

索引始终是`从前往后`计数，索引参数不能为负

```javascript
str.startsWith(str1,n)  //返回布尔值,子串str1是否位于str由索引n处到尾部的子串的头部
str.endsWith(str1,n)    //返回布尔值,子串str1是否位于str由头部到索引n前一项的子串的尾部
str.includes(str1,n)    //返回布尔值,str是否包含str1,由索引n处向后搜索
str.indexOf(str1,n)     //返回查到的第一个子串str1的索引,由索引n处向后搜索
str.lastIndexOf(str1,n) //返回查到的第一个子串str1的索引,由索引n处向前搜索
```

```javascript
const str = "hello world";

str.includes("w");     //true
str.includes("w", 6);  //true
str.includes("w", 7);  //false

str.startsWith("world");    //false
str.startsWith("world", 4); //false
str.startsWith("world", 5); //false
str.startsWith("world", 6); //true

str.endsWith("hello");    //false
str.endsWith("hello", 4); //false
str.endsWith("hello", 5); //true
str.endsWith("hello", 6); //false

str.indexOf("o");         //4
str.lastIndexOf("o");     //7
str.indexOf("o", 6);      //7
str.lastIndexOf("o", 6);  //4
```

比较方法：

比较字符串在`字母表中顺序`

```javascript
const str = "yello";
str.localeCompare("aaaaa"); //1
str.localeCompare("zzzza"); //-1
str.localeCompare("yello"); //0
```

Unicode 正规化方法：

许多欧洲语言有语调符号和重音符号，Unicode 提供 2 种方法表示，一种是提供带重音符号的字符，另一种是提供原字符和重音符号的合成符号，这 2 种表示方法在视觉和语义上都等价，但是 ES5 无法识别，而 ES6 提供 normalize() 来统一字符的不同表示方法

```javascript
'\u01D1' === '\u004F\u030C';
 //false
'\u01D1'.normalize() === '\u004F\u030C'.normalize(); //true,均表示字符'Ǒ'
```

### (6) Symbol

ES6 引入基本数据类型 Symbol，表示`独一无二的值`，为了`从根本上防止对象属性名冲突`，ES5 的对象属性名都是 String，容易造成属性名冲突

```javascript
Symbol基本包装对象
定义：const sym = Symbol(str)
属性：正则属性：
     Symbol.match
     Symbol.replace
     Symbol.search
     Symbol.split
     遍历器属性：
     Symbol.iterator           //返回对象的同步遍历器接口
     Symbol.asyncIterator      //返回对象的异步遍历器接口
     其他方法：
     Symbol.hasInstance        //返回/设置一个内部方法,当前对象使用instanceof运算符时默认调用
     Symbol.isConcatSpreadable //返回/设置布尔值,决定当前对象使用Array.prototype.concat()时是否可以展开
     Symbol.species            //返回/设置当前对象的构造函数,当前对象创建实例时会默认调用这个构造函数方法
     Symbol.toPrimitive        //返回/设置一个内部方法,当前对象被转换为原始数据类型值时默认调用
     Symbol.toStringTag        //返回/设置一个内部方法,当前对象调用Object.prototype.toString()时,内部方法返回值会出现
                               //在toString()方法返回的字符串中,表示对象的类型
     Symbol.unscopables        //返回/设置一个对象,指定了当前对象使用with关键字时哪些属性会被with环境排除
方法：Symbol.for(str)           //返回全局上下文中指定字符串参数的Symbol值并将其登记在全局上下文,没有则新建
     Symbol.keyFor(sym)        //返回已登记的sym的key,未登记则返回undefined
     继承方法：
     sym.valueOf()             //返回sym
     sym.toString()            //返回sym的字符串描述
     sym.toLocaleString()      //返回sym的字符串描述
```

#### ① Symbol 值

Symbol 值通过 Symbol 函数生成，Symbol 值是基本类型值，因而 Symbol 函数不能使用 new 操作符调用，Symbol 函数的字符串参数表示`对Symbol值的描述`，主要用于控制台输出，因此`字符串参数可以相同`

```javascript
//Symbol函数的字符串参数可以相同
Symbol('sym') === Symbol('sym'); //false

//Symbol值不能与其他类型值进行运算，否则会报错
console.log('your symbol is' + Symbol('sym')); //TyperError

//Symbol值可以显示转换为Boolean、String,不能转换为Number
const sym = Symbol('sym');
Boolean(sym); //true
Number(sym);  //TypeError
String(sym);  //'sym'
```

#### ② Symbol 方法

Symbol.for(str)：

可获取到 `不同的 iframe 和 service worker` 中的同一个 Symbol 值，获取不到则新建，新建的 Symbol 值会被`登记在全局上下文供搜索`

```javascript
const ifrmae = document.querySelector('iframe');
ifrmae.contentWindow.Symbol.for('sym') === Symbol.for('sym'); //true
```

Symbol.keyFor(sym)：

使用 Symbol() 创建的 Symbol 值不会被登记，而使用 Symbol.for() 创建的 Symbol 值会被登记在全局上下文以供搜索

```javascript
const sym1 = Symbol('sym1');
const sym2 = Symbol.for('sym2');
Symbol.keyFor(sym1); //undefined
Symbol.keyFor(sym2); //'sym2'
```

继承方法：

```javascript
const sym = Symbol('sym');
sym.valueOf();        //Symbol(sym)
sym.toString();       //'Symbol(sym)'
sym.toLocaleString(); //'Symbol(sym)'
```

## 3. 引用数据类型

保存在`堆内存`中的对象，栈内存中保存`对象的引用地址`

### (1) Object

Object 本质上是 hash 结构，也就是键值对的集合，但是 Object 只能使用 String、Symbol 作为键名，Object 提供了 `String/Symbol—值`的对应

```javascript
属性：obj.constructor                   
方法：属性描述对象方法：
     Reflect.getOwnPropertyDescriptor(obj,prop)      //返回obj.prop的属性描述对象
     Reflect.defineProperty(obj,prop,desc)           //返回修改后的对象,通过属性描述对象修改obj.prop
     Reflect.defineProperties(obj,{prop1:desc1,...}) //返回修改后的对象,通过属性描述对象修改obj.prop1,...
     冻结方法：
     Reflect.preventExtensions(obj)                  //无返回值,使obj不可扩展,无法添加新属性
     Object.seal(obj)                                //无返回值,密封obj,无法添加新属性,删除旧属性
     Object.freeze(obj)                              //无返回值,冻结obj,无法添加新属性,删除旧属性,改变属性值
     Reflect.isExtensible(obj)                       //返回布尔值,obj是否可扩展
     Object.isSealed(obj)                            //返回布尔值,obj是否被密封
     Object.isFrozen(obj)                            //返回布尔值,obj是否被冻结
     原型方法：
     Object.create(obj)                              //返回以obj为原型创建的实例,继承obj的所有属性和方法
     Reflect.getPrototypeOf(obj)                     //返回obj的原型(_proto_属性值)
     Reflect.setPrototypeOf(obj,proto)               //返回obj,设置obj的原型为proto(_proto_属性值)
     枚举方法：
     obj.hasOwnProperty(property)                    //返回布尔值,表示属性是否定义在obj上
     Object.keys(obj)                                //返回obj自身可遍历的所有String属性名的数组
     Object.getOwnPropertyNames(obj)                 //返回obj自身所有String属性名的数组
     Object.getOwnPropertySymbols(obj)               //返回obj自身所有Symbol属性名的数组
     比较方法：
     Object.is(val1,val2)                            //返回布尔值,val1、val2是否相等
     复制方法：
     Object.assign(target,souce1,...)                //返回目标对象,将所有源对象的所有可枚举属性复制到目标对象
     继承方法：
     obj.valueOf()                                   //返回obj
     obj.toString()                                  //返回[object, NativeConstructorName]字符串
     obj.toLocalString()                             //返回[object, object]字符串
```

#### ① 属性名

定义对象属性有 2 种方法，一是使用标识符，二是使用表达式，使用`字面量`方式定义对象时，ES5 只允许使用标识符，而 ES6 还允许使用表达式

使用标识符作为对象属性名时，ES5 使用字符串，而字符串不具备唯一性，容易造成`属性名的冲突`，ES6 新增基本数据类型 Symbol，表示独一无二的值，从根本上杜绝了属性名冲突的可能性，故而推荐使用 Symbol 值

**标识符属性名**

* String 属性名：推荐使用`点表示法`，特殊情况下使用方括号表示法

  * 特殊情况 1：通过变量访问属性

  * 特殊情况 2：属性名使用关键字、保留字、包含会导致语法错误的字符

* Symbol 属性名：必须使用`方括号表示法`，因为点表示法常用语 String 属性名

**表达式属性名**

必须使用`方括号表示法`，表达式属性名和简洁表示法不能同时使用，否则会报错

```javascript
const age = Symbol('person age');
const a = 1;
const x = {x: 1};
const person = {
  //String属性名
  name: '张三', 
  "birth day": 2000, //包含会导致语法错误的字符,需使用字符串形式

  //Symbol属性名
  [age]: 19, 

  //表达式属性名
  [a + 'b']: 'ab', 
  [x]: 'xy' //表达式属性名若为对象,默认会将属性名转化为'[object object]'
};
const personName = "name";

person.name;         //'张三'
person[personName];  //'张三',使用变量访问属性
person['birth day']; //'张',属性名包含会导致语法错误的字符
person[age];         //19
person[a + 'b'];     //123
person[x];           //'xy'
```

#### ② 属性名的简洁表示法

ES6 允许在对象中`只写属性名，不写属性值`，此时属性值就等于属性名代表的变量，即 ES6 允许直接写入变量作为对象的属性

```javascript
//ES6写法
const name = '张三';
const person = {
  //数据属性的简写
  name,
  _age: 20,
  getName(){
    return this.name;
  },

  //存取器属性的简写
  get age(){
    return this._age;
  },
  set age(val){
    this._age = val > this._age ? val : this._age;
  }
};
console.log(person.age); //20
person.age= 22;
console.log(person.age); //22

//ES5写法
var person = {
  name: '张三',
  getName: function(){
    return this.name
  },
  _age: 20
};
Object.defineProperty(person, 'age', {
  get: function(){
    return person._age;
  },
  set: function(val){
    person._age = val > person._age ? val : person._age;
  }
});
console.log(person.age); //20
person.age= 22;
console.log(person.age); //22
```

函数返回值的简写

```javascript
function getPoint(){
  const x = 1;
  const x = 2;
  return {x, y}; //return {x: 1, y: 2};
}
```

#### ③ 对象比较

```javascript
见demo/ES/对象比较
```

#### ④ 对象拷贝

```javascript
见demo/ES/对象拷贝
```

#### ⑤ Object 方法

枚举方法：

对象属性枚举次序：首先枚举所有 `Number 属性名`的属性，按数字排序，其次枚举所有 `String 属性名`的属性，按生成时间排序，最后枚举所有 `Symbol 属性名`的属性，按生成时间排序

不可遍历：Object 没有部署 Iterator 接口，因为`对象属性遍历次序不确定`，需要开发者手动指定，故而不提供遍历方法

**for-in**：对象继承的和自身的可枚举 String 属性（包含继承属性，不推荐使用）

| |String|Symbol|
|-|------|------|
|方法|enumerable:true/false|enumerable:true/false|
|Object.keys()|是|
|Object.getOwnPropertyNames()|是、是|
|Object.getOwnPropertySymbols()||是、是|
|Reflect.ownKeys()|是、是|是、是|

```javascript
const person = {
  name: '张三',
  [Symbol('person age')]: 19
};
Reflect.defineProperty(person, 'birthDay', {
  value: 2000,
  enumerable: false,
});
Reflect.defineProperty(person, Symbol('person job'), {
  value: 'doctor',
  enumerable: false,
});
Object.keys(person);                  //Array ["name"]
Object.getOwnPropertyNames(person);   //Array ["name", "birthDay"]
Object.getOwnPropertySymbols(person); //Array [Symbol(person age), Symbol(person job)]
Reflect.ownKeys(person);              //Array ["name", "birthDay", Symbol(person age), Symbol(person job)]
```

复制方法：

复制所有源对象的所有`自身的可枚举的 String、Symbol 属性`到目标对象

同名属性覆盖：若源对象与目标对象有同名属性，或多个源对象有同名属性，后面的属性会`覆盖`前面的属性

浅复制：属性值为对象，则复制`对象的引用`

```javascript
const person = {
  name: '张三',
  friends: {name: '王五'}
};
const person1 = {
  name: '李四',
  friends: {name: '赵六'},
  [Symbol('person age')]: 19
};
Reflect.defineProperty(person1, 'birthDay', {
  value: 2000,
  enumerable: false,
});
Reflect.defineProperty(person1, Symbol('person job'), {
  value: 'doctor',
  enumerable: false,
});

Object.assign(person, person1); 
person1.friends.name = '陈七';//复制对象的引用,对象的任何变化都会反映到目标对象上
console.log(person); //person {name: '李四', friends: {name: '陈七'}, Symbol(person age)}
```

继承方法：

Object 的 toString() 方法，返回 `[object，NativeConstructorName]` 字符串，其中 NativeConstructorName 代表`原生构造函数名`，常用于数据类型检测

```javascript
const obj = {a: 1};
obj.valueOf();
        //Object {a: 1}
obj.toString();
       //'[object Object]'
obj.toLocaleString(); //'[object Object]'

//数据类型检测
const arr = [1, 2, 3];
Object.prototype.toString.call(arr); //'[object Array]'
```

### (2) Map

ES6 新增数据类型 Map，类似于 Object，但是 Map 的键名可以是任意数据类型值，Map 结构提供了`任意数据类型值—值`的对应

```javascript
定义：const map = new Map()
属性：map.size
方法：继承方法：
     map.valueOf()        //返回map
     map.toString()       //返回[object Map]字符串
     map.toLocaleString() //返回[object Map]字符串
     操作方法：
     map.has(key)         //返回布尔值,map是否包含指定键名key
     map.get(key)         //返回map中键名kay对应的键值,无则返回undefined
     map.set(key,val)     //返回map,向map添加键值对key-val,若key已存在,则覆盖对应键值
     map.delete(key)      //返回布尔值,是否成功从map删除键名key
     map.clear()          //无返回值,清除map所有成员
     遍历方法：
     map.keys()           //返回键名的遍历器对象,可使用for-of循环遍历
     map.values()         //返回键值的遍历器对象,可使用for-of循环遍历
     map.entries()        //返回键值对的遍历器对象,可使用for-of循环遍历
     map.forEach(f,scope) //无返回值,对map每项运行f=function(value,key,map)
```

#### ① 创建 Map

使用 new 操作符调用 Map 构造函数创建 map，可接受一个`具有 Iterator 接口且每个成员都是双元素数组的数据结构`作为参数来初始化，Map 的`键和内存地址绑定`，只要内存地址不一样，就视为两个键，解决了`同名属性碰撞 clash` 的问题

若 Map 键名为简单数据类型值，则使用`同值相等算法`判断两个键名是否为同一个键

若 Map 键名为引用数据类型值，始终被视为两个键

```javascript
new Map([[NaN, 2], [NaN, 2]]); //Map {NaN => 2}
new Map([[+0, 3], [-0, 3]]);   //Map {0 => 3}
new Map([[{}, 1], [{}, 1]]);   //Map {{…} => 1, {…} => 1}
```

#### ② Map 方法

继承方法

```javascript
const map = new Map([[1, 1], [2, 2]]);
map.valueOf();
        //Map {{1=>1}, {2=>2}}
map.toString();
       //'[object Map]'
map.toLocaleString(); //'[object Map]'
```

操作方法：

Map 的键名为基本数据类型值时，操作值

Map 的键名为对象时，操作`对象的引用`，即使用对象的`变量名`

```javascript
const map = new Map([[1, 1], [2, 2]]);

//操作基本数据类型值
map.clear();
map.set(3, 3).set(4, 4);
map.delete(4);
 //Map {3=>3}

//操作引用数据类型值
const obj1 = [5];
const obj2 = {c: 6};
map.set(obj1, 5).set(obj2, 6);
map; //Map {3=>3, [5]=>5, {c: 6}=>6}
```

遍历方法：

Map 原生部署 Iterator 接口，按`成员插入顺序`遍历，默认遍历器生成方法为 `map.entries()` 方法，可直接用 for-of 循环遍历

```javascript
const arr = [['a', 1], ['b', 2]];
const map = new Map(arr); //Map{'a'=>1, 'b'=>2}

//map结构的默认遍历器生成方法为map.entries()方法,故可省略该方法,直接用for-of循环遍历
for(const item of map){
  console.log(item); //Array ["a", 1] ["b", 2]
}

//forEach
map.forEach((value, key, map) => console.log(Array.of(key, value))); //Array ["a", 1] ["b", 2]
```

### WeakMap

ES6 新增数据类型 WeakMap，类似于 Map，但是键名只能是引用数据类型值且都是弱引用，WeakMap 结构提供了`引用数据类型值—值`的对应

**弱引用**：`垃圾回收机制不考虑 WeakMap 对键名对象的引用`，即当其他对象都不再引用 WeakMap 键名对象时，垃圾回收机制自动回收该键名对象，不考虑其是否还存在于 WeakMap 中

**不可遍历**：WeakMap 内部成员的个数取决于`垃圾回收机制是否运行`，运行前后很可能成员个数不一致，而垃圾回收机制何时运行不可预测，因此 ES6 规定 WeakMap 不可遍历

```javascript
定义：const wp = new WeakMap(iterator)
方法：继承方法：
     wp.valueOf()        //返回wp
     wp.toString()       //返回[object WeakMap]字符串
     wp.toLocaleString() //返回[object WeakMap]字符串
     操作方法：
     wp.has(key)         //返回布尔值,wp是否包含指定键名key
     wp.get(key)         //返回wp中键名kay对应的键值,无则返回undefined
     wp.set(key,val)     //返回wp,向wp添加键值对key-val,若key已存在,则覆盖对应键值
     wp.delete(key)      //返回布尔值,是否成功从wp删除键名key
```

#### ① 强引用

JS 中一般创建一个对象，都是建立一个强引用，只有手动设置变量名等于 `null`，才有可能回收变量名引用的对象

```javascript
const key = [1];
const map = new Map();
map.set(key, 2); //建立map对[1]的强引用

//情况1
key = null;      //去掉key对[1]的强引用,并未去掉map对[1]的强引用,所以[1]不会被回收

//情况2
map.delete(key); //去掉map对[1]的强引用
key = null;      //去掉key对[1]的强引用,[1]被回收
```

#### ② 弱引用

垃圾回收机制`不考虑弱引用`，只要对象的所有强引用都被清除，垃圾回收机制就会回收该对象，释放该对象占用的内存

* 一旦不再需要，WeakMap 里面的键名对象和所对应的键值对会自动消失，WeakSet内部的成员对象也会自动消失，不用手动删除引用

* WeakMap、WeakSet 内部成员个数，取决于垃圾回收机制是否运行，运行前后很可能成员个数不一致，而垃圾回收机制何时运行不可预测，因此 ES6 规定 WeakMap、WeakSet 不可遍历

* 所以 WeakMap、WeakSet，没有遍历操作，没有 size 属性，也不支持 clear 方法

```javascript
const key = [1];
const wm = new WeakMap(); 
wm.set(key, 2); //建立wm对[1]的弱引用

key = null; //去掉key对[1]的强引用,并未去掉wm对[1]的弱引用,下次垃圾回收机制运行时,[1]被回收
```

#### ③ 创建 WeakMap

使用 new 操作符调用 WeakMap 构造函数创建 weakMap，可接受一个`具有 Iterator 接口且每个成员都是双元素数组的数据结构`作为参数来初始化

```javascript
const arr1 = [[1, 1], [2, 2]];
const arr2 = [[{a:1}, 1], [[2], 2]];
const wm1 = new WeakMap(arr1); //TypeError,arr1的成员数组的第一个参数并非对象
const wm2 = new WeakMap(arr2); //WeakMap {{a:1}=>1, [2]=>2}
```

#### ④ WeakMap 方法

继承方法

```javascript
const wm = new WeakMap([[{a:1}, 1], [[2], 2]]);
wm.valueOf();
        //WeakMap {{a:1}=>1, [2]=>2}
wm.toString();
       //'[object WeakMap]'
wm.toLocaleString(); //'[object WeakMap]'
```

操作方法：

WeakMap 的键名必须是`对象`，所以 WeakMap 的操作方法，都是操作`对象的引用`，即使用对象的`变量名`

```javascript
const wm = new WeakMap();
const obj1 = [5];
const obj2 = {c: 6};
wm.set(obj1, 5).set(obj2, 6);
wm; //WeakMap {[5]=>5, {c: 6}=>6}
```

#### ⑤ WeakMap 用途

DOM 节点上保存相关数据：

将 DOM 节点作为 WeakMap 的键名，如将事件处理程序的监听函数作为 WeakMap 的键名，一旦 DOM 节点消失，与其绑定的监听函数也自动消失，不会造成内存泄漏

```javascript
//<button id="btn">点击</button>
const btn = document.querySelector('#btn');
const listener = new WeakMap();
const handler = (e) => console.log(e.target);
listener.set(btn, handler);
btn.addEventListener('click', listener.get(btn));
```

数据缓存：

需要关联对象和数据，而又不想管理这些数据的死活时，非常适合使用 WeakMap，比如在不修改原有对象的情况下储存某些属性或者根据对象储存一些计算的值等

```javascript
const cache = new WeakMap();
function attrLength(obj){
  if(cache.has(obj)){
    return cache.get(obj);
  } else{
    const count = Object.keys(obj).length;
    cache.set(obj, count);
    return count;
  }
}
attrLength({a: 1, b: 2}); //2
```

部署私有属性：

WeakMap 也可用于实现私有变量，将类的私有属性作为 WeakMap 的键名，若删除类的实例，则私有属性也随之消失，不会造成内存泄漏，ES6 中实现私有变量的方式有很多种

```javascript
const privateData = new WeakMap();
class Person{
  constructor(name, age){
    privateData.set(this, { name: name, age: age });
  }
  getName(){
    return privateData.get(this).name;
  }
  getAge(){
    return privateData.get(this).age;
  }
}
export default Person;
```

### (3) Array

Array 是数据的`有序列表`，成员可以是`任意数据类型值`

```javascript
定义：const arr = [];
属性：arr.length
方法：对象方法：
     Array.isArray(arr)       //返回布尔值,表示arr是否为数组,无论在哪个全局上下文创建(适用于多iframe页面)
     Array.from(obj,f)        //返回新数组,将obj转换成数组,f用于对每项处理,处理完成后放入数组
     Array.of(x1,...)         //返回新数组,将一组值转换成数组
     继承方法：
     arr.valueOf()            //返回arr副本
     arr.toString()           //返回字符串,对arr每项调用toString()并以,分隔
     arr.toLocalString()      //返回字符串,对arr每项调用toLocalString()并以,分隔
     栈方法：
     arr.push(x1,...)         //返回arr的长度,向arr末尾连续添加任意个项
     arr.pop()                //返回移除项,移除arr的末尾项
     队列方法：
     arr.unshift(x1...)       //返回arr的长度,向arr头部连续添加任意个项
     arr.shift()              //返回移除项,移除arr的头部项
     分割方法：
     arr.join(a)              //返回字符串,对arr每项以字符串a分割,无参以,分隔
     操作方法：
     arr.concat(x1,...)       //返回新数组,创建arr副本并在末尾连续添加任意个项
     arr.slice(n1,n2)         //返回新数组,由arr的索引n1处到索引n2前一项构成
     arr.splice(n,m,x1...)    //返回arr移除项构成的新数组,移除arr索引n处开始的m项,在索引a处连续添加任意个项x1,...
     arr.copyWithin(n1,n2,n3) //返回arr,复制arr索引n2至索引n3前一项,并覆盖到索引n1处
     arr.fill(x,n1,n2)        //返回arr,使用给定值x填充arr的索引n1处到索引n2前一项
     查询方法：
     arr.includes(a,n)        //返回布尔值,arr是否包含数组项a,由索引n处向后搜索
     arr.indexOf(a,n)         //返回查找到的第一个数组项a的索引,由索引n处向后搜索
     arr.lastIndexOf(a,n)     //返回查找到的第一个数组项a的索引,由索引n处向前搜索
     arr.find(f)              //返回第一个符合条件的数组项,对数组每依次执行函数f,第一个返回true的数组项
     arr.findIndex(f)         //返回第一个符合条件的数组项的索引,对数组每依次执行函数f,第一个返回true的数组项
     重排序方法：
     arr.reverse()            //返回新数组,反转arr数组项
     arr.sort(f)              //返回新数组,升序排列arr,对arr每项调用toString(),比较每项字符串的ASCII码,可接受一个比较函数作为参数
     迭代方法： 
     arr.map(f,scope)         //返回新数组,由f对arr每项的返回值构成
     arr.filter(f,scope)      //返回新数组,由f对arr返回true的项构成
     arr.every(f,scope)       //返回布尔值,仅当f对arr每项都返回true,则返回true
     arr.some(f,scope)        //返回布尔值,当f对arr某项返回true,则返回true
     遍历方法：
     arr.keys()               //返回键名的遍历器对象,可使用for-of循环遍历
     arr.values()             //返回键值的遍历器对象,可使用for-of循环遍历
     arr.entries()            //返回键值对的遍历器对象,可使用for-of循环遍历
     arr.forEach(f,scope)     //无返回值,对arr每项运行f=function(item,index,arr)
     归并方法：
     arr.reduce(f,init)       //返回数值,正向遍历arr,function(prev,cur,index,arr),init作为初始值赋给参数prev
     arr.reduceRight(f,init)  //返回数值,反向遍历arr,function(prev,cur,index,arr)
```

#### ① 判断是否为数组

Array.isArray() 方法判断是否为数组，无论数组在哪个全局上下文中创建，始终返回正确值

```javascript
Array.isArray([]); //true

Object.prototype.toString.call([]); //true
```

#### ② 转换成数组

Array.of()：可以将`一组值`转换成数组，可以代替 Array 构造函数

扩展运算符...：可以将`具有 Iterator 接口的数据类型`转换成数组

Array.from()：可以将`具有 Iterator 接口的数据类型`以及`类数组对象`转换成数组

```javascript
//一组值
Array.of();              //[]
Array.of(undefined);     //[undefined]
Array.of(3, undefin, 8); //[3, 6, 8]

//具有Iterator结构的数据类型
[...'hello'];                      //String
[...map];                          //Map
[...set];                          //Set
[...arguments];                    //Arguments对象
[...node.childNodes];              //NodeList对象
[...document.querySelectorAll()];
[...document.getElementsByName()]; 
//Generator函数的返回值

Array.from('hello');                           //String
Array.from(map);                               //Map
Array.from(set);                               //Set
Array.from(arguments);                         //Arguments对象
Array.from(node.childNodes);                   //NodeList对象
Array.from(document.querySelectorAll()); 
Array.from(document.getElementsByName());
//Generator函数的返回值

//类数组对象：Arguments对象、NodeList对象、HTMLCollection对象、NamedNodeMap对象
Array.from(node.children); //HTMLCollection对象
Array.from(document.getElementsByTagName()); 
Array.from(document.getElementsByClassName());

//Array.from()函数的第二个参数类似于arr.map()方法,对每项进行处理,然后放入返回的数组
const arrLike = {
  0: 1,
  1: 2,
  2: 3,
  length: 3
};
Array.from(arrLike, x => x*2); //Array [2, 4, 6]
```

#### ③ 数组长度

数组的大小是`动态变化`的，length 属性可写，且与数组的大小始终`同步`变化，可以通过设置 lenght 属性从数组`末尾`移除或添加新项

```javascript
const arr = ['a', 'b'];

//数组末尾删除一项
arr.length = 1;        //Array ['a']

//数组末尾新增一项
arr[1] = 'c';          //Array ['a', 'c']
arr.length = 3;        //Array ['a', 'c', undefined]
arr[arr.length] = 'd'; //Array ['a', 'b', undefined, 'd']
arr[5] = 'e';          //Array ['a', 'b', undefined, 'c', undefined, 'e']
```

#### ④ 数组最值

ES5 中求数组最值，只能使用`f.apply()`方法将数组转换为函数参数，而 ES6 新增扩展运算符`...`，则可以直接使用 Math.max/min()

**限制**

* 无参：返回 Infinity
* 任一参数不能转换成数值：返回 NaN

```javascript
const arr = [4, 5, 11, 3, 90];

//方法一
Math.max(...arr); //90

//方法二
Reflect.apply(Math.min, Math, arr); //90
```

#### ⑤ 数组排序

```javascript
见demo/ES/数组排序
```

#### ⑥ 数组乱序

```javascript
见demo/ES/数组乱序
```

#### ⑦ 数组去重

```javascript
见demo/ES/数组去重
```

#### ⑧ 数组扁平化

将多层嵌套的数组转换成只有一层的数组  

```javascript
见demo/ES/数组扁平化
```

#### ⑨ 数组深度优先/广度优先遍历

```javascript
见demo/ES/数组遍历
```

#### ⑨ Array 方法

继承方法：

```javascript
const arr = ["a", "b", "c"];
arr.valueOf();        //Array ["a", "b", "c"]
arr.toString();       //"a,b,c"
arr.toLocaleString(); //"a,b,c"
```

栈方法（先进后出）：

```javascript
const arr = [];
arr.push("a", "b"); //Array ["a", "b"]
arr.push("c");      //Array ["a", "b", "c"]
arr.pop();          //Array ["a", "b"]
```

队列方法（后进先出）：

```javascript
const arr = [];
arr.unshift("a", "b"); //Array ["a", "b"]
arr.unshift("c");      //Array ["c", "a", "b"]
arr.shift();           //Array ["a", "b"]
```

分割方法：

arr.join() 函数无参则以`逗号`分割

```javascript
const arr = ["a", "b", "c"];
arr.join();     //"a,b,c"
arr.join("||"); //"a||b||c"
```

操作方法：

参数 n 代表索引，参数 m 代表个数，索引参数为负则加上数组长度

```javascript
arr.concat(x1,...)       //返回新数组,创建arr副本并在末尾连续添加任意个项x1,...
arr.slice(n1,n2)         //返回新数组,由arr的索引n1处到索引n2前一项构成
arr.splice(n,m,x1...)    //返回arr移除项构成的数组,移除arr索引n处开始的m项,在索引n处连续添加任意个项x1,...
arr.copyWithin(n1,n2,n3) //返回arr,复制arr索引n2处到索引n3前一项,并覆盖到索引n1处
arr.fill(x,n1,n2)        //返回arr,使用给定值x填充arr的索引n1处到索引n2前一项
```

```javascript
const arr = [1, 4, 2, 5];

arr.concat([8, 9]);  //Array [1, 4, 2, 5, 8, 9]
[...arr, ...[8, 9]]; //Array [1, 4, 2, 5 ,8 ,9],ES6新增扩展运算符用于数组合并更方便快捷

arr.slice();      //Array [1, 4, 2, 5]
arr.slice(1);     //Array [4, 2, 5]
arr.slice(1, 3);  //Array [4, 2]
arr.slice(-3,-1); //Array [4, 2]  slice(-3,-1)=slice(1,3)
arr.slice(-1,-3); //Array []      slice(-1,-3)=slice(3,1)=[]

[1, 4, 2, 5].splice(1, 2);             //Array [4, 2] 原数组 [1, 5]
[1, 4, 2, 5].splice(1, 0, "a", 9);     //Array []     原数组 [1, "a", 9, 4, 2, 5]
[1, 4, 2, 5].splice(1, 2, "a", true);  //Array [4, 2] 原数组 [1, "a", true, 5]
[1, 4, 2, 5].splice(-2, 2, "a", true); //Array [2, 5] 原数组 [1, 4, "a", true]  splice(-2, 2)=splice(2, 2)

[1, 4, 2, 5].copyWithin(0, 2);       //Array [2, 5, 2, 5]
[1, 4, 2, 5].copyWithin(0, 1, 3);    //Array [4, 2, 2, 5]
[1, 4, 2, 5].copyWithin(-4, -2, -1); //Array [2, 4, 2, 5]  copyWithin(-4, -2, -1)=copyWithin(0, 2, 3)

[1, 4, 2, 5].fill(7);         //Array [7, 7, 7, 7]
[1, 4, 2, 5].fill(7, 1, 3);   //Array [1, 7, 7, 5]
[1, 4, 2, 5].fill(7, -3, -2); //Array [1, 7, 2, 5]  fill(x, -3, -2)=fill(x, 1, 2)
```

查询方法：

索引始终是`从前往后`计数，参数 n 代表索引，索引参数为负则加上数组长度

```javascript
arr.includes(a,n)    //返回布尔值,arr是否包含数组项a,由索引n处向后搜索
arr.indexOf(a,n)     //返回查找到的第一个数组项a的索引,由索引n处向后搜索
arr.lastIndexOf(a,n) //返回查找到的第一个数组项a的索引,由索引n处向前搜索
arr.find(f)          //返回第一个符合条件的数组项,对数组每依次执行函数f,第一个返回true的数组项
arr.findIndex(f)     //返回第一个符合条件的数组项的索引,对数组每依次执行函数f,第一个返回true的数组项
```

```javascript
const arr = [1, 2, NaN, 4, -5, 4, 3, 2, 1]; 

arr.includes(NaN);    //true
arr.includes(-5, 3);  //true
arr.includes(-5, -1); //false

arr.indexOf(4);         //3
arr.lastIndexOf(4);     //5
arr.indexOf(4, 4);      //5
arr.lastIndexOf(4, 4);  //3
arr.indexOf(4, -1);     //-1  index(a, -1)=index(a, 8)
arr.lastIndexOf(4, -1); //5   index(a, -1)=index(a, 8)

arr.find(n => n<0);      //-5
arr.findIndex(n => n<0); //4
```

重排序方法：

arr.sort(f) 是比较字符串的 `ASCII 码`，某些情况下无法正确排序，可接受一个函数作为参数数组

```javascript
const arr = [0, 1, 5, 10];

//反转数组
const arr1 = arr.reverse(); //Array [10, 5, 1, 0]

//升序排列：比较ASCII码
const arr2 = arr.sort(); //Array [0, 1, 10, 5]
const arr3 = arr.sort((val1, val2) => val1 - val2); //Array [0, 1, 10, 5]
```

迭代方法：

```javascript
const arr = [1, 2, 3, 4, 5];
const arr1 = arr.map((item, index, arr) => item * 3);    //Array [3, 6, 9, 12, 15]
const arr2 = arr.filter((item, index, arr) => item > 2); //Array [3, 4, 5]

const flag1 = arr.every((item, index, arr) => item > 0); //true
const flag2 = arr.some((item, index, arr) => item < 0);  //false
```

遍历方法：

Array 原生部署 Iterator 接口，按`成员顺序`依次遍历，默认遍历器生成方法为 `map.values()` 方法，可直接使用 for-of 循环遍历

```javascript
const arr = ['a', 'b', 'c'];

//Array结构的默认遍历器生成函数为arr.values(),故可省略该方法,直接用for-of循环遍历
for(const entry of arr){
  console.log(entry); //'a' 'b' 'c'
}

//forEach
arr.forEach((item, index, arr) => console.log(Array.of(item, index))); //Array [0, 'a'] [1, 'b'] [2, 'c']
```

归并方法：

init 会作为初始值赋给参数 prev 启动累加或累积，每次迭代后的结果赋值给 prev 继续下一轮迭代

```javascript
//基本数据类型值
const arr1 = [1, 2, 3, 4, 5];
const sum1 = arr.reduce((prev, cur, index, arr) => prev + cur;}); //15

//引用数据类型值
const arr2 = [{val: 1}, {val: 2}, {val: 3}, {val: 4}, {val: 5}];
const sum2 = arr.reduce((prev, cur, index, arr) => prev + cur.val, 0); //15
```

![reduce](https://github.com/yuyuyuzhang/Blog/blob/master/images/JS/ES/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/ES6/reduce.png)

### (4) Set

ES6 新增数据类型 Set，类似于数组，成员可以是`任意数据类型但值唯一`

```javascript
定义：const set = new Set(iterable);
属性：set.constructor
     set.size
方法：继承方法：
     set.valueOf()        //返回set
     set.toString()       //返回[object Set]字符串
     set.toLocaleString() //返回[object Set]字符串
     操作方法：
     set.has(val)         //返回布尔值,set是否包含val
     set.add(val)         //返回set,向set添加val
     set.delete(val)      //返回布尔值,是否成功从set删除val
     set.clear()          //无返回值,清除set所有成员
     遍历方法：
     set.keys()           //返回键名的遍历器对象,可使用for-of循环遍历
     set.values()         //返回键值的遍历器对象,可使用for-of循环遍历
     set.entries()        //返回键值对的遍历器对象,可使用for-of循环遍历
     set.forEach(f,scope) //无返回值,对set每项运行f=function(value,key,set)
```

#### ① 创建 Set

使用 new 操作符调用 Set 构造函数创建 set，可接受一个`具有 Iterator 接口的数据结构`作为参数来初始化，Set 使用`同值相等算法`判断两个值是否相同

```javascript
new Set([NaN, NaN]);
 //set{NaN}
new Set([+0, -0]);   //set{0}
new Set([{}, {}]);
   //set{{}, {}}
```

#### ② Set 并集、交集、差集

```javascript
const set1 = new Set([1, 2, 3]);
const set2 = new Set([2, 3, 4]);
const union = new Set([...set1, ...set2]);
                             //并集 set(1, 2, 3, 4)
const intersect = new Set([...set1].filter(item => set2.has(item)));
   //交集 set{2, 3}
const difference = new Set([...set1].filter(item => !set2.has(item))); //差集 set{1}
```

#### ③ Set 方法

继承方法

```javascript
const set = new Set([1, 2, 3]);
set.valueOf();
        //Set {1, 2, 3}
set.toString();
       //'[object Set]'
set.toLocaleString(); //'[object Set]'
```

操作方法：

Set 的成员为基本数据类型值时，操作值

Set 的成员为对象时，操作`对象的引用`，即使用对象的`变量名`

```javascript
const set = new Set([1, 2, 3]);

//操作基本数据类型值
set.clear();
set.add(5).add(6).add(7);
set.delete(5);
 //Set {6, 7}

//操作引用数据类型值
const obj1 = [5];
const obj2 = {c: 6};
set.add(obj1).add(obj2);
set; //Set {6, 7, [5], {c: 6}}
```

遍历方法：

Set 原生部署 Iterator 结构，按`成员插入顺序`遍历，默认遍历器生成方法为 `set.values()` 方法，可直接用 for-of 循环遍历，Set 结构没有键名，只有键值，也可以认为`键名和键值相同`

```javascript
const set = new Set([1, 2, 3]);

//Set结构的默认遍历器生成函数为set.values(),故可省略该方法,直接用for-of循环遍历
for(const item of set){
  console.log(item); //1 2 3
}

//forEach
set.forEach((value, key) => console.log(Array.of(value, key))); //Array [1, 1] [2, 2] [3, 3]
```

### WeakSet

ES6 新增数据类型 WeakSet，类似于 Set，成员只能是`引用数据类型值但唯一`，且成员都是弱引用

**弱引用**：`垃圾回收机制不考虑WeakSet对成员对象的引用`，即当其他对象都不再引用 WeakSet 成员对象时，垃圾回收机制自动回收该成员对象，不考虑其是否还存在于 WeakSet中

**不可遍历**：WeakSet 内部成员的个数取决于`垃圾回收机制是否运行`，运行前后很可能成员个数不一致，而垃圾回收机制何时运行不可预测，因此 ES6 规定 WeakSet 不可遍历

```javascript
定义：const ws = new WeakSet(iterator)
属性：ws.constructor
方法：继承方法：
     ws.valueOf()        //返回ws
     ws.toString()       //返回[object WeakSet]字符串
     ws.toLocaleString() //返回[object WeakSet]字符串
     操作方法：
     ws.has(obj)         //返回布尔值,ws是否包含obj
     ws.add(obj)         //返回ws,向ws添加obj
     ws.delete(obj)      //返回布尔值,是否成功从ws删除obj
```

#### ① 创建 WeakSet

使用 new 操作符调用 WeakSet 构造函数创建 weakset，可接受一个`具有 Iterator 接口的数据结构`作为参数来初始化

```javascript
const arr1 = [1, 2 , 0];
const arr2 = [[1, 2], {a: 0}];
const ws1 = new WeakSet(arr1);
 //TypeError,arr1的成员并非对象
const ws2 = new WeakSet(arr2);
 //WeakSet{[1, 2], {a: 0}}
```

#### ② WeakSet 方法

继承方法

```javascript
const ws = new WeakSet([[1, 2], {a: 0}]);
ws.valueOf();
        //WeakSet {[1, 2], {a: 0}}
ws.toString();
       //'[object WeakSet]'
ws.toLocaleString(); //'[object WeakSet]'
```

操作方法：

WeakSet 的成员必须是`对象`，所以 WeakSet 的操作方法，都是操作`对象的引用`，即使用对象的`变量名`

```javascript
const ws = new WeakSet();
const obj1 = [5];
const obj2 = {c: 6};
ws.add(obj1).add(obj2);
ws; //WeakSet{[5], {c: 6}}
```

### (5) Date

Date 类型使用`时间戳`保存日期，Date 对象的月份值为 `0～11`

```javascript
定义：const date = new Date()
方法：时间戳方法：
     Date.now()                        //返回当前方法调用时的时间戳
     Date.parse('yyyy-mm-ddThh:mm:ss') //返回指定CST日期时间的时间戳(月份1~12)
     Date.UTC(y,m,d,h,m,s)             //返回指定UTC日期时间的时间戳(月份0~11,小时-8)
     date.valueOf()                    //返回date对象的时间戳
     date.getTime()                    //返回date对象的时间戳
     date.setTime()                    //无返回值,设置date对象时间戳
     获取/设置日期方法：
     date.getFullYear()/UTC            //从date对象获取/设置CST/UTC年
     date.getMonth()/UTC               //从date对象获取/设置CST/UTC月(0~11)
     date.getDate()/UTC                //从date对象获取/设置CST/UTC日
     date.getHours()/UTC               //从date对象获取/设置CST/UTC时
     date.getMinutes()/UTC             //从date对象获取/设置CST/UTC分
     date.getSeconds()/UTC             //从date对象获取/设置CST/UTC秒
     date.getMilliseconds()/UTC        //从date对象获取/设置CST/UTC毫秒
     date.getDay()/UTC                 //从date对象获取CST/UTC星期
     日期格式化字符串方法：
     date.toUTCString()                //返回date对象转换成的UTC日期时间
     date.toString()                   //返回date对象转换成的带时区CST日期时间
     date.toDateString()               //返回date对象转换成的带时区CST日期
     date.toTimeString()               //返回date对象转换成的带时区CST时间
     date.toLocalString()              //返回date对象转换成的不带时区CST日期时间
     date.toLocaleDateString()         //返回date对象转换成的不带时区CST日期
     date.toLocaleTimeString()         //返回date对象转换成的不带时区CST时间
```

#### ① CST & UTC

本地时间 CST = 标准时间 UTC/GMT + 时区差（8h），浏览器上显示的是`本地时间`，写代码也使用本地时间

#### ① 创建 Date

Date 构造函数中传入参数时，构造函数会模拟 Date.parse()、Date.UTC() 方法，但是当构造函数模拟 Date.UTC() 方法时，基于`本地时间`而非标准时间

```javascript
//当前日期时间
const ts1= Date.now();    //1566214780000
const date1 = new Date(); //'Mon Aug 19 2019 19:39:40 GMT+0800 (中国标准时间)'

//指定CST日期时间,月份1~12
const ts2 = Date.parse('2019-08-19T19:39:40');
 //1566214780000
const date2 = new Date('2019-08-19T19:39:40'); //'Mon Aug 19 2019 19:39:40 GMT+0800 (中国标准时间)'

//指定UTC日期时间,月份0~11
const ts3 = Date.UTC(2019, 7, 19, 11, 39, 40);   //1566214780000
const date3 = new Date(2019, 7, 19, 19, 39, 40); //'Mon Aug 19 2019 19:39:40 GMT+0800 (中国标准时间)'
```

#### ② 比较 Date 对象大小

将 date 对象转化成`时间戳`，然后比较时间戳的大小，由于比较运算符在针对对象时，会自动调用对象的 `valueOf()` 方法，因而可以直接比较 date 对象

```javascript
const date1 = new Date();
const date2 = new Date('2019-08-19T19:39:30');
date1 > date2; //true
```

#### ③ Date 方法

获取设置日期方法

```javascript
function formatDate(date){
  const year = date.getFullYear();
  let month = date.getMonth() + 1;
  let day = date.getDate();
  let hour = date.getHours();
  let minute = date.getMinutes();
  let second = date.getSeconds();

  month = month < 10 ? '0' + month : month;
  day = day < 10 ? '0' + day : day;
  hour = hour < 10 ? '0' + hour : hour;
  minute = minute < 10 ? '0' + minute : minute;
  second = second < 10 ? '0' + second : second;

  return year + '-' + month + '-' + day + ' ' + hour + ':' + minute + ':' + second;
}
const date = new Date();
formatDate(date); //'2019-08-20 19:19:51'
```

## 4. 单体内置对象

由 ES 提供的，不依赖宿主环境的对象，在程序执行前就已经存在

### (1) Math 对象

Math 对象包含的属性大都是数学计算中可能会用到的一些特殊值，包含的方法大都用于辅助完成简单和复杂的数学计算

```javascript
属性：Math.E              //常量e
     Math.LN10           //10的自然对数
     Math.LN2            //2的自然对数
     Math.LOG2E          //以2为底e的对数
     Math.LOG10E         //以10为底e的对数
     Math.PI             //常量Π
     Math.SQRT1_2        //1/2的平方根
     Math.SQRT2          //2的平方根
方法：Math.random()       //返回大于等于0小于1的一个随机数
     32位整数方法：
     Math.cla32(num)     //返回num的32位无符号整数形式前导0的个数
     Math.imul(a,b)      //返回a,b以32位带符号整数形式的乘积
     单精度浮点数方法：
     Math.fround(num)    //返回num的单精度浮点数形式
     正负方法：
     Math.sign(num)      //返回数值,num>+0返回+1,num=+0返回+0,num=-0返回-0,num<-0返回-1,其他返回NaN
     Math.signbit(num)   //返回布尔值,表示num的符号位是否已设置（num<=-0返回true,其他返回false）
     绝对值方法：
     Math.abs(num)       //返回num的绝对值
     最值方法：
     Math.min(num1,...)  //返回n1,...中的最小值
     Math.max(num1,...)  //返回n1,...中的最大值
     取整方法：
     Math.trunc(num)     //返回num的整数部分,去掉小数部分
     Math.ceil(num)      //返回将num向上舍入后最接近的整数
     Math.floor(num)     //返回将num向下舍入后最接近的整数
     Math.round(num)     //返回将num四舍五入后最接近的整数
     开根方法：
     Math.pow(num,n)     //返回num的n次方
     Math.sqrt(num)      //返回num的平方根
     Math.cbrt(num)      //返回num的立方根
     Math.hypot(num,...) //返回所有参数的平方和的平方根
     指数方法：
     Math.exp(num)       //返回e的n次方
     Math.expm1(num)     //返回e的num次方减1
     对数方法
     Math.log(num)       //返回num的自然对数
     Math.log1p(num)     //返回num+1的自然对数
     Math.log10(num)     //返回以10为底的num的对数
     Math.log2(num)      //返回以2为底的num的对数
     三角函数方法：
     Math.sin(x)         //返回x的正弦值
     Math.cos(x)         //返回x的余弦值
     Math.tan(x)         //返回x的正切值
     Math.asin(x)        //返回x的反正弦值
     Math.acos(x)        //返回x的反余弦值     
     Math.atan(x)        //返回x的反正切值
     Math.atan2(y,x)     //返回x的y/x的反正切值
     双曲函数方法：
     Math.sinh(x)        //返回x的双曲正弦值
     Math.cosh(x)        //返回x的双曲余弦值
     Math.tanh(x)        //返回x的双曲正切值
     Math.asinh(x)       //返回x的反双曲正弦值
     Math.acosh(x)       //返回x的反双曲余弦值     
     Math.atanh(x)       //返回x的反双曲正切值
```

32 位整数方法

```javascript
//ES中整数使用32位二进制形式表示,位移运算符与Math.clz32()直接相关
Math.clz32(1);       //31
Math.clz32(1 << 10); //21

//绝大多数情况下,Math.imul(a, b)方法等同于(a*b)|0（超出32位的部分溢出）
//ES中超过2的53次方的整数无法准确表示,因而对于极大数的乘法,乘积的低位数值往往不精确,Math.imul()可以返回精确的低位数值
Math.imul(2, 4);                   //8
Math.imul(0x7fffffff, 0x7fffffff); //1
(0x7fffffff * 0x7fffffff) | 0);    //0
```

单精度浮点数方法

```javascript
//对于无法用64位二进制精确表示的小数,Math.fround()会返回最接近这个小数的单精度浮点数
Math.fround(1.5);   //1.5
Math.fround(1.377); //1.3370000123977661
```

从某个整数范围内随机选择一个值

```javascript
function valueFrom(lowerValue, upperValue){
  const choices = upperValue - lowerValue + 1;
  return Math.floor(Math.random() * choices + lowerValue);
}
const colors = ["red", "blue", "yellow", "white", "black", "purple"];
const color = colors[valueFrom(0, colors.length-1)]; //"purple"
```

### (2) Global 对象

Global 对象是 ES 中的`全局对象`，浏览器和 Node 对 Global 对象的实现不同

```javascript
属性：特殊值： undefined  NaN  Infinity          
     构造函数：Boolean Number String Object Array Date RegExp Function Error RangeError ReferenceError SyntaxError TypeError URLError
方法：URI(通用资源标识符)编码方法：
     encodeURI(url)          //返回编码后的url,转义除URL合法字符外的所有字符
     decodeURI(url)          //解码使用encodeURL()编码的url
     encodeURIComponent(url) //返回编码后的url,转义除语义字符外的所有字符
     decodeURIComponent(url) //解码使用encodeURLComponent()编码的url
```

#### ① 浏览器

Global 对象作为 Window 对象的一部分来实现

ES5 规定在全局上下文中声明的 var、function 变量，都是 Global 对象的属性，也就是 Window 对象的属性

ES6 规定在全局上下文中声明的 const、let、class 变量，不属于 Global 对象的属性，从 ES6 开始，全局变量将逐步与 Global 对象的属性隔离

#### ② Node

Global 对象单独实现，Node 没有 Window 对象

#### ③ Global 方法

URL 编码方法

```javascript
const url = "http://www.b.com #哈";
encodeURI(url);          //"http://www.b.com%20#%E5%93%88"
encodeURIComponent(url); //"http%3A%2F%2Fwww.b.com%20%23%E5%93%88"
```

eval()

```javascript
eval("function sayhi(){console.log('hi')}");
sayhi(); //"hi"
```
