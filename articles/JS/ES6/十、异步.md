# 十、异步

## 1. 异步

### (1) 异步与同步

同步执行是`阻塞`的：立即执行操作，等待返回结果后再继续执行后面的代码，未返回结果之前会阻塞之后的代码执行

```js
function syncAdd(a, b) {
  return a + b;
}
syncAdd(1, 2);
console.log(4);

//输出：3 4
```

异步执行是`非阻塞`的：立即执行操作，而后继续执行后面的代码，未来某个时刻返回结果，未返回结果之前不会阻塞之后的代码执行

```js
function asyncAdd(a, b, cb) {
  setTimeout(function(){
    cb(a + b);
  }, 1000)
}
asyncAdd(1, 2, console.log)
console.log(4)

//输出：4 3(1s后打印)
```

### (2) 异步与回调

① 事件、MutationObserver、AJAX 异步请求、定时器等异步操作都是采用回调函数的方式：立即执行操作，而后继续执行后面的代码，`未来某个时刻返回结果时将回调函数添加到 JS 引擎线程的任务队列`

* 事件

```js
document.addEventListener('copy', function(e){
  const text = document.getSelection().toString();
  const info = "原文出自【张钰的个人博客】";
  const clip = e.clipboardData;
  clip.setData("text/plain", text + info);

  //阻止浏览器默认行为,使setData()添加信息成功
  e.preventDefault();
});

//JS引擎线程立即执行代码开始监听，而后继续执行后续代码，
//未来事件发生时，事件触发线程将copy事件回调函数添加到JS引擎线程的任务队列
```

* MutationObserver

```js
const observer = new MutationObserver(function(records, observer){
  records.map(record => {
    console.log('record type: ' + record.type);
    console.log('Previous value: ' + record.oldValue);
  });
});
observer.observe(document.body, {
  //观察目标节点的子元素节点
  'childList': true,

  //观察目标节点的所有属性
  'attribute': true,
  'attributeOldValue': true,

  //观察目标节点的子文本节点&子元素节点
  'characterData': true,
  'characterDataOldValue': true,
  'subtree': true
});

//JS引擎线程立即执行代码开始观察页面DOM的变动，而后继续执行后续代码，
//未来DOM发生变动时，事件触发线程将回调函数添加到JS引擎线程的任务队列
```

* AJAX 请求

```js
const xhr = new XMLHttpRequest()

//事件监听必须在调用xhr.send()发送请求之前
xhr.onreadystatechange = function(){
  if(xhr.readyState === 4 && xhr.status === 200){
    console.log(xhr.response)
  } else{
    console.error(xhr.statusText)
  }
}

//请求设置
const params = '?name=张三&age=20'
xhr.open('GET', 'http://example.com' + params, true)
xhr.setRequestHeader('Content-Type', 'application/json')
xhr.send(null)

//JS引擎线程立即执行代码，并通知异步请求线程发出请求，而后JS引擎线程继续执行后续代码，
//未来返回数据时，事件触发线程将readystatechange回调函数添加到JS引擎线程的任务队列
```

* 定时器

```js
setTimeout(function(){
  console.log(1)
}, 1000)
console.log(2)

//输出：2 1
//JS引擎线程立即执行代码，并通知定时器计数线程开始计数，而后JS引擎线程继续执行后续代码，
//定时器线程计数完成后，事件触发线程将定时器回调函数添加到JS引擎线程的任务队列
```

② 异步操作并非都是采用回调函数的方式

```js
const a = {
  counter: {
    index: 1
  }
};
console.log(a);
a.counter.index++;

//输出：{counter: index: 2}
//浏览器将控制台打印这种涉及IO的操作做了异步执行
```

③ 回调函数也并非都是异步操作

```js
const arr = [1, 2, 3]
arr.forEach(item => console.log(item))
console.log(4)

//输出：1 2 3 4，如果异步应该输出 4 1 2 3
```

### (3) 异步的原理（事件循环机制）

JS 引擎线程作为一个单线程为什么能够实现异步？

* 因为`浏览器标签页渲染进程`除了 JS 引擎线程，还有事件触发线程、异步请求线程、定时器计数线程，将一些异步操作交给其他线程处理，然后通过`事件循环机制`处理返回结果
* 因为 Node

#### ① 事件循环机制（Event Loop）

数组 eventLoop 表示任务队列，用来存放需要执行的任务，对象 event 表示当前需要执行的任务

用一个永不停歇的 while 循环来表示事件循环，一次循环称为一次 tick，每次 tick 如果任务队列中有等待的任务，就获取第一个任务执行

```js
let eventLoop = []; //任务队列，先进先出
let event;          //当前需要执行的任务

while (true) {
  //一次循环
  if (eventLoop.length > 0) {
    //任务队列中取出第一个任务
    event = eventLoop.shift(); //移除数组头部项
    try {
      event();
    } catch (err) {
      console.log(err);
    }
  }
}
```

#### ② 宏任务队列和微任务队列

任务队列按照`先进先出`的顺序执行，即使排在后面的任务更为紧急，也必须等待前面的任务先执行完成，因此 JS 引擎设置宏任务队列和微任务队列 2 个任务队列，微任务队列的优先级高于宏任务队列

**原理**：由于`微任务队列的优先级高于宏任务队列`，每次事件循环时会从微任务队列中获取任务，只有当微任务队列`清空`时才会从宏任务队列中获取任务，同一个队列中的任务只遵循`先进先出`的原则

* **微任务队列**：process.nextTick（Node，`优先级最高`）、MutaionObserver 回调函数（浏览器）、Promise.then/catch/finally()
* **宏任务队列**：DOM 事件回调函数（浏览器）、IntersectionObserver 回调函数（浏览器）、异步请求回调函数、定时器回调函数

```js
function f1() {
  setTimeout(console.log.bind(null, 1), 0)
}
function f2() {
  Promise.resolve().then(console.log.bind(null, 2))
}
function f3() {
  setTimeout(() => {
    console.log(3)
    f2()
  }, 0)
}
function f4() {
  Promise.resolve().then(() => {
    console.log(4)
    f1()
  }, 0)
}
f3()
f4()

//输出：4 3 2 1
```

如下图所示，红色代表微任务队列，绿色代表宏任务队列

![事件循环机制](https://github.com/yuyuyuzhang/Blog/blob/master/images/JS/ES/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6.png)

### (4) Web Worker

随着电脑计算能力的增强，尤其是`多核 CPU` 的出现，JS 引擎单线程模型无法充分发挥计算机的计算能力，带来很大的不便

Web Worker 就是为 JS 语言创造多线程环境，`允许 JS 引擎线程创建 Wroker 线程`，将一些任务分配给 Worker 线程运行，JS 引擎线程运行的同时，Wroker 线程在后台运行，两者互不干扰，Worker 线程完成计算任务再将结果返回给 JS 引擎线程，这样的好处是一些`计算密集型或高延迟任务`可以交给 Worker 线程运行，JS 引擎线程能够保持流畅不被阻塞或拖慢

Werker 线程一旦被创建，就会始终运行，不会被 JS 引擎线程上的活动打断，这样有利于随时响应 JS 引擎线程的通信，但也导致了 Worker 线程比较耗费资源，不应该过度使用，而且一旦使用完毕就应该关闭

### (5) JS 引擎线程执行流程示例

优先级：同步任务 > 微任务 > 宏任务

```js
console.log("同步任务1");

function asyn(mac) {
  console.log("同步任务2");
  if (mac) {
    console.log(mac);
  }
  return new Promise((resolve, reject) => {
    console.log("Promise中的同步任务");
    resolve("Promise中回调的异步微任务")
  })
}

setTimeout(() => {
  console.log("异步任务中的宏任务");
  setTimeout(() => {
    console.log("定时器中的定时器（宏任务）");
  }, 0)
  asyn("定时器传递任务").then(res => {
    console.log('定时器中的:', res);
  })
}, 0)

asyn().then(res => {
  console.log(res);
})

console.log("同步任务3")
```

![JS引擎线程执行流程示例](https://github.com/yuyuyuzhang/Blog/blob/master/images/JS/ES/JS%E5%BC%95%E6%93%8E%E7%BA%BF%E7%A8%8B%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E7%A4%BA%E4%BE%8B.png)

```js
//输出：同步任务1
//     同步任务2
//     Promise中的同步任务
//     同步任务3
//     Promise中回调的异步微任务
//     异步任务中的宏任务
//     同步任务2
//     定时器传递任务
//     Promise中的同步任务
//     定时器中的Promise中回调的异步微任务
//     定时器中的定时器（宏任务）
```

### (6) Promise、Genarator、Async 对比

#### ① Promise 对象

Promise 实例新建后`立即执行其回调函数`，Promise 实例 then 方法的参数函数等待`异步操作成功完成后`加入 JS 引擎线程的`微任务队列`

```js
//Promise实例创建则立即执行
const p = new Promise((resolve, reject) => {
  console.log(2);
  resolve(3);
  console.log(4);
});

console.log(1);
p.then(val => console.log(val));
console.log(5);

//输出：2 4 1 5 3
```

#### ② Genarator 函数

整个 Generator 函数就是一个封装的异步任务，yield 表达式就是该异步任务的分段，调用 next 方法时，从函数开头或上一次暂停的地方开始执行

**优点**：可以暂停执行和恢复执行，函数体内外可以实现数据交换，具备错误处理机制，因而可以成为异步编程的完整解决方案

**缺陷**：缺少自动执行器，不适用于异步操作，不能保证上一步执行完才执行下一步

```js
function* f(){
  console.log(2);
  yield new Promise(resolve => {
    console.log('start3')
    resolve(3)
  }).then(val => console.log('end3'))
  console.log(4);
}
const ite = f();

console.log(1);
ite.next();
console.log(5);
ite.next();

//输出：1 2 start3 5 4 end3
```

#### ③  Async 函数

整个 Async 函数就是一个封装的异步任务，await 命令就是该异步任务的分段

**优点**：自带执行器，内部实现能够保证上一步执行完才执行下一步，语义更加清晰

```js
async function f(){
  console.log(2);
  await new Promise(resolve => {
    console.log('start3')
    resolve(3)
  }).then(val => console.log('end3'))
  console.log(4)
}

console.log(1);
f();
console.log(5);

//输出：1 2 start3 5 end3 4
```

## 2. Promise

Promise 是异步编程的一种解决方案，比传统的回调函数更合理且强大，ES6 原生提供了 Promise 对象

### (1) Promise 对象

#### ① 特点

* Promise 对象的状态不受外界影响，Promise 对象代表一个有三种状态的异步操作，进行中（pending），已成功（fulfilled），已失败（rejected），只有异步操作的结果可以决定 Promise 对象当前是哪个状态，任何其他操作都无法改变这个状态
* 一旦 Promise 对象的状态改变，就会一直保持当前状态，任何时候都可以得到这个结果。Promise 对象的状态改变，只能是从进行中（pending）到已成功（fulfilled），或者从进行中（pending）到已失败（rejected），只要发生这两种情况之一，Promise 对象的状态就凝固了，此时称为已定型（resolved），状态改变后，再对 Promise 对象添加回调函数，也会立即得到这个结果，与事件完全不同，事件发生后再去监听是得不到结果的

#### ② 优点

* Promise 对象可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数
* Promise 对象提供统一的接口，使得控制异步操作更加简单

#### ③ 缺陷

* Promise 无法取消，一旦新建就会立即执行，无法中途取消
* 如果不设置回调函数，Promise 内部抛出的错误不会反映到外部
* Promise 对象如果处于进行中（pending），无法得到目前进行到具体哪个程度，刚刚开始还是即将完成

#### ④ 构造函数

ES6 规定 Promise 对象是一个构造函数，用来生成 Promise 实例

Promise 构造函数接受一个函数作为参数，该函数的两个参数分别是 resolve() 函数和 reject() 函数（由 JS 引擎提供无需自己部署），异步操作成功时调用 resolve() 函数，异步操作失败时调用 reject() 函数

* **resolve() 函数的作用**：将 Promise 实例的状态由进行中（pending）变为已成功（fulfilled），并将异步操作成功的结果作为参数传递到 Promise 实例状态变为已成功（fulfilled）时的回调函数，即 promise 实例的 then 方法的参数函数
* **reject() 函数的作用**：将 Promise 实例的状态由进行中（pending）变为已失败（rejected），并将异步操作失败的结果作为参数传递到 Promise 实例状态变为已失败（rejected）时的回调函数，即 promise 实例的 catch 方法的参数函数

```js
const p = new Promise((resolve, reject) => {
  //异步操作
  ...

  //判断异步操作结果
  if(...){
    resolve(val);
  } else{
    reject(err);
  }
});

p.then(val => console.log(val))
 .catch(err => console.log(err))
```

#### ⑤ 方法

```js
定义：const p = new Promise((resolve, reject) => {});
方法：p.then(callback)               //实例p状态变为已成功(fulfilled)时执行then方法的callback回调函数
     p.catch(callback)              //实例p状态变为已失败(rejected)时执行catch方法的callback回调函数
     p.finally(callback)            //实例p最后一定执行finally方法的callback回调函数,无论状态如何
     转化方法
     Promise.resolve(param)         //返回一个新Promise实例,状态由参数param决定
     Promise.reject(param)          //返回一个状态为已失败(rejected)的新Promise实例,参数作为实例的reject方法的参数
     合成方法
     Promise.all([p1,p2,p3])        //返回一个新Promise实例,所有Promise实例参数状态均为已成功(fulfilled),则为已成功
     Promise.any([p1,p2,p3])        //返回一个新Promise实例,所有Promise实例参数状态均为已失败(rejected),则为已失败
     Promise.race([p1,p2,p3])       //返回一个新Promise实例,状态和最先改变状态的Promise实例参数一致
     Promise.allSettled([p1,p2,p3]) //返回一个新Promise实例,状态始终是已成功(fulfilled),但是必须等待所有Promise实例参数状态改变
     包装方法
     Promsie.try(f)                 //无返回值,当同步函数在Promise实例的resolve函数中调用时,使同步函数f同步执行
```

### (2) then()

Promise.prototype.then() 方法定义在 Promise 对象的原型上，故而所有 Promise 实例都具有 then 方法

#### ① then 方法的作用

* then 方法的作用是为 Promise 实例添加状态改变时的回调函数
* then 方法可以接受 2 个函数作为参数，第一个参数函数是 Promise 实例状态变为已成功（fulfilled）时的回调函数，第二个参数函数是 Promise 实例状态变为已失败（rejected）时的回调函数，第二个参数函数不推荐使用，推荐使用后续的 catch 方法的回调函数

```js
const p = new Promise((resolve, reject) => resolve());

promise.then(val => {}, err => {});
```

#### ② then 方法的参数函数执行时间

Promise 实例新建后`立即执行其回调函数`，Promise 实例 then 方法的参数函数等待`异步操作成功完成后`加入 JS 引擎线程的`微任务队列`

```js
//最好在resolve函数和reject函数的调用语句前面加上return,防止后续语句继续执行,导致意外
const promise = new Promise((resolve, reject) => {
  resolve();
  console.log('promise');
});

promise.then(val => console.log('fulfilled'));

console.log('hi');

//输出：'promise'  'hi'  'fulfilled'
//promise实例新建后立即执行,then方法指定的fulfilled状态的回调函数需等待当前脚本所有同步任务执行完后才会执行
```

#### ③ resolve/reject 函数

* reject 函数的参数通常是 Error 对象的实例
  
  reject 函数将 Promise 实例状态变为已失败（rejected）后，将异步操作成功的结果作为参数传递到 Promise 实例状态变为已失败（rejected）时的回调函数，即 catch 方法的参数函数

  ```js
  const p = new Promise((resolve, reject) => reject(new Error('error')));
  
  p.then(val => console.log('1' + val))
   .catch(err => console.log('2' + err))

  //输出：2Error: error
  ```

* resolve 函数的参数可以是正常值
  
  resolve 函数将 Promise 实例状态变为已成功（fulfilled）后，将异步操作失败的结果作为参数传递到 Promise 实例状态变为已成功（fulfilled）时的回调函数，即 then 方法的参数函数

  ```js
  //Promise实现AJAX
  const getData = (url) => {
    const promise = new Promise((resolve, reject) => {
      const client = new XMLHttpRequest();
      client.open('POST', url);

      //回调函数不能写成箭头函数,否则this指向不正确
      client.onreadstatechange = function(){
        if(this.readyState !== 4){
          return;
        }
        if(this.status === 200){
          resolve(this.response);
        } else{
          reject(new Error(this.statusText));
        }
      };
      client.responseType = 'json';
      client.setRequestHeader('Accept', 'application/json');
      client.send();
    });
    return promise;
  }

  getData("/posts.json")
   .then(json => console.log('Contents: ' + json),
         err => console.log('Error: ' + err))
  ```

* resolve 函数的参数也可以是`另一个promise实例`
  
  p1 的状态会传递给 p2，p1 异步操作的返回结果也会传给 p2 对应状态的回调函数

  p1 的状态为进行中（pending），p2 对应状态的回调函数需等待 p1 状态改变

  p1 的状态为已成功（fulfilled）或已失败（rejected），p2 对应状态的回调函数立即执行

  ```js
  const p1 = new Promise((resolve, reject) => {
    resolve(1);
    //reject(new Error('error'));
  });
  const p2 = new Promise((resolve, reject) => resolve(p1));
  p1.then(val => console.log('p1: ' + val))
    .catch(err => console.log('p1: ' + err))
  p2.then(val => console.log('p2: ' + val))
    .catch(err => console.log('p2: ' + err))

  //p1状态为fulfilled,输出：p1: 1      p2: 1
  //p1状态为rejected, 输出：p1: Error  p2: Error
  ```

#### ④ then 方法的返回值

then 方法返回一个`新 Promise 实例`，新 Promise 实例的状态与 then 方法参数函数的返回值有关

因此可以采用链式写法，即 then 方法后再继续调用 then 方法或 catch 方法，这样可以指定一组按次序调用的回调函数，前一个 then 方法的参数函数执行完后，会将异步操作的返回结果作为参数传递到下一个 then 方法或 catch 方法的参数函数，若前一个 then 方法的参数函数返回一个 Promise 实例，那么后一个 then 方法或 catch 方法的参数函数就会`等待该 Promise 实例状态改变`时才会被调用

```js
//第一个then方法返回一个Promise实例
//该promise实例状态变为fulfilled时,调用第二个then方法的参数函数
//该promise实例状态变为rejected时,调用第三个catch方法的参数函数
getData("/posts.json")
.then(json => return getData(json.url))
.then(val => console.log('fulfilled: ' + val))
.catch(err => console.log('rejected: ' + err))
```

* then 方法的参数函数返回`值`
  
  then 方法的参数函数无 return 即是返回 `undefined`

  then 方法返回的新 Promise 实例的状态为`已成功(fulfilled)`，then 方法的参数函数返回值传递给新 Promise 实例的 then 方法的参数函数

  ```js
  const p = new Promise((resolve, reject) => resolve(1));

  //情况1：无返回值
  p.then(val => {})
   .then(val => console.log('fulfilled: ' + val))
   .catch(err => console.log('rejected: ' + err))

  //情况2：return val
  p.then(val => val)
   .then(val => console.log('fulfilled: ' + val))
   .catch(err => console.log('rejected: ' + err))

  //输出：fulfilled: undefined
  //     fulfilled: 1
  ```

* then 方法的参数函数返回 `Promise 实例`
  
  then 方法返回的新 Promise 实例的状态为 then 方法的参数函数`返回的 Promise 实例的状态`，返回值传递给新 Promise 实例的对应状态的回调函数

  ```js
  const p1 = new Promise((resolve, reject) => resolve(1));          //情况1
  const p1 = new Promise((resolve, reject) => reject(new Error())); //情况2

  const p = new Promise((resolve, reject) => resolve('ok'));
  p.then(val => p1)
   .then(val => console.log('fulfilled: ' + val))
   .catch(err => console.log('rejected: ' + err))

  //输出：fulfilled: 1
  //     rejected: Error
  ```

* then 方法的参数函数`抛出错误`
  
  then 方法返回的新 Promise 实例的状态为`已失败(rejected)`，then 方法的参数函数抛出的错误传递给新 Promise 实例的 catch 方法的参数函数

  ```js
  const p = new Promise((resolve, reject) => resolve(1));
  p.then(val => {throw Error()})
   .then(val => console.log('fulfilled: ' + val))
   .catch(err => console.log('rejected: ' + err))

  //输出：rejected: Error
  ```

### (3) catch()

catch 方法是 `then(undefined/null, rejection)` 的别名

#### ① catch 方法的作用

* catch 方法捕获 Promise 实例异步操作抛出的错误（Promise 实例状态为 rejected），以及前面所有 then 方法参数函数运行时的错误，以及前面所有 catch 方法抛出的错误
  
  ```js
  const p = new Promise((resolve, reject) => {});
  p.then(val => console.log('resolved: ' + val))
   .catch(err => console.log('rejected' + err))

  //等同于
  p.then(val => console.log('resolved: ' + val))
   .then(null, err => console.log('rejected: ' + err))

  //情况1：p状态为rejected,不会执行第一个then方法指定的参数函数,
  //但是会执行第一个then方法,而第一个then方法返回一个新Promise实例,
  //所以状态被传递给了第一个then方法返回的新Promise实例,
  //新Promise实例状态也为rejected,就会执行第二个then方法的第二个参数函数

  //情况2：p状态为fulfilled,执行第一个then方法指定的参数函数,
  //若此时运行出错,那么第一个then方法返回的新Promise实例
  //状态就是rejected,就会执行第二个then方法指定的第二个参数函数
  ```

* Promise 实例的错误具有`冒泡`性质，会一直向后传递，直到被捕获为止，也就是说，错误总会被下一个 catch 方法的参数函数捕获
  
  ```js
  const p = new Promise((resolve, reject) => {
    resolve(x + 1); //x未声明,该行会报错
  });

  p.catch(err => console.log('rejected1: ' + err)) 
   .then(val => y + 2) //y未声明,该行会报错
   .catch(err => console.log('rejected2: ' + err))

  //输出：rejected1: ReferenceError: x is not defined
  //     rejected2: ReferenceError: y is not defined
  ```

  后续 then 方法运行出错，与前面的 catch 方法无关

  ```js
  const p = new Promise((resolve, reject) => resolve(2));
  p.catch(err => console.log('rejected: ' + err)) 
   .then(val => y + 2)

  //输出：Uncaught (in promise) ReferenceError: y is not defined
  ```

* Promise 和传统的 try-catch 代码块不同的是，即使没有使用 catch 方法指定错误处理的回调函数，Promise 实例抛出的错误也不会传递到外层代码，不会影响当前脚本继续执行，但是浏览器会打印出错误原因
  
  ```js
  const p = new Promise((resolve, reject) => {
    resolve(x + 2); //x未声明,该行会报错
  });
  p.then(val => console.log('fulfilled: ' + val))

  setTimeout(() => console.log(111), 0)

  //输出：Uncaught (in promise) ReferenceError: x is not defined
  //     111
  ```

#### ② resolve/reject 函数

* Promise 实例在调用 resolve 方法后再抛出错误，是不会被捕获的，因为 Promise 实例状态已定型
  
  Promise 实例状态一旦改变，状态就会凝固，即一直保持当前状态，此时称为`已定型(resolved)`

  ```js
  const p = new Promise((resolve, reject) => {
    resolve('ok');
    throw new Error(); //不起作用
  });

  p.then(val => console.log('resolved: ' + val))
   .catch(err => console.log('rejected: ' + err)) 

  //输出：resolved: ok
  ```

#### ③ catch 方法返回值

catch 方法返回一个`新 Promise 实例`，catch 方法是 then(undefined/null, rejection) 的别名，所以 catch 方法返回的新 Promise 实例的状态同 then 方法的三种情况一样，是由 `catch 方法的参数函数的返回值`决定的

* catch 方法第一个参数函数返回`值`
  
  catch 方法参数函数无 return 即是返回 `undefined`

  catch 方法返回的新 Promise 实例的状态为`已成功（fulfilled）`，catch 方法参数函数返回值传递给新 Promise 实例的 then 方法的参数函数

  ```js
  const p = new Promise((resolve, reject) => reject(new Error()));

  //情况1：无返回值
  p.catch(err => {})
   .then(val => console.log('fulfilled: ' + val))
   .catch(err => console.log('rejected: ' + err))

  //情况2：return val
  p.catch(err => err)
   .then(val => console.log('fulfilled: ' + val))
   .catch(err => console.log('rejected: ' + err))

  //输出：fulfilled: undefined
  //     fulfilled: Error
  ```

* catch 方法第一个参数函数返回 `Promise 实例`
  
  catch 方法返回的新 Promise 实例的状态为 catch 方法参数函数`返回的 Promise 实例的状态`，返回值传递给新 Promise 实例的对应状态的回调函数

  ```js
  const p1 = new Promise((resolve, reject) => resolve(1));           //情况1
  const p1 = new Promise((resolve, reject) => reject(new Error(2))); //情况2

  const p = new Promise((resolve, reject) => rejected(new Error()));
  p.catch(err => p1)
   .then(val => console.log('fulfilled: ' + val))
   .catch(err => console.log('rejected: ' + err))

  //输出：fulfilled: 1
  //     rejected: Error: 2
  ```

* catch 方法第一个参数函数`抛出错误`
  
  catch 方法返回的新 Promise 实例的状态为`已失败（rejected）`，catch 方法参数函数抛出的错误传递给新 Promise 实例的 catch 方法的参数函数

  ```js
  const p = new Promise((resolve, reject) => reject(new Error()));
  p.catch(err => {throw new Error(2)})
   .then(val => console.log('fulfilled: ' + val))
   .catch(err => console.log('rejected: ' + err))

  //输出：rejected: Error: 2
  ```

### (4) finally()

① finally 方法用于指定无论 Promise 实例最后状态如何，都会执行的操作

② finally 方法指定的参数函数`不接受任何参数`，这意味着无法得知 Promise 实例的状态到底是已成功（fulfilled）还是已失败（rejected），表明 finally 方法参数函数中的操作与 Promise 实例的状态无关，不依赖 Promise 实例的执行结果

```js
//情况1
const p = new Promise((resolve, reject) => resolve(1));
p.then(val => console.log('fulfilled: ' + val))
 .catch(err => console.log('rejected: ' + err))
 .finally(() => console.log('finally'));
//输出：fulfilled: 1
//     finally

//情况2
const p = new Promise((resolve, reject) => reject(new Error()));
p.then(val => console.log('fulfilled: ' + val))
 .catch(err => console.log('rejected: ' + err))
 .finally(() => console.log('finally'));
//输出：rejected: Error
//     finally
```

#### ③ finally 方法的实现

finally 方法返回一个新 Promise 实例

无论 Promise 实例的状态是已成功（fulfilled）还是已失败（rejected），都会执行 finally 方法的回调函数 callback

finally 方法总是返回原来的值

```js
Promise.prototype.finally = function(callback){
  return this.then(
    val => Promise.resolve(callback()).then(() => val),
    err => Promise.resolve(callback()).then(() => {throw err})
  );
};

const p = new Promise((resolve, reject) => resolve('ok'));
p.finally(() => console.log(1));
```

### (5) done()

① 无论 Promise 实例的回调链是以 then 方法还是 catch 方法或者 finally 方法结尾，最后一个方法抛出的错误都无法被捕捉到，因为 Promise 内部的错误`不会冒泡到全局`

② done 方法总是处于回调链的尾端，保证捕捉到任何可能出现的错误，并`向全局抛出`

```js
//情况1
const p = new Promise((resolve, reject) => {throw new Error()});
p.done();

//情况2
const p = new Promise((resolve, reject) => resolve(1));
p.then(val => {throw new Error()})
 .done();

//情况3
const p = new Promise((resolve, reject) => {throw new Error()});
p.catch(err => {throw new Error()})
 .done();

//情况4
const p = new Promise((resolve, reject) => resolve(1));
p.finally(() => {throw new Error()})
 .done();

setTimeout(() => console.log(1), 0);

//输出：1
//     Uncaught Error
```

#### ③ done 方法的实现

```js
Promise.prototype.done = function(resolve, reject){
  this.then(resolve, reject)
      .catch(err => setTimeout(() => {throw err}, 0)
}

const p = new Promise((resolve, reject) => {throw Error()});
p.done();
```

### (6) 转化方法

将现有对象转化为 Promise 实例

#### ① Promise.resolve

* 不带任何参数

  返回一个状态为已成功（fulfilled）的新 Promise 实例

* 参数是一个 thenable 对象

  thenable 对象指的是具有 then 方法的对象，自动调用 Promise.resolve() 方法将这个对象转化为 Promise 实例，然后立即执行这个对象的 then 方法

* 参数是原始值，或者不是具有 then 方法的对象

  返回一个状态为已成功（fulfilled）的新 Promise 实例，参数直接传递给 then 方法的回调函数

* 参数是一个 Promise 实例

  不做任何修改，原封不动的返回这个 Promise 实例

```js
//情况2
const thenable = {
  then: function(resolve, reject){
    resolve(2);
    reject(2);
  }
}

//情况3
const val = '3';

//情况4
const p = new Promise((resolve, reject) => {
  resolve(4);
  reject(new Error(4));
});

const p1 = Promise.resolve(thenable/val/p);
p1.then(val => console.log('fulfilled: ' + val))
  .catch(err => console.log('rejected: ' + err))

//输出：情况2：fulfilled: 2   rejected: 2
//     情况3：fulfilled: 3
//     情况4：fulfilled: 4   rejected: Error: 4
```

#### ② Promise.reject

返回一个状态为已失败（rejected）的新 Promise 实例，参数作为返回的 Promise 实例的 reject 方法的参数

```js
//情况2
const thenable = {
  then: function(resolve, reject){
    resolve(2);
    reject(2);
  }
}

//情况3
const val = '3';

//情况4
const p = new Promise((resolve, reject) => {
  resolve(4);
  reject(new Error(4));
});

const p1 = Promise.reject(thenable/val/p);
p1.then(val => console.log('fulfilled: ' + val))
  .catch(err => console.log('rejected: ' + err))

//输出：情况2：rejected: [object Object]   rejected: [object Object]
//     情况3：rejected: 3
//     情况4：rejected: [object Promise]  rejected: [object Promise]
```

### (7) 合成方法

将多个 Promise 实例，包装合成为一个 Promise 实例

合成方法都是接受一个具有`Iterator 接口`的数据作为参数，并且该数据返回的每个成员都是 `Promise 实例`，如果不是 Promise 实例，则先调用 Promise.resolve() 方法将成员转换为 Promise  实例再进行处理

#### ① Promise.all

* 所有 Promise 实例参数的状态都变为已成功（fulfilled），新 Promise 实例状态才会变为已成功（fulfilled），并且所有 Promise 实例参数的返回值组成一个数组，传递给新 Promise 实例的 then 方法的参数函数

* 只要某个 Promise 实例参数的状态变为已失败（rejected），新 Promise 实例状态就会变为已失败（rejected），并且`第一个`状态变为已失败（rejected）的 Promise 实例参数的返回值，传递给新 Promise 实例的 catch 方法的参数函数
  
  ```js
  const p1 = Promise.resolve(1);

  //情况1
  const p2 = Promise.resolve(2);
  const p3 = Promise.resolve(3);

  //情况2
  const p2 = Promise.reject(new Error(2));
  const p3 = Promise.reject(new Error(3));

  const p = Promise.all([p1, p2, p3]);
  p.then(val => console.log(val))
   .catch(err => console.log(err))

  //输出：Array [1, 2, 3]
  //     Error: 2
  ```

  Promise 实例自己定义了 catch 方法，那么当该实例的状态变为已失败（rejected）时，不会触发 Promise.all() 的 catch 方法

  ```js
  const p1 = Promise.resolve(1);
  const p2 = Promise.resolve(2);

  //情况1：先创建p3,p3状态为已失败(rejected)
  const p3 = Promise.reject(new Error());
  p3.then(val => console.log('p3: ' + val))
    .catch(err => console.log('p3: ' + err))

  //情况2：p3是catch返回的新Promise实例,p3状态为已成功(fulfilled)
  const p3 = Promise.reject(new Error())
  .then(val => console.log('p3: ' + val))
  .catch(err => console.log('p3: ' + err))

  const p = Promise.all([p1, p2, p3]);
  p.then(val => console.log(val))
   .catch(err => console.log(err))

  //输出：p3: Error
  //     Error
  //输出：p3: Error
  //     Array [1, 2, undefined]
  ```

#### ② Promise.any

* 所有 Promise 实例参数的状态都变为已失败（rejected），新 Promise 实例状态才会变为已失败（rejected）

* 只要某个 Promise 实例参数的状态变为已成功（fulfilled），新 Promise 实例状态就会变为已成功（fulfilled）

```js
//该方法暂无浏览器实现
```

#### ③ Promise.race

新 Promise 实例的状态`同最先改变状态的 Promise 实例一致`，并且率先改变状态的 Promise 实例参数的返回值，会传递给新 Promise 实例的对应状态的回调函数

```js
const p1 = Promise.resolve(1);         //情况1
const p1 = Promise.eject(new Error()); //情况2
const p2 = Promise.resolve(2);
const p4 = Promise.resolve(3);

const p = Promise.race([p1, p2, p3]);
p.then(val => console.log(val))
 .catch(err => console.log(err));

//输出：1
//     Error
```

指定时间内未返回结果，就将新 Promise 实例状态变为已失败（rejected）

```js
const p = Promise.race([
  getData('url'),
  new Promise((resolve, reject) => setTimeout(reject(new Error('request error')), 3000))
]);
p.then(val => val)
 .catch(err => console.log(err));
```

#### ④ Promise.allSettled

新 Promise 实例的状态总是`已成功（fulfilled）`，但是必须等到`所有 Promise 实例都改变状态`，包装实例才结束，`所有 Promise 实例构成的数组`，作为参数传递到新 Promise 实例的 then 方法的参数函数

```js
const p1 = Promise.resolve(1);
const p2 = Promise.resolve(2);
const p3 = Promise.reject(new Error());

const p = Promise.allSettled([p1, p2, p3]);
p.then(val => console.log(val))
 .catch(err => console.log(err));

//输出：Array [{status: 'fulfilled', value: 1}, {status: 'fulfilled', value: 2}, {status: 'rejected', reason: Error}]
```

有时候，我们不关心异步操作的结果，只关心异步操作是否结束，此时 Promise.allSettled() 就很有用，可以确保所有异步操作都结束

```js
const urls = [ /_ ... _/ ];
const requests = urls.map(x => fetch(x));
const results = await Promise.allSettled(requests);

//过滤出成功的请求
const successfulPromises = results.filter(p => p.status === 'fulfilled');

//过滤出失败的请求,并输出原因
const errorPromises = results.filter(p => p.status === 'rejected')
const errorReasons = errorPromises.map(p => p.reason);

try{
  await Promise.allSettled(requests)
  console.log('所有请求都成功。');
} catch{
  console.log('至少一个请求失败，其他请求可能还未结束。');
}
```

### (8) Promise.try

Promise.try() 为所有同步和异步操作提供了统一的处理机制，并且让它们具有统一的 API，无论函数是同步还是异步，都用 then 方法指定下一步流程，用 catch 方法处理抛出的错误

① 同步函数用 Promise.try() 包装后会变成`异步执行`

```js
const f = () => console.log(1);
Promise.try(f);

console.log(2);

//输出：2 1
```

② 想要让同步函数用 Promise.try() 包装后仍然是`同步执行`，有 2 种实现方式

* 实现方式一：使用 new Promise
  
  ```js
  const f = () => console.log(1);
  (() => Promise.resolve(f()))()

  console.log(2);

  //输出：1 2
  ```

* 实现方式二：使用 async 函数，但是这样需要使用 catch 方法捕获错误
  
  ```js
  const f = () => console.log(1);

  (async () => f())()
  .then(val => val)
  .catch(err => console.log(err));

  console.log(2);

  //输出：1 2
  ```

## 3. Generator

Generator 函数返回一个`同步遍历器对象`

### (1) yield 表达式

#### ① 惰性求值

yield 表达式是暂停标志，yield 关键字后面的表达式，`只有当调用 next 方法，内部指针指向该语句时才会执行`，其他情况下不会执行，相当于为 ES 提供了手动的惰性求值

```js
function* f(){
  yield 123 + 456;
}
const ite = f(); //此处不执行

console.log(ite.next()); //{value: 579, done: false}
console.log(ite.next()); //{value: undefined, done: true}
```

暂缓执行函数：Generator 函数如果不使用 yield 表达式，就变成了一个单纯的暂缓执行函数，只有调用 next 方法时才会执行

```js
function* f(){
  return '执行';
}
const ite = f(); //此处不执行

setTimeout(() => console.log(ite.next()), 3000); //3秒后输出 {value: '执行', done: true}
```

#### ② 返回值

yield 命令后跟一个`表达式`，yield 表达式本身没有返回值，或者说总是返回 `undefined`，但是可以`通过 next() 方法返回表达式的值`

```js
function* f(){
  yield 1;
  console.log(yield 2);
}
for(let item of f()){
  console.log(item); //1  2  undefined
}
```

#### ③ 位置记忆功能

yield 表达式与 return 语句都能通过 next() 方法返回紧跟在语句后面的表达式的值

* yield 语句具备位置记忆功能，每次调用 next 方法，都从`函数开头或者上次暂停的地方`继续执行，一个函数可以执行多个 yield 表达式，因此 Generator 函数可以返回一系列值

* return 语句不具备位置记忆功能，一个函数只能执行一个 return 语句，因此正常函数只能返回一个值

```js
function* f(){
  yield 1;
  console.log(yield 2);
  yield 3;
}
const ite = f();

console.log('第一次调用next');
console.log(ite.next());
console.log('第二次调用next');
console.log(ite.next());
console.log('第三次调用next');
console.log(ite.next());

//输出：第一次调用next
//     {value: 1, done: false}
//     第二次调用next
//     {value: 2, done: false}
//     第三次调用next
//     undefined  
//     {value: 3, done: true}
```

#### ⑤ yield 表达式在另一个表达式中使用，必须放在圆括号中

yield 表达式用作函数参数或者放在赋值表达式右边，可以不放在圆括号中

```js
function* f(){
  return 'hello ' + (yield '张三');
}
const ite = f();

console.log(ite.next()); //{value: "张三", done: false}
console.log(ite.next()); //{value: 'hello undefined', done: true}
                         //第二次调用next时执行的是return,yield是惰性求值,只有第一次调用next时才求值,其他情况下返回undefined
```

### (2) yield* 表达式

#### ① 用途

`yield*` 表达式用来在一个 Gennerator 函数内部调用另一个 Generator 函数，yield* 命令`不遍历 return 语句`

```js
function* f1(){
  yield 1;
  return 2;
}
function* f2(){
  yield 3;
  f1();        //情况1,直接调用Generator函数不起作用
  yield f1();  //情况2,不会执行f1,毫无意义
  yield* f1(); //情况3,执行f1
  yield 4;
}
for(let item of f2()){
  console.log(item);
}

//输出：3      4
//     3  f1  4
//     3  1   4
```

任何有 Iterator 接口的数据结构，就可以被 yield* 命令遍历

```js
function* f(){
  yield* 'hello';
  yield* [1, 2, 3];
}
for(let item of f()){
  console.log(item); //'h' 'e' 'l' 'l' 'o' 1 2 3
}
```

```js
//yield*命令可以方便地取出嵌套数组的所有成员
function* iterTree(tree){
  if(Array.isArray(tree)){
    for(let i=0; i<tree.length; i++){
      yield* tree[i];
    }
  } else{
    yield tree;
  }
}
const tree = [1, 2, [3, 4, [6, 7]]];
for(let item of iterTree(tree)){
  console.log(item); //1 2 3 4 6 7
}
```

#### ② 返回值

yield* 命令的返回值由`被代理的 Generator 函数的 return 语句`决定

```js
function* f1(){
  yield 1;
  return 'f1 end'; //return语句决定yield*表达式返回值
}
function* f2(){
  yield 3;
  console.log(yield* f1());
  yield 4;
}
for(let item of f2()){
  console.log(item);
}
//输出：3  1  'f1 end'   4
```

### (3) next()

#### ① 返回值

调用 Generator 函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向函数内部状态的`同步遍历器对象`，每次调用同步遍历器对象的 next() 方法返回`当前遍历成员的信息对象`，value 属性是当前内部状态的值，done 属性是遍历是否结束的布尔值，Generator 函数若没有 return 语句，调用 next 方法返回的对象 value 属性值为 `undefined`，指针从`函数头部或上一次暂停的地方`开始执行，`直到遇到下一个 yield 表达式或 return 语句为止`，换而言之，Generator 函数是分段执行的，yield 表达式是暂停执行的标记，而 next 方法可以恢复执行

```js
//该函数有三个内部状态：'hello' 'world' 'ending'
function* f(){
  yield 'hello';
  yield 'world';
  return 'ending';
}
const ite = f();

console.log(ite.next()); //{value: 'hello', done: false}
console.log(ite.next()); //{value: 'world', done: false}
console.log(ite.next()); //{value: 'ending', done: true}
```

#### ② 参数

yield 表达式本身没有返回值，或者说总是返回 `undefined`，next 方法可以带一个参数，该参数会被当做`上一个 yield 表达式的返回值`

```js
function* f(){
  for(let i = 0; true; i++){
    let reset = yield i;
    if(reset){
      i = -1;
    }
  }
}
const ite = f();

console.log(ite.next());     //{value: 0, done: false}
console.log(ite.next());     //{value: 1, done: false},next方法无参数时,reset总是等于undefined
console.log(ite.next(true)); //{value: 0, done: false},next方法参数作为上一个yield表达式的值,此时reset=true
```

Generator 函数从暂停状态到恢复执行，其执行上下文不变，但是通过 next 方法的参数，可以在 Generator 函数运行后继续向函数体内部注入值，也就是说，可以在 Generator 函数运行的不同阶段，从外部向函数内部注入不同的值，从而调整函数的行为

```js
function* f(x){
  const y = 2 * (yield (x + 1));
  const z = yield (y / 3);
  return x + y + z;
}
const ite = f(5);

//情况1
console.log(ite.next()); //{value: 6, done: false}
console.log(ite.next()); //{value: NaN, done: false}
console.log(ite.next()); //{value: NaN, done: true}

//情况2
console.log(ite.next());  //{value: 6, done: false}
console.log(ite.next(6)); //{value: 4, done: false}
console.log(ite.next(4)); //{value: 21, done: true}
```

如果想在第一次调用 next 方法时就能够输入值，可以在 Generator 函数外面`再包一层`

```js
function wrapper(f){
  return function(...args){
    const result = f(...args);
    result.next(); //先执行一次next
    return result;
  }
}
const wrapped = wrapper(function* (...args){
  console.log(`${args}. ${yield}`); //已执行过一次next,'hello'为此处yield表达式返回值
  return 'done';
});
const ite = wrapped(1);
ite.next('hello'); //'1. hello'


//等价于
const wrapped = function(...args){
  const f = function* (...args){
    console.log(${args}. ${yield}); 
    return 'done';
  }
  const result = f(...args);
  result.next();
  return result;
}
const ite = wrapped(1)
ite.next('hello');


//等价于
const f = function* (...args){
  console.log(${args}. ${yield});
  return 'done';
}
const ite = f(1);
ite.next();
ite.next('hello');
```

#### ③ for-of 循环

for-of 循环可以自动遍历 Generator 函数生成的同步遍历器对象，一旦 next 方法返回对象的 done 属性为 true，for-of 循环就会终止，且不包含该返回对象，因此 `return 语句不在 for-of 循环中`

```js
function* f(){
  yield 'hello';
  yield 'world';
  return 'ending';
}

//情况1
const ite = f();
console.log(ite.next()); //{value: 'hello', done: false}
console.log(ite.next()); //{value: 'world', done: false}
console.log(ite.next()); //{value: 'ending', done: true}

//情况2：for-of循环不包含return语句
for(let item of f()){
  console.log(item); //'hello'  'world'
}
```

除了 for-of 循环，扩展运算符、解构赋值、Array.form() 方法内部调用的都是同步遍历器接口

```js
function* f(){
  yield 1;
  yield 2;
  return 3;
  yield 4;
}

//情况1
[...f()]; //Array [1, 2]

//情况2
let [x, y] = f(); //x=1,y=2

//情况3
Array.from(f()); //Array [1, 2]

//情况4
for(let item of f()){
  console.log(item); //1 2
}
```

```js
//利用Generator函数和for-of循环,实现斐波那契数列
function* fibonacci() {
  let [prev, curr] = [0, 1];
  for(;;){
    [perv, curr] = [curr, perv + curr];
    yield curr;
  }
}
for(let i of fibonacci()){
  if(i > 100){
    break;
  }
  console.log(i); //1 2 3 5 8 13 21 34 55 89
}
```

### (4) throw()

#### ① 参数

throw 方法可以接受一个参数，该参数会被 catch 语句接收，建议抛出 Error 对象的实例

#### ② 执行

Generator 函数返回的同步遍历器对象，都有一个 throw 方法，throw 方法可以在函数体外抛出错误

* 若 Generator 函数体内部署 try-catch 代码块，那么 throw 方法抛出的错误将被函数体内的 catch 语句捕获
  
  ```js
  //情况1
  function* f(){
    try{
      yield;
    } catch(e){
      console.log('内部捕获：' + e);
    }
  }
  const ite = f();
  ite.next(); //执行函数f内部的yield表达式,并且暂停在此处

  try{
    ite.throw('a'); //被函数体内的catch语句捕获,此时函数体内的try-catch代码块已执行完毕
    ite.throw('b'); //此时函数体内的try-catch代码块已经执行完毕,只能被函数体外的catch语句捕获
  } catch(e){
    console.log('外部捕获：' + e);
  }

  //输出：内部捕获：a
  //     外部捕获：b
  ```

* 若 Generator 函数体内未曾部署 try-catch 代码块，然后 throw 方法抛出的错误只能被函数体外的  catch 语句捕获
  
  ```js
  //情况2
  function* f(){
    yield;
    console.log('内部');
  }
  const ite = f();
  ite.next(); //执行函数f内部的yield表达式,并且暂停在此处

  try{
    ite.throw('a'); //函数体内未部署try-catch代码块,被函数体外的catch语句捕获,此时函数体外的try-catch代码块已执行完毕
    ite.throw('b'); //此时函数体外的try-catch代码块已经执行完毕,不会再次捕获throw方法抛出的错误
  } catch(e){
    console.log('外部捕获：' + e);
  }

  //输出：外部捕获：a
  ```

* 若 Generator 函数体外也未曾部署 try-catch 代码块，那么程序将报错，直接`中断执行`
  
  ```js
  //情况3
  function* f(){
    yield;
    console.log('内部');
  }
   const ite = f();
  ite.next();
  ite.throw();

  //输出：Uncaught undefined
  ```

* 只要 Generator 函数体内部署 try-catch 代码块，throw 方法抛出的错误，`不会影响下次遍历`，否则遍历直接终止，即使函数体外部署了 try-catch 代码块
  
  throw 方法被捕获以后，会附带执行下一条 yield 语句，也就是说，`会附带执行一次next方法`

  ```js
  function* f(){
    try{
      yield console.log(1);
    } catch(e){
      console.log('内部捕获：' + e);
    }
    yield console.log(2);
    yield console.log(3);
  }
  const ite = f();

  ite.next();  //1
  ite.throw(); //'内部捕获：undefined'   2
  ite.next();  //3
  ```

* 一旦 Generator 函数执行过程中抛出错误，且没有被内部捕获，就不会再继续执行，如果此后还调用 next 方法，将返回一个 value 属性等于 undefined，done 属性等于 true 的对象，即 JS 引擎认为这个 Generator 函数已经执行完毕
  
  ```js
  function* f(){
    yield console.log(1);
    throw new Error('出错');
    yield console.log(2);
    yield console.log(3);
  }
  function log(ite){
    let v;
    console.log('start');
    try{
      v = ite.next();
      console.log('第一次运行next方法', v);
    } catch(e){
      console.log('捕获错误：' + e);
    }
    try{
      v = ite.next();
      console.log('第二次运行next方法', v);
    } catch(e){
      console.log('捕获错误：' + e);
    }
    try{
      v = ite.next();
      console.log('第三次运行next方法', v);
    } catch(e){
      console.log('捕获错误：' + e);
    }
    console.log('end');
  }
  const ite = f();
  log(ite);

  //输出： start
  //      1
  //      第一次运行next方法  {value: undefined, done: false}
  //      捕获错误：Error：出错
  //      第三个运行next方法  {value: undefined, done: true}
  //      end
  ```

#### ③ 全局 throw 命令

全局 throw 命令与 Generator 函数的 throw 方法无关，两者互不影响

全局 throw 命令抛出的错误只能被函数体外的 catch 语句捕获

```js
function* f(){
  try{
    yield;
  } catch(e){
    console.log('内部捕获：' + e);
  }
}
const ite = f();
ite.next(); //执行函数f内部的yield表达式,并且暂停在此处

try{
  throw new Error('a'); //全局throw命令抛出的错误只能被函数体外的catch语句捕获,此时函数体外的try-catch代码块已经执行完毕
  throw new Error('b'); //函数体外的try-catch代码块已经执行完毕,不会再次捕获全局throw命令抛出的错误
} catch(e){
  console.log('外部捕获：' + e);
}

//输出：外部捕获：Error: a
```

### (5) return()

#### ① 参数

Generator 函数的 return 方法可以`返回参数`，并且终结遍历 Generator 函数

```js
function* f(){
  yield 1;
  yield 2;
  yield 3;
}
const ite = f();

console.log(ite.next());        //{value: 1, done: false}
console.log(ite.return('end')); //{value: 'end', done: true}
```

#### ② 执行

若 Generator 函数体内部署 try-finally 代码块，那么`调用 return 方法时，就开始执行 finally 代码块`，finally 代码块执行完毕后，再执行 return 方法

```js
function* f(){
  yield 1;
  try{
    yield 2;
    yield 3;
  } finally{
    yield 4;
    yield 5;
  }
  yield 6;
}
const ite = f();

console.log(ite.next());        //{value: 1, done: false}
console.log(ite.next());        //{value: 2, done: false},执行finally代码块
console.log(ite.return('end')); //{value: 4, done: false}
console.log(ite.next());        //{value: 5, done: false}
console.log(ite.next());        //{value: 'end', done: true},执行return方法
console.log(ite.next());        //{value: undefined, done: true}
```

### (6) 同步遍历器接口

Generator 函数就是`同步遍历器生成函数`，因此可以直接将 Generator 函数赋值给对象的 Symbol.iterator 属性使该对象具有同步遍历器接口

```js
const obj = {
  name: '张三',
  friends: ['王五', '赵六'],
};
function* f(){
  const props = Reflect.ownKeys(this);
  for(let prop of props){
    yield [prop, obj[prop]];
  }
}
obj[Symbol.iterator] = f;

for(let [key, value] of obj){
  console.log(`${key}: ${value}`); 
}

//输出：name:    '张三'  
//     friends: '王五,赵六'
```

Generator 函数调用后返回的同步遍历器对象，本身也具有 Symbol.iterator 属性，执行后返回自身

```js
function* f(){}
const ite = f();
console.log(iteSymbol.iterator === ite); //true
```

### (7) Generator 函数的 this

① Generator 函数返回同步遍历器，ES6 规定这个同步遍历器是 Generator 函数的实例，继承了 Generator 函数原型的方法

```js
function* f(){}
f.prototype.sayHi = function(){
  console.log('hi');
}
const ite = f();

console.log(ite instanceof f); //true
ite.sayHi(); //'hi'
```

② Generator 函数不是普通的构造函数

* Generator 函数返回的是同步遍历器对象，而非 this 对象
* Generator 函数不能和 new 命令一起用，否则会报错

```js
function* f(){
  this.a = 1
}
const ite = f();

console.log(ite.a); //undefined
new f(); //TypeError: f is not a constructor
```

### (8) Generator 函数执行上下文

#### ① 普通函数的执行上下文

JS 引擎执行某个普通函数时，创建该函数的执行上下文，并且压入执行上下文栈，该函数执行完成后，函数上下文从执行上下文栈中弹出并`销毁`

#### ② Generator 函数的执行上下文

JS 引擎执行某个 Generator 函数时，创建该 Generator 函数的执行上下文，并且压入执行上下文栈，一旦遇到 yield 命令，Generator 函数上下文就从执行上下文栈中弹出但并不销毁而是暂时`冻结`在当前状态，等到对该 Generator 函数的同步遍历器对象执行 next 命令时，该 Generator 函数上下文重新压入执行上下文栈，冻结的变量和对象恢复执行

```js
function* f(){
  yield 1;
  yield 2;
}
const ite = f();
console.log(ite.next()); //第一次执行next,f上下文压入上下文栈,开始执行f内部代码,yield 1执行完毕后,f上下文退出上下文栈,内部状态冻结
console.log(ite.next()); //第二次执行next,f上下文重新压入上下文栈,内部状态解冻,恢复执行
```

### (9) 自动流程管理

Generator 函数不能实现自动执行，只有调用 next 方法才会执行，普通的循环执行不适合异步操作，因为不能保证上一步执行完才执行下一步

```js
function* f(){
  console.log(2);
  yield Promise.resolve(3).then(val => console.log(val));
  console.log(4);
}

const ite = f();
var res = ite.next();
while(!res.done){
  console.log(res.value);
  res = ite.next();
}

//输出：2  4  3
```

基于 Promise 对象的 Generator 函数自动执行器：异步操作有了结果，`在 then 方法中交回执行权`

```js
function* f(){
  console.log(2);
  yield Promise.resolve(3).then(val => console.log(val));
  console.log(4);
}

function runG(f){
  const ite = f();
  const next = function(data){
    let res = ite.next(data);
    if(res.done){
      return;
    }
    res.value.then(function(data){
      next(data);
    });
  }
  next();
}

runG(f); //2 3 4
```

## 4. Async

Async 函数是 Generator 函数的语法糖，使得异步操作变得更加方便，Async 函数返回一个 `Promise 实例`

### (1) await 命令

await 命令表示需要`等待`其后的表达式执行完成，await 命令后跟表达式有如下三种类型

#### ① 原始类型值

await 命令直接返回后跟原始类型值，return 语句将其传递到 Async 函数返回的 Promise 实例的 then 方法的参数函数

```js
async function f(){
  return await 1;
}
f().then(val => console.log(val))

//输出：1
```

#### ② Promise 实例

await 命令等待后跟 Promise 实例的状态改变，返回后跟 Promise 实例的 resolve/reject 函数的参数

* 状态变为已成功（fulfilled），await 命令返回 resolve 函数的参数，return 语句将其传递到 Async 函数返回的 Promise 实例的 then 方法的参数函数
* 状态变为已失败（rejected），await 命令返回 reject 函数的参数，return 语句将其传递到 Async 函数返回的 Promise 实例的 catch 方法的参数函数

```js
async function f(){
  return await new Promise((resolve, reject) => {
    resolve(1); //情况1
    reject(2);  //情况2
  });
}
f().then(val => console.log(val))
   .catch(err => console.log(err));

//输出：1
//     2
```

#### ③ thenable 对象

自动调用 Promise.resolve() 方法将 thenable 对象转化为 Promise 实例，然后立即执行该 Promise 实例的 then 方法

await 命令等待该 Promise 实例的 then 方法返回的 Promise 实例的状态改变

* 状态变为已成功（fulfilled），await 命令返回 resolve 函数的参数，传递到 Async 函数返回的 Promise 实例的 then 方法的参数函数
* 状态变为已失败（rejected），await 命令返回 reject 函数的参数，传递到  Async 函数返回的 Promise 实例的 catch 方法的参数函数

```js
const thenable = {
  then: function(resolve, reject){
    resolve(1); //情况1
    reject(2);  //情况2
  }
}
async function f(){
  return await thenable;
}
f().then(val => console.log(val))
   .catch(err => console.log(err));

//输出：1
//     2
```

### (2) Async 函数的执行

Async 函数返回一个 `Promise 实例`，return 语句的返回值将被传递到 Promise 实例对应状态的回调函数，没有 return 语句即返回值为 `undefined`

① Async 函数内部抛出错误，Async 函数返回的 Promise 实例的状态变为已失败（rejected），`无需return语句`，错误对象直接被传递到 Promise 实例的 catch 方法的参数函数

```js
async function f(){
  throw new Error('error');
}
f().then(val => console.log(val))
   .catch(err => console.log(err));

//输出：Error: error
```

② 所有 await 命令后跟 Promise 实例状态都变为已成功（fulfilled），Async 函数返回的 Promise 实例状态变为已成功（fulfilled）

任意一个  Promise 实例状态变为已失败（rejected），Async 函数返回的 Promise 实例状态变为已失败（rejected），，Async 函数`中断执行`，`无需return语句`，错误对象直接被传递到 Promise 实例的 catch 方法的参数函数

```js
const p1 = Promise.resolve(1);          //情况1
const p1 = Promise.reject(new Error()); //情况2
const p2 = Promise.resolve(2);
const p3 = Promise.resolve(3);

async function f(){
  await p1;
  await p2;
  await p3;
  console.log('complete');
}

f().then(val => console.log(val))
   .catch(err => console.log(err));

//输出：'complete'  undefined
//     Error
```

③ 若希望前一个 await 命令后的 Promise 实例状态变为已失败（rejected），仍要执行后面的 await 命令

* 第一种方式是将前面的 await 命令放在 try-catch 代码块中

* 第二种方式是前面的 await 命令后跟 Promise 实例加上 catch 方法，用于捕获错误

```js
const p1 = Promise.reject(new Error(1)).catch(err => console.log(err)); 
const p2 = Promise.resolve(2).then(val => console.log(val));
const p3 = Promise.resolve(3).then(val => console.log(val));

async function f(){
  await p1;
  await p2;
  await p3;
  console.log('complete');
} 
f().then(val => console.log(val))
   .catch(err => console.log(err));

//输出：'Error: 1'  2  3  
//      'complete'  undefined
```

④ 多个 await 命令后的异步操作，如果不存在继发关系，最好使用 `Promise.all()` 同时触发

```js
const p1 = Promise.resolve(1).then(val => console.log(val));
const p2 = Promise.resolve(2).then(val => console.log(val));
const p3 = Promise.resolve(3).then(val => console.log(val));

async function f(){
  await Promise.all([p1, p2, p3]);
}

f().then(val => console.log(val))
   .catch(err => console.log(err));

//输出：1 2 3 undefined
```

### (3) Async 函数的执行上下文

#### ① 普通函数的执行上下文

JS 引擎执行某个普通函数时，创建该函数的执行上下文并且压入执行上下文栈，该函数执行完成后，函数上下文从执行上下文栈中弹出并`销毁`

#### ② Async 函数的执行上下文

JS 引擎执行某个 Async 函数时，创建该 Async 函数的执行上下文并且压入执行上下文栈，一旦遇到 await 命令， Async 函数上下文就从执行上下文栈中弹出但并不销毁而是暂时`冻结`在当前状态，等到该 await 命令后的操作执行完毕，该 Async 函数上下文重新压入上下文栈并且冻结的变量和对象恢复执行

```js
const p1 = Promise.resolve(1).then(val => console.log(val));
const p2 = Promise.resolve(2).then(val => console.log(val));

async function f(){
  await p1; //执行到当前await命令时,f上下文退出上下文栈,内部状态冻结,p1执行完成后,f上下文重新压入上下文栈,内部状态解冻,恢复执行
  await p2;
}
f().then(val => console.log(val))
   .catch(err => console.log(err));

//输出：1 2 undefined
```

## 5. 异步 Generator

异步 Generator 函数是 Generator 函数和 Async 函数的结合，异步 Generator 函数返回一个`异步遍历器对象`

### (1) 异步 Generator 函数

① 调用异步 Generator 函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向函数内部状态的`异步遍历器对象`，每次调用异步遍历器对象的 next() 方法返回一个 `Promise 实例`，当前遍历成员异步遍历成功后其`信息对象`作为参数传递给该 Promise 实例的 then 方法的参数函数

```js
async function* g() {
  yield 'hello';
  yield '111';
  yield '222';
}

const asyncIte = g(); //返回一个异步遍历器
asyncIte.next()
  .then(val1 => {
    console.log(val1);
    return asyncIte.next();
  })
  .then(val2 => {
    console.log(val2);
    return asyncIte.next();
  })
  .then(val3 => {
    console.log(val3);
  });

//输出：{ value: 'hello', done: false }
//     { value: '111', done: false }
//     { value: '222', done: false }
```

② 异步遍历器的 next() 方法返回 Promise 实例，因此可以将其放在 await 命令后面，await 命令会返回后跟 Promise 实例的异步操作的结果

```js
async function iteG(){
  const asyncIte = g(); //返回一个异步遍历器

  console.log(await asyncIte.next());
  console.log(await asyncIte.next());
  console.log(await asyncIte.next());
}
iteG();

//输出：{ value: 'hello', done: false }
//     { value: '111', done: false }
//     { value: '222', done: false }
```

③ 异步遍历器的 next() 方法是可以`连续调用`的，无需等到上一步的 Promise 实例的状态改变后再调用，因为 next() 方法会累计起来自动按照序运行，因此可以直接将所有的 next() 方法放入 `Promise.all()` 中

```js
async function iteG(){
  const asyncIte = g(); //返回一个异步遍历器

  const [a, b, c] = await Promise.all([asyncIte.next(), asyncIte.next(), asyncIte.next()])

  console.log(a, b, c);
}
iteG();

//输出：{ value: 'hello', done: false }
//     { value: '111', done: false }
//     { value: '222', done: false }
```

### (2) 异步遍历器接口

Generator 函数就是`同步遍历器生成函数`，因此可以直接将 Generator 函数赋值给对象的 Symbol.iterator 属性使该对象具有同步遍历器接口

```js
//同步遍历器
function* map(iterable, func) {
  const iter = iterable[Symbol.iterator]();
  while (true) {
    const {value, done} = iter.next();
    if (done) break;
    yield func(value);
  }
}
```

```js
//异步遍历器
async function* map(iterable, func) {
  const iter = iterable[Symbol.asyncIterator]();
  while (true) {
    const {value, done} = await iter.next();
    if (done) break;
    yield func(value);
  }
}
```

部署了异步遍历器接口的数据结构就可以使用 `for-await-of` 循环遍历，for-await-of 循环本质上就是调用异步遍历器接口生成的遍历器对象

```js
async function iteG(){
  const asyncIte = g(); //返回一个异步遍历器

  try{
    for await (const item of asyncIte){
      console.log(item)
    }
  } catch(err){
    console.log(err)
  }
}
iteG();

//输出：'hello'
//      '111'
//      '222'
```

## 6. queueMicrotask(cb)

### (1) 浏览器

浏览器的 window 对象上实现了 window.queueMicrotask(cb) API，同于将回调函数 cb 添加到 JS 引擎线程的微任务队列

```js
console.log('start')
window.queueMicrotask(() => {
    console.log('queueMicrotask')
})
setTimeout(() => {
    console.log('setTimeout')
}, 0)
console.log('end')

//输出：
//'start'
//'end'
//'queueMicrotask'
//'setTimeout'
```

### (2) Node

同样地，Node 实现了全局方法 queueMicrotask(cb) API 用于将回调函数 cb 添加到 JS 引擎线程的微任务队列，queueMicrotask(cb) API 提供了一种可移植且可靠的延迟执行机制，该机制适用于多个不同的 JS 平台环境，是 process.nextTick(cb) 的替代方案，除非需要 process.nextTick(cb) 的特定功能，否则请使用 queueMicrotask(cb)

两个 API 之间唯一值得注意的区别是 process.nextTick(cb) 允许指定`额外参数`传递给回调函数 cb，使用 queueMicrotask(cb) 实现相同的结果需要使用`闭包或绑定函数`

* index.js
* npm run serve

    ```js
    console.log('start')
    queueMicrotask(() => {
        console.log('queueMicrotask')
    })
    setTimeout(() => {
        console.log('setTimeout')
    }, 0)
    console.log('end')

    //输出：
    //'start'
    //'end'
    //'queueMicrotask'
    //'setTimeout'
    ```
