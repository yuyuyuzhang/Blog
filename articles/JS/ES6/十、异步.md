# 十、异步

[[_TOC_]]

## 1. 异步



## 1. 异步

### (1) 原理

#### ① 单线程

一次只能完成一个任务，如果有多个任务，就必须排队，前面一个任务完成，才能执行后面一个任务，以此类推

**优点**：实现比较简单，执行环境相对单纯，

**缺陷**：一个任务耗时很长， 后面的任务就必须排队等待，会拖延整个程序的执行，容易造成浏览器假死无响应，为了解决单线程的缺陷，JS 语言将任务的执行模式分成同步和异步两种

#### ② 同步任务

一个任务`连续的执行`，后一个任务等待前一个任务执行完毕再执行，程序的执行顺序与`任务的排列顺序`一致，

#### ③ 异步任务

一个任务`不是连续的执行`，而是被人为分成多段，先执行第一段，然后转而执行其他的任务，等做好了准备，再回头执行第二段，程序的执行顺序`不规律`，

### (2) 异步编程方式

#### ① 回调函数

异步任务的第二段单独写在一个函数里面，等重新执行这个异步任务时，就直接调用这个回调函数

```javascript
function f1(callback){
  console.log(2);
  setTimeout(() => callback(), 0); //下轮事件循环执行
  console.log(4)
}
function f2(){
  console.log(3);
}

console.log(1);
f1(f2);
console.log(5);

//输出：1 2 4 5 3
```

#### ② 事件监听

异步任务的第二段写在事件监听程序的回调函数里面，事件发生时，就直接调用这个回调函数，程序的执行顺序与`事件的发生时间`有关，

```javascript
//<button id="btn">点击</button>

console.log(1);

const btn = document.getElementById('btn');
btn.addEventListener('click', function(e){
  console.log(2);
  setTimeout(() => console.log(3), 0); //下轮事件循环执行
  console.log(4);
});

console.log(5);

//输出：1 5 2 4 3
```

#### ③ Promise 对象

Promise 实例创建则`立即执行`，Promise 实例的 then 方法在`本轮事件循环末尾执行`，

**优点**：回调函数变成了链式调用，程序的流程可以看得很清楚，一个任务已经完成，再添加回调函数，该回调函数会立即执行，所以`不用担心错过某个事件或信号`，

**缺陷**：Promise 对象的最大问题是`代码冗余`，原来的任务被 Promise 对象包装以后，不管什么操作，一眼看去都是一堆 then，原来的语义变得很不清楚

```javascript
//Promise实例创建则立即执行
const p = new Promise((resolve, reject) => {
  console.log(2);
  resolve(3);
  console.log(4);
});

console.log(1);
p.then(val => console.log(val)); //Promise的then在本轮事件循环末尾执行
console.log(5);

//输出：2 4 1 5 3
```

#### ④ Genarator 函数

整个 Generator 函数就是一个封装的异步任务，yield 表达式就是该异步任务的分段，调用 next 方法时，从函数开头或上一次暂停的地方开始执行，执行到 yield 命令时，

* yield 命令后跟同步操作：先执行完 yield 命令后的同步操作，再暂停执行，冻结函数上下文，Generator 函数交出执行权，当前脚本所有同步任务执行完毕后，Generator 函数恢复执行权，继续执行，直到下一个 yield 命令

* yield 命令后跟异步操作：先暂停执行，冻结函数上下文，Generator 函数交出执行权，当前脚本所有同步任务执行完毕后，Generator 函数恢复执行权，再执行 yield 命令后的异步操作，异步操作完成后，继续执行，直到下一个 yield 命令

**优点**：可以暂停执行和恢复执行，函数体内外可以实现数据交换，具备错误处理机制，因而可以成为异步编程的完整解决方案

**缺陷**：缺少自动执行器，不适用于异步操作，不能保证上一步执行完才执行下一步，

```javascript
function* f(){
  console.log(2);
  yield console.log(3); //情况1：同步操作
  yield Promise.resolve(3).then(val => console.log(val)); //情况2：异步操作(Promise的then在本轮事件循环末尾执行)
  console.log(4);
}
const ite = f();

console.log(1);
ite.next();
console.log(5);
ite.next();

//输出：1 2 3 5 4
//     1 2 5 4 3
```

#### ⑤  Async 函数

整个 Async 函数就是一个封装的异步任务，await 命令就是该异步任务的分段，Async 函数执行到 await 命令时，

* await 命令后跟同步操作：先执行完 await 命令后的同步操作，再暂停执行，冻结函数上下文，Async 函数交出执行权，当前脚本所有同步任务执行完毕后，Async 函数恢复执行权，继续执行，直到下一个 await 命令

* await 命令后跟异步操作：先暂停执行，冻结函数上下文，Async 函数交出执行权，当前脚本所有同步任务执行完毕后，Async 函数恢复执行权，再执行 await 命令后的异步操作，异步操作完成后，继续执行，直到下一个 await 命令

**优点**：自带执行器，内部实现能够保证上一步执行完才执行下一步，语义更加清晰

```javascript
async function f(){
  console.log(2);
  await console.log(3); //情况1：同步操作
  await Promise.resolve(3).then(val => console.log(val)); //情况2：异步操作
  console.log(4)
}

console.log(1);
f();
console.log(5);

//输出：1 2 3 5 4
//     1 2 5 3 4
```

## 2. Promise

Promise 是异步编程的一种解决方案，比传统的回调函数和事件更合理且强大，ES6 原生提供了 Promise 对象

### (1) Promise对象

#### 特点

① Promise 对象的状态不受外界影响。Promise 对象代表一个有三种状态的异步操作，进行中 (pending)，已成功 (fulfilled)，已失败 (rejected)，只有异步操作的结果可以决定 Promise 对象当前是哪个状态，任何其他操作都无法改变这个状态

② 一旦 Promise 对象的状态改变，就会一直保持当前状态，任何时候都可以得到这个结果。Promise 对象的状态改变，只可能是从进行中 (pending) 到已成功 (fulfilled)，或者从进行中 (pending) 到已失败 (rejected)，只要发生这两种情况之一，Promise 对象的状态就凝固了，此时称为已定型 (resolved)，状态改变后，再对 Promise 对象添加回调函数，也会立即得到这个结果，与事件完全不同，事件发生后，再去监听，是得不到结果的

#### 优点

① Promise 对象可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数

② Promise 对象提供统一的接口，使控制异步操作更加简单

#### 缺陷

① Promise 无法取消，一旦新建就会立即执行，无法中途取消

② 如果不设置回调函数，Promise 内部抛出的错误，不会反映到外部

**③** Promise 对象如果处于进行中 (pending) ，则无法得到目前进行到具体哪个程度，刚刚开始还是即将完成

**④** 如果某些事件不断反复发生，一般来说，使用 Stream 模式是比部署 Promise 更好的选择

#### 构造函数

ES6 规定，Promise 对象是一个构造函数，用来生成 Promise 实例

Promise 构造函数接受一个函数作为参数，该函数的两个参数分别是 resolve() 函数和 reject() 函数，由JS 引擎提供，无需自己部署

① 异步操作成功时调用 resolve() 函数，将 Promise 实例的状态由进行中 (pending) 变为已成功 (fulfilled)，并将异步操作的结果，作为参数传递到Promise 实例状态变为已成功 (ulfilled) 时的回调函数

② 异步操作失败时调用 reject() 函数，将 Promise 实例的状态由进行中 (pending) 变为已失败 (rejected)，并将异步操作抛出的错误，作为参数传递到 Promise 实例状态变为已失败 (rejected) 时的回调函数

```javascript
const p = new Promise((resolve, reject) => {
  if(...){
    resolve(val);
  } else{
    reject(err);
  }
});
```

#### 方法

```javascript
定义：const p = new Promise((resolve, reject) => {});
方法：p.then(callback)               //实例p状态变为已成功(fulfilled)时执行then方法的callback回调函数
     p.catch(callback)              //实例p状态变为已失败(rejected)时执行catch方法的callback回调函数
     p.finally(callback)            //实例p最后一定执行finally方法的callback回调函数,无论状态如何
     转化方法
     Promise.resolve(param)         //返回一个新Promise实例,状态由参数param决定
     Promise.reject(param)          //返回一个状态为已失败(rejected)的新Promise实例,参数作为实例的reject方法的参数
     合成方法
     Promise.all([p1,p2,p3])        //返回一个新Promise实例,所有Promise实例参数状态均为已成功(fulfilled),则为已成功
     Promise.any([p1,p2,p3])        //返回一个新Promise实例,所有Promise实例参数状态均为已失败(rejected),则为已失败
     Promise.race([p1,p2,p3])       //返回一个新Promise实例,状态和最先改变状态的Promise实例参数一致
     Promise.allSettled([p1,p2,p3]) //返回一个新Promise实例,状态始终是已成功(fulfilled),但是必须等待所有Promise实例参数状态改变
     包装方法
     Promsie.try(f)                 //无返回值,当同步函数在Promise实例的resolve函数中调用时,使同步函数f同步执行
```

### (2) then()

Promise.prototype.then() 方法定义在 Promise 对象的原型上，故而所有 Promise 实例都具有 then 方法

#### then方法作用

① then 方法的作用是为 Promise 实例添加状态改变时的回调函数

② then 方法可以接受 2 个函数作为参数，第一个参数函数是 Promise 实例状态变为已成功 (fulfilled) 时的回调函数，第二个参数函数是 Promise 实例状态变为已失败 (rejected) 时的回调函数，第二个参数函数不推荐使用，推荐使用后续的 catch 方法

```javascript
const p = new Promise((resolve, reject) => {});
promise.then(val => {}, err => {});
```

#### then方法参数函数执行时间

① Promise 实例`新建后立即执行`，

② then 方法的参数函数需等待当前脚本所有同步任务执行完后才会执行，即`本轮事件循环末尾执行`，

③ resolve 函数和 reject 函数的调用不会影响 Promise 实例的参数函数继续执行，但一般来说，调用 resolve 函数或 reject 函数后，Promise 实例的使命就完成了，后续操作都应该放到 then 方法中

```javascript
//最好在resolve函数和reject函数的调用语句前面加上return,防止后续语句继续执行,导致意外
const promise = new Promise((resolve, reject) => {
  resolve();
  console.log('promise');
});

promise.then(val => console.log('fulfilled'));

console.log('hi');

//输出：'promise'  'hi'  'fulfilled'
//promise实例新建后立即执行,then方法指定的fulfilled状态的回调函数需等待当前脚本所有同步任务执行完后才会执行
```

#### resolve/reject函数

① reject 函数的参数通常是 Error 对象的实例，

reject 函数将 Promise 实例状态变为已失败 (rejected) 后，将参数传递到 Promise 实例状态变为已失败 (rejected) 时的回调函数，即 then 方法第二个参数函数 (不推荐使用)，或 catch 方法参数函数

```javascript
//情况1
const p = new Promise((resolve, reject) => reject(new Error('error')));
p.then(val => console.log('1' + val), 
       err => console.log('2' + err)); 
//输出：2Error: error


//情况2
const p = new Promise((resolve, reject) => reject(new Error('error')));
p.then(val => console.log('1' + val))
 .catch(err => console.log('2' + err)) 
//输出：2Error: error
```

② resolve 函数的参数可以是正常值，

resolve 函数将 Promise 实例状态变为已成功 (fulfilled) 后，将参数传递到Promise 实例状态变为已成功 (fulfilled) 时的回调函数，即 then 方法第一个参数函数

```javascript
//Promise实现AJAX
const getData = (url) => {
  const promise = new Promise((resolve, reject) => {
    //handler不能写成箭头函数,否则this指向不正确
    const handler = function(){
      if(this.readyState !== 4){
        return;
      }
      if(this.status === 200){
        resolve(this.response);
      } else{
        reject(new Error(this.statusText));
      }
    };
    const client = new XMLHttpRequest();
    client.open('POST', url);
    client.onreadstatechange = handler;
    client.responseType = 'json';
    client.setRequestHeader('Accept', 'application/json');
    client.send();
  });
  return promise;
}

getData("/posts.json")
 .then(json => console.log('Contents: ' + json), 
       err => console.log('Error: ' + err))
```

③ resolve 函数的参数也可以是`另一个promise实例`，

p1 状态会传递给 p2，p1 的返回结果也会传给 p2 对应状态的回调函数

p1 状态为进行中 (pending)，p2 对应状态的回调函数需等待 p1 状态改变

p1 状态为已成功 (fulfilled) 或已失败 (rejected)，p2 对应状态的回调函数立即执行

```javascript
const p1 = new Promise((resolve, reject) => {
  resolve(1);
  //reject(new Error('error'));
});
const p2 = new Promise((resolve, reject) => resolve(p1));
p1.then(val => console.log('p1: ' + val))
  .catch(err => console.log('p1: ' + err))
p2.then(val => console.log('p2: ' + val))
  .catch(err => console.log('p2: ' + err))

//p1状态为fulfilled,输出：p1: 1      p2: 1
//p1状态为rejected, 输出：p1: Error  p2: Error
```

#### then方法返回值

then 方法返回一个`新Promise实例`，新 Promise 实例的状态与 then 方法第一个参数函数的返回值有关，

因此可以采用链式写法，即 then 方法后再继续调用 then 方法或 catch 方法，这样可以指定一组按次序调用的回调函数，前一个 then 方法的参数函数执行完后，会将返回结果作为参数传递到下一个 then 方法或 catch 方法的参数函数，若前一个 then 方法的参数函数返回一个 Promise 实例，那么后一个 then 方法或 catch 方法的参数函数就会`等待该Promise实例状态改变`时才会被调用

```javascript
//第一个then方法返回一个Promise实例,
//该promise实例状态变为fulfilled时,调用第二个then方法的参数函数
//该promise实例状态变为rejected时,调用第三个catch方法的参数函数
getData("/posts.json")
.then(json => return getData(json.url))
.then(val => console.log('fulfilled: ' + val))
.catch(err => console.log('rejected: ' + err))
```

① then 方法第一个参数函数返回值

then 方法第一个参数函数无 return 即是返回 `undefined`，

then 方法返回的新 Promise 实例的状态为`已成功(fulfilled)`，then 方法第一个参数函数返回值传递给新 Promise 实例的 then 方法的参数函数

```javascript
const p = new Promise((resolve, reject) => resolve(1));

//情况1：无返回值
p.then(val => {})
 .then(val => console.log('fulfilled: ' + val))
 .catch(err => console.log('rejected: ' + err))

//情况2：return val
p.then(val => val)
 .then(val => console.log('fulfilled: ' + val))
 .catch(err => console.log('rejected: ' + err))

//输出：fulfilled: undefined
//     fulfilled: 1
```

② then 方法第一个参数函数返回 Promise 实例

then 方法返回的新 Promise 实例的状态为 then 方法第一个参数函数`返回的Promise实例的状态`，返回值传递给新 Promise 实例的对应状态的回调函数

```javascript
const p1 = new Promise((resolve, reject) => resolve(1));          //情况1
const p1 = new Promise((resolve, reject) => reject(new Error())); //情况2

const p = new Promise((resolve, reject) => resolve('ok'));
p.then(val => p1)
 .then(val => console.log('fulfilled: ' + val))
 .catch(err => console.log('rejected: ' + err))

//输出：fulfilled: 1
//     rejected: Error
```

③ then 方法第一个参数函数抛出错误

then 方法返回的新 Promise 实例的状态为`已失败(rejected)`，then 方法第一个参数函数抛出的错误传递给新 Promise 实例的 catch 方法的参数函数

```javascript
const p = new Promise((resolve, reject) => resolve(1));
p.then(val => {throw Error()})
 .then(val => console.log('fulfilled: ' + val))
 .catch(err => console.log('rejected: ' + err))

//输出：rejected: Error
```

### (3) catch()

catch 方法是`then(undefined/null, rejection)`的别名

#### catch方法作用

① catch 方法捕获 Promise 实例异步操作抛出的错误 (Promise 实例状态为 rejected)，以及前面所有 then 方法参数函数运行时的错误，以及前面所有 catch 方法抛出的错误

```javascript
const p = new Promise((resolve, reject) => {});
p.then(val => console.log('resolved: ' + val))
 .catch(err => console.log('rejected' + err))

//等同于
//情况1：Promsie实例p状态为rejected,不会执行第一个then方法指定的参数函数,但是会执行第一个then方法,而第一个then方法返回一个
//      新Promise实例所以状态被传递给了第一个then方法返回的新Promise实例,新Promise实例状态也为rejected,就会执行第二个then
//      方法的第二个参数函数
//情况2：Promise实例p状态为fulfilled,执行第一个then方法指定的参数函数,若此时运行出错,那么第一个then方法返回的新Promise实例
//      状态就是rejected,就会执行第二个then方法指定的第二个参数函数
p.then(val => console.log('resolved: ' + val))
 .then(null, err => console.log('rejected: ' + err))
```

② Promise 实例的错误具有`冒泡`性质，会一直向后传递，直到被捕获为止，也就是说，错误总会被下一个 catch 方法的参数函数捕获

```javascript
const p = new Promise((resolve, reject) => {
  resolve(x + 1); //x未声明,该行会报错
});

p.catch(err => console.log('rejected1: ' + err)) 
 .then(val => y + 2) //y未声明,该行会报错
 .catch(err => console.log('rejected2: ' + err))

//输出：rejected1: ReferenceError: x is not defined
//     rejected2: ReferenceError: y is not defined
```

后续 then 方法运行出错，与前面的 catch 方法无关

```javascript
const p = new Promise((resolve, reject) => resolve(2));
p.catch(err => console.log('rejected: ' + err)) 
 .then(val => y + 2)

//输出：Uncaught (in promise) ReferenceError: y is not defined
```

③ Promise 和传统的 try-catch 代码块不同的是，即使没有使用 catch 方法指定错误处理的回调函数，Promise 实例抛出的错误也不会传递到外层代码，不会影响当前脚本继续执行，但是浏览器会打印出错误原因

```javascript
const p = new Promise((resolve, reject) => {
  resolve(x + 2); //x未声明,该行会报错
});
p.then(val => console.log('fulfilled: ' + val))
 .catch(err => console.log('rejected: ' + err))

setTimeout(() => console.log(111), 0)

//输出：Uncaught (in promise) ReferenceError: x is not defined
//     111
```

#### resolve/reject函数

① Promise 实例在调用 resolve 方法后再抛出错误，是不会被捕获的，因为 Promise 实例状态已定型

Promise 实例状态一旦改变，状态就会凝固，即一直保持当前状态，此时称为`已定型(resolved)`，

```javascript
const p = new Promise((resolve, reject) => {
  resolve('ok');
  throw new Error(); //不起作用
});

p.then(val => console.log('resolved: ' + val))
 .catch(err => console.log('rejected: ' + err)) 

//输出：resolved: ok
```

② Promise 实例可以在调用 resolve 方法后指定在`下一轮事件循环`再抛出错误，到了那个时候，Promise 实例已经运行结束，所以这个错误是在 Promise 实例函数体外抛出的，`会冒泡到最外层`，成为未捕获的错误

```javascript
const p = new Promise((resolve, reject) => {
  resolve('ok');
  setTimeout(() => {throw new Error()}, 0); //下轮事件循环开始时执行
});

//本轮事件循环所有同步任务结束后执行
p.then(val => console.log('fulfilled: ' + val))
 .catch(err => console.log('rejected: ' + err)) 

//输出：fulfilled: ok
//     Uncaught Error
```

#### catch方法返回值

catch 方法返回一个`新Promise实例`，catch 方法是 then(undefined/null, rejection) 的别名，所以 catch 方法返回的新 Promise 实例的状态同 then 方法的三种情况一样，是由 `catch方法的参数函数的返回值`决定的

① catch 方法第一个参数函数返回值

catch 方法参数函数无 return 即是返回 `undefined`，

catch 方法返回的新 Promise 实例的状态为`已成功(fulfilled)`，catch 方法参数函数返回值传递给新 Promise 实例的 then 方法的参数函数

```javascript
const p = new Promise((resolve, reject) => reject(new Error()));

//情况1：无返回值
p.catch(err => {})
 .then(val => console.log('fulfilled: ' + val))
 .catch(err => console.log('rejected: ' + err))

//情况2：return val
p.catch(err => err)
 .then(val => console.log('fulfilled: ' + val))
 .catch(err => console.log('rejected: ' + err))

//输出：fulfilled: undefined
//     fulfilled: Error
```

② catch 方法第一个参数函数返回 Promise 实例

catch 方法返回的新 Promise 实例的状态为 catch 方法参数函数`返回的Promise实例的状态`，返回值传递给新 Promise 实例的对应状态的回调函数

```javascript
const p1 = new Promise((resolve, reject) => resolve(1));           //情况1
const p1 = new Promise((resolve, reject) => reject(new Error(2))); //情况2

const p = new Promise((resolve, reject) => rejected(new Error()));
p.catch(err => p1)
 .then(val => console.log('fulfilled: ' + val))
 .catch(err => console.log('rejected: ' + err))

//输出：fulfilled: 1
//     rejected: Error: 2
```

③ catch 方法第一个参数函数抛出错误

catch 方法返回的新 Promise 实例的状态为`已失败(rejected)`，catch 方法参数函数抛出的错误传递给新 Promise 实例的 catch 方法的参数函数

```javascript
const p = new Promise((resolve, reject) => reject(new Error()));
p.catch(err => {throw new Error(2)})
 .then(val => console.log('fulfilled: ' + val))
 .catch(err => console.log('rejected: ' + err))

//输出：rejected: Error: 2
```

### (4) finally()

① finally 方法用于指定无论 Promise 实例最后状态如何，都会执行的操作，

② finally 方法指定的参数函数`不接受任何参数`，这意味着无法得知 Promise 实例的状态到底是已成功 (fulfilled) 还是已失败 (rejected)，表明 finally 方法参数函数中的操作与 Promise 实例的状态无关，不依赖 Promise 实例的执行结果

```javascript
//情况1
const p = new Promise((resolve, reject) => resolve(1));
p.then(val => console.log('fulfilled: ' + val))
 .catch(err => console.log('rejected: ' + err))
 .finally(() => console.log('finally'));
//输出：fulfilled: 1
//     finally

//情况2
const p = new Promise((resolve, reject) => reject(new Error()));
p.then(val => console.log('fulfilled: ' + val))
 .catch(err => console.log('rejected: ' + err))
 .finally(() => console.log('finally'));
//输出：rejected: Error
//     finally
```

#### ③ finally 方法的实现

finally 方法返回一个新 Promise 实例，

无论 Promise 实例的状态是已成功 (fulfilled)还是已失败 (rejected)，都会执行 finally 方法的回调函数 callback，

finally 方法总是返回原来的值

```javascript
Promise.prototype.finally = function(callback){
  return this.then(
    val => Promise.resolve(callback()).then(() => val),
    err => Promise.resolve(callback()).then(() => {throw err})
  );
};

const p = new Promise((resolve, reject) => resolve('ok'));
p.finally(() => console.log(1));
```

### (5) done()

① 无论 Promise 实例的回调链是以 then 方法还是 catch 方法或者 finally 方法结尾，最后一个方法抛出的错误都无法被捕捉到，因为 Promise 内部的错误`不会冒泡到全局`，

② done 方法总是处于回调链的尾端，保证捕捉到任何可能出现的错误，并`向全局抛出`，

```javascript
//情况1
const p = new Promise((resolve, reject) => {throw new Error()});
p.done(); 

//情况2
const p = new Promise((resolve, reject) => resolve(1));
p.then(val => {throw new Error()})
 .done(); 

//情况3
const p = new Promise((resolve, reject) => {throw new Error()});
p.catch(err => {throw new Error()})
 .done(); 

//情况4
const p = new Promise((resolve, reject) => resolve(1));
p.finally(() => {throw new Error()})
 .done(); 

setTimeout(() => console.log(1), 0);

//输出：1
//     Uncaught Error
```

#### ③ done 方法的实现

```javascript
Promise.prototype.done = function(resolve, reject){
  this.then(resolve, reject)
      .catch(err => setTimeout(() => {throw err}, 0)
}
```

### (6) 转化方法

将现有对象转化为 Promise 实例

#### ① Promise.resolve

* 不带任何参数

  返回一个状态为已成功 (fulfilled) 的新 Promise 实例，

* 参数是一个 thenable 对象

  thenable 对象指的是具有 then 方法的对象，自动调用 Promise.resolve() 方法将这个对象转化为 Promise 实例，然后立即执行这个对象的 then 方法

* 参数是原始值，或者不是具有 then 方法的对象

  返回一个状态为已成功 (fulfilled) 的新 Promise 实例，参数直接传递给 then 方法的回调函数

* 参数是一个 Promise 实例

  不做任何修改，原封不动的返回这个 Promise 实例

```javascript
//情况2
const thenable = {
  then: function(resolve, reject){
    resolve(2);
    reject(2);
  }
}

//情况3
const val = '3';

//情况4
const p = new Promise((resolve, reject) => {
  resolve(4);
  reject(new Error(4));
});

const p1 = Promise.resolve(p);
p1.then(val => console.log('fulfilled: ' + val))
  .catch(err => console.log('rejected: ' + err))

//输出：fulfilled: 2   rejected: 2
//     fulfilled: 3
//     fulfilled: 4   rejected: Error: 4
```

Promise.resolve() 方法在`本轮事件循环结束时执行`，而非下轮事件循环开始时执行

```javascript
//下轮事件循环开始时执行
setTimeout(() => console.log(1), 0);

//本轮事件循环结束时执行
Promise.resolve(2).then(val => console.log(val));

console.log(3);

//输出：3 2 1
```

#### ② Promise.reject

返回一个状态为已失败 (rejected) 的新 Promise 实例，参数作为返回的 Promise 实例的 reject 方法的参数

```javascript
//情况2
const thenable = {
  then: function(resolve, reject){
    resolve(2);
    reject(2);
  }
}

//情况3
const val = '3';

//情况4
const p = new Promise((resolve, reject) => {
  resolve(4);
  reject(new Error(4));
});

const p1 = Promise.reject(p);
p1.then(val => console.log('fulfilled: ' + val))
  .catch(err => console.log('rejected: ' + err))

//输出：rejected: [object Object]   rejected: [object Object]
//     fulfilled: 3
//     rejected: [object Promise]  rejected: [object Promise]
```

Promise.reject() 方法在`本轮事件循环结束时执行`，而非下轮事件循环开始时执行

```javascript
//下轮事件循环开始时执行
setTimeout(() => console.log(1), 0);

//本轮事件循环结束时执行
Promise.reject(2).then(err => console.log(err));

console.log(3);

//输出：3 2 1
```

### (7) 合成方法

将多个 Promise 实例，包装合成为一个 Promise 实例

合成方法都是接受一个具有`Iterator接口`的数据作为参数，并且该数据返回的每个成员都是 `Promise实例`，如果不是 Promise 实例，则先调用 Promise.resolve() 方法将成员转换为 Promise  实例再进行处理

#### ① Promise.all

* 所有 Promise 实例参数的状态都变为已成功 (fulfilled)，新 Promise 实例状态才会变为已成功 (fulfilled)，并且所有Promise 实例参数的返回值组成一个数组，传递给新 Promise 实例的 then 方法的参数函数

* 只要某个 Promise 实例参数的状态变为已失败 (rejected)，新 Promise 实例状态就会变为已失败 (rejected)，并且`第一个`状态变为已失败 (rejected)的 Promise 实例参数的返回值，传递给新 Promise 实例的 catch 方法的参数函数

```javascript
const p1 = Promise.resolve(1);

//情况1
const p2 = Promise.resolve(2);
const p3 = Promise.resolve(3);

//情况2
const p2 = Promise.reject(new Error(2));
const p3 = Promise.reject(new Error(3));

const p = Promise.all([p1, p2, p3]);
p.then(val => console.log(val))
 .catch(err => console.log(err))

//输出：Array [1, 2, 3]
//     Error: 2
```

Promise 实例参数，自己定义了 catch 方法，那么当该实例参数的状态变为已失败 (rejected)时，不会触发 Promise.all() 的 catch 方法

```javascript
const p1 = Promise.resolve(1);
const p2 = Promise.resolve(2);

//情况1：先创建p3,p3状态为已失败(rejected)
const p3 = Promise.reject(new Error());
p3.then(val => console.log('p3: ' + val))
  .catch(err => console.log('p3: ' + err))

//情况2：p3是catch返回的新Promise实例,p3状态为已成功(fulfilled)
const p3 = Promise.reject(new Error())
.then(val => console.log('p3: ' + val))
.catch(err => console.log('p3: ' + err))

const p = Promise.all([p1, p2, p3]);
p.then(val => console.log(val))
 .catch(err => console.log(err))

//输出：p3: Error
//     Error
//输出：p3: Error
//     Array [1, 2, undefined]
```

#### ② Promise.any

* 所有 Promise 实例参数的状态都变为已失败 (rejected)，新 Promise 实例状态才会变为已失败 (rejected)

* 只要某个 Promise 实例参数的状态变为已成功 (fulfilled)，新 Promise 实例状态就会变为已成功 (fulfilled)

```javascript
//该方法暂无浏览器实现
```

#### ③ Promise.race

新 Promise 实例的状态`同最先改变状态的Promise实例参数一致`，并且率先改变状态的 Promise 实例参数的返回值，会传递给新 Promise 实例的对应状态的回调函数

```javascript
const p1 = Promise.resolve(1);         //情况1
const p1 = Promise.eject(new Error()); //情况2
const p2 = Promise.resolve(2);
const p4 = Promise.resolve(3);

const p = Promise.race([p1, p2, p3]);
p.then(val => console.log(val))
 .catch(err => console.log(err));

//输出：1
//     Error
```

指定时间内未返回结果，就将新 Promise 实例状态变为已失败 (rejected)

```javascript
const p = Promise.race([
  getData('url'),
  new Promise((resolve, reject) => setTimeout(reject(new Error('request error')), 3000))
]);
p.then(val => val)
 .catch(err => console.log(err));
```

#### ④ Promise.allSettled

新 Promise 实例的状态总是`已成功(fulfilled)`，但是必须等到`所有Promise实例参数都改变状态`，包装实例才结束，`所有Promise实例参数构成的数组`，作为参数传递到新 Promise 实例的 then 方法的参数函数

```javascript
const p1 = Promise.resolve(1);
const p2 = Promise.resolve(2);
const p3 = Promise.reject(new Error());

const p = Promise.allSettled([p1, p2, p3]);
p.then(val => console.log(val))
 .catch(err => console.log(err));

//输出：Array [{status: 'fulfilled', value: 1}, {status: 'fulfilled', value: 2}, {status: 'rejected', reason: Error}]
```

有时候，我们不关心异步操作的结果，只关心异步操作是否结束，此时 Promise.allSettled() 就很有用，可以确保所有异步操作都结束

```javascript
const urls = [ /_ ... _/ ];
const requests = urls.map(x => fetch(x));
const results = await Promise.allSettled(requests);

//过滤出成功的请求
const successfulPromises = results.filter(p => p.status === 'fulfilled');

//过滤出失败的请求,并输出原因
const errorPromises = results.filter(p => p.status === 'rejected')
const errorReasons = errorPromises.map(p => p.reason);

try{
  await Promise.allSettled(requests)
  console.log('所有请求都成功。');
} catch{
  console.log('至少一个请求失败，其他请求可能还未结束。');
}

```

### (9) Promise.try

① 实际开发中经常遇到这样一种情况，不想区分函数 f 是同步函数还异步函数，都想用 Promise 处理。这样就可以始终用 then 方法指定下一步流程，用 catch 方法处理函数 f 抛出的错误，但是`用Promise包装后的同步函数会异步执行，在本轮事件循环的末尾执行`，

```javascript
const f = () => console.log(1);
Promise.resolve().then(f);

console.log(2);

//输出：2 1
```

② Promise.try() 为所有同步和异步操作提供了统一的处理机制，并且让它们具有统一的 API，无论函数是同步还是异步，都用 then 方法指定下一步流程，用 catch 方法处理抛出的错误，

同步函数用 Promise.try() 包装后会变成异步执行，想要让`同步函数用Promise.try()包装后仍然是同步执行`，有 2 种实现方式

```javascript
const f = () => console.log(1);
Promise.try(f);

console.log(2);

//输出：2 1
```

实现方式一：使用 new Promise

```javascript
const f = () => console.log(1);
(() => Promise.resolve(f()))()

console.log(2);

//输出：1 2
```

实现方式二：使用 async 函数，但是这样需要使用 catch 方法捕获错误

```javascript
const f = () => console.log(1);

(async () => f())()
.then(val => val)
.catch(err => console.log(err));

console.log(2);

//输出：1 2
```

## 3. Generator

### (1) yield 命令

#### ① 惰性求值

yield 表达式是暂停标志，yield 关键字后面的表达式，`只有当调用next方法，内部指针指向该语句时才会执行`，其他情况下不会执行，相当于为 ES 提供了手动的惰性求值，

```javascript
function* f(){
  yield 123 + 456;
}
const ite = f(); //此处不执行

console.log(ite.next()); //{value: 579, done: false}
console.log(ite.next()); //{value: undefined, done: true}
```

暂缓执行函数：Generator 函数如果不使用 yield 表达式，就变成了一个单纯的暂缓执行函数，只有调用 next 方法时才会执行

```javascript
function* f(){
  return '执行';
}
const ite = f(); //此处不执行

setTimeout(() => console.log(ite.next()), 3000); //3秒后输出 {value: '执行', done: true}
```

#### ② 返回值 

yield 命令后跟一个`表达式`，yield 表达式本身没有返回值，或者说总是返回 `undefined`，但是可以`通过next方法返回表达式的值`，

```javascript
function* f(){
  yield 1;
  console.log(yield 2); 
}
for(let item of f()){
  console.log(item); //1  2  undefined
}
```

#### ③ 位置记忆功能

yield 表达式与 return 语句都能通过 next 方法返回紧跟在语句后面的表达式的值，

* yield 语句具备位置记忆功能，每次调用 next 方法，都从`函数开头或者上次暂停的地方`继续执行，一个函数可以执行多个 yield 表达式，因此 Generator 函数可以返回一系列值

* return 语句不具备位置记忆功能，一个函数只能执行一个 return 语句，因此正常函数只能返回一个值

```javascript
function* f(){
  yield 1;
  console.log(yield 2);
  yield 3; 
}
const ite = f();

console.log('第一次调用next');
console.log(ite.next()); 
console.log('第二次调用next');
console.log(ite.next()); 
console.log('第三次调用next');
console.log(ite.next()); 

//输出：第一次调用next
//     {value: 1, done: false}
//     第二次调用next
//     {value: 2, done: false}
//     第三次调用next
//     undefined  
//     {value: 3, done: true}
```

#### ⑤ *yield 表达式在另一个表达式中使用，必须放在圆括号中，

yield 表达式用作函数参数或者放在赋值表达式右边，可以不放在圆括号中

```javascript
function* f(){
  return 'hello ' + (yield '张三');
}
const ite = f();

console.log(ite.next()); //{value: "张三", done: false}
console.log(ite.next()); //{value: 'hello undefined', done: true}
                         //第二次调用next时执行的是return,yield是惰性求值,只有第一次调用next时才求值,其他情况下返回undefined
```

### (2) yield* 表达式

#### ① 用途

yield* 表达式用来在一个 Gennerator 函数内部调用另一个 Generator 函数，yield* 命令`不遍历return语句`，

```javascript
function* f1(){
  yield 1;
  return 2;
}
function* f2(){
  yield 3;
  f1();        //情况1,直接调用Generator函数不起作用
  yield f1();  //情况2
  yield* f1(); //情况3
  yield 4;
}
for(let item of f2()){
  console.log(item); 
}

//输出：3      4
//     3  f1  4
//     3  1   4
```

任何数据结构，只要有 Iterator 接口，就可以被 yield* 命令遍历

```javascript
function* f(){
  yield* 'hello';
  yield* [1, 2, 3];
}
for(let item of f()){
  console.log(item); //'h' 'e' 'l' 'l' 'o' 1 2 3
}
```

```javascript
//yield*命令可以方便地取出嵌套数组的所有成员
function* iterTree(tree){
  if(Array.isArray(tree)){
    for(let i=0; i<tree.length; i++){
      yield* tree[i];
    }
  } else{
    yield tree;
  }
}
const tree = [1, 2, [3, 4, [6, 7]]];
for(let item of iterTree(tree)){
  console.log(item); //1 2 3 4 6 7
}
```

#### ② 返回值

yield* 命令的返回值由`被代理的Generator函数的return语句`决定，

```javascript
function* f1(){
  yield 1;
  return 'f1 end'; //return语句决定yield*表达式返回值
}
function* f2(){
  yield 3;
  console.log(yield* f1()); 
  yield 4;
}
for(let item of f2()){
  console.log(item); 
}
//输出：3  1  'f1 end'   4
```

### (3) next()

#### ① 返回值

调用 Generator 函数后，该函数并不执行，返回的也不是函数运行结果，而是一个`指向函数内部状态的遍历器对象`，每次调用遍历器对象的 next 方法，返回一个有着 value 属性和 done 属性的对象，value 属性是当前内部状态的值，done 属性是遍历是否结束的布尔值，Generator 函数若没有 return 语句，调用 next 方法返回的对象 value 属性值为 `undefined`，指针从`函数头部或上一次暂停的地方`开始执行，`直到遇到下一个yield表达式或return语句为止`，换而言之，Generator 函数是分段执行的，yield 表达式是暂停执行的标记，而 next 方法可以恢复执行

```javascript
//该函数有三个内部状态：'hello' 'world' 'ending'
function* f(){
  yield 'hello';
  yield 'world';
  return 'ending';
}
const ite = f();

console.log(ite.next()); //{value: 'hello', done: false}
console.log(ite.next()); //{value: 'world', done: false}
console.log(ite.next()); //{value: 'ending', done: true}
```

#### ② 参数

yield 表达式本身没有返回值，或者说总是返回 `undefined`，next 方法可以带一个参数，该参数会被当做`上一个yield表达式的返回值`，

```javascript
function* f(){
  for(let i = 0; true; i++){
    let reset = yield i;
    if(reset){
      i = -1;
    }
  }
}
const ite = f();

console.log(ite.next());     //{value: 0, done: false}
console.log(ite.next());     //{value: 1, done: false},next方法无参数时,reset总是等于undefined
console.log(ite.next(true)); //{value: 0, done: false},next方法参数作为上一个yield表达式的值,此时reset=true
```

Generator 函数从暂停状态到恢复执行，其执行上下文不变，但是通过 next 方法的参数，可以在 Generator 函数运行后继续向函数体内部注入值，也就是说，可以在 Generator 函数运行的不同阶段，从外部向函数内部注入不同的值，从而调整函数的行为

```javascript
function* f(x){
  const y = 2 * (yield (x + 1));
  const z = yield (y / 3);
  return x + y + z;
}
const ite = f(5);

//情况1
console.log(ite.next()); //{value: 6, done: false}
console.log(ite.next()); //{value: NaN, done: false}
console.log(ite.next()); //{value: NaN, done: true}

//情况2
console.log(ite.next());  //{value: 6, done: false}
console.log(ite.next(6)); //{value: 4, done: false}
console.log(ite.next(4)); //{value: 21, done: true}
```

如果想在第一次调用 next 方法时就能够输入值，可以在 Generator 函数外面`再包一层`，

```javascript
function wrapper(f){
  return function(...args){
    const result = f(...args);
    result.next(); //先执行一次next
    return result;
  }
}
const wrapped = wrapper(function* (...args){
  console.log(${args}. ${yield}); //已执行过一次next,'hello'为此处yield表达式返回值
  return 'done';
});
const ite = wrapped(1);
ite.next('hello'); //'1. hello'
```

#### ③ for-of循环

for-of 循环可以自动遍历 Generator 函数生成的遍历器对象，一旦 next 方法返回对象的 done 属性为 true，for-of 循环就会终止，且不包含该返回对象，因此 `return语句不在for-of循环中`，

```javascript
function* f(){
  yield 'hello';
  yield 'world';
  return 'ending';
}

//情况1
const ite = f();
console.log(ite.next()); //{value: 'hello', done: false}
console.log(ite.next()); //{value: 'world', done: false}
console.log(ite.next()); //{value: 'ending', done: true}

//情况2：for-of循环不包含return语句
for(let item of f()){
  console.log(item); //'hello'  'world'
}
```

除了 for-of 循环，扩展运算符、解构赋值、Array.form() 方法内部调用的都是遍历器接口

```javascript
function* f(){
  yield 1;
  yield 2;
  return 3;
  yield 4;
}

//情况1
[...f()]; //Array [1, 2]

//情况2
let [x, y] = f(); //x=1,y=2

//情况3
Array.from(f()); //Array [1, 2]

//情况4
for(let item of f()){
  console.log(item); //1 2
}
```

```javascript
//利用Generator函数和for-of循环,实现斐波那契数列
function* fibonacci() {
  let [prev, curr] = [0, 1];
  for(;;){
    [perv, curr] = [curr, perv + curr];
    yield curr;
  }
}
for(let i of fibonacci()){
  if(i > 100){
    break;
  }
  console.log(i); //1 2 3 5 8 13 21 34 55 89
}
```

### (4) throw()

#### ① 参数

throw 方法可以接受一个参数，该参数会被 catch 语句接收，建议抛出 Error 对象的实例

#### ② 执行

Generator 函数返回的遍历器对象，都有一个 throw 方法，throw 方法可以在函数体外抛出错误，

* 若 Generator 函数体内部署 try-catch 代码块，那么 throw 方法抛出的错误将被函数体内的 catch 语句捕获

* 若 Generator 函数体内未曾部署 try-catch 代码块，然后 throw 方法抛出的错误只能被函数体外的  catch 语句捕获

* 若 Generator 函数体外也未曾部署 try-catch 代码块，那么程序将报错，直接中断执行

```javascript
//情况1
function* f(){
  try{
    yield;
  } catch(e){
    console.log('内部捕获：' + e);
  }
}
const ite = f();
ite.next(); //执行函数f内部的yield表达式,并且暂停在此处

try{
  ite.throw('a'); //被函数体内的catch语句捕获,此时函数体内的try-catch代码块已执行完毕
  ite.throw('b'); //此时函数体内的try-catch代码块已经执行完毕,只能被函数体外的catch语句捕获
} catch(e){
  console.log('外部捕获：' + e);
}

//输出：内部捕获：a
//     外部捕获：b
```

```javascript
//情况2
function* f(){
  yield;
  console.log('内部');
}
const ite = f();
ite.next(); //执行函数f内部的yield表达式,并且暂停在此处

try{
  ite.throw('a'); //函数体内未部署try-catch代码块,被函数体外的catch语句捕获,此时函数体外的try-catch代码块已执行完毕
  ite.throw('b'); //此时函数体外的try-catch代码块已经执行完毕,不会再次捕获throw方法抛出的错误
} catch(e){
  console.log('外部捕获：' + e);
}

//输出：外部捕获：a
```

```javascript
//情况3
function* f(){
  yield;
  console.log('内部');
}
const ite = f();
ite.next();
ite.throw();

//输出：Uncaught undefined
```

只要 Generator 函数体内部署 try-catch 代码块，throw 方法抛出的错误，`不会影响下次遍历`，否则遍历直接终止，即使函数体外部署了 try-catch 代码块

throw 方法被捕获以后，会附带执行下一条 yield 语句，也就是说，`会附带执行一次next方法`，

```javascript
function* f(){
  try{
    yield console.log(1);
  } catch(e){
    console.log('内部捕获：' + e);
  }
  yield console.log(2);
  yield console.log(3);
}
const ite = f();

ite.next();  //1
ite.throw(); //'内部捕获：undefined'   2
ite.next();  //3
```

一旦 Generator 函数执行过程中抛出错误，且没有被内部捕获，就不会再继续执行，如果此后还调用 next 方法，将返回一个 value 属性等于 undefined，done 属性等于 true 的对象，即 JS 引擎认为这个 Generator 函数已经执行完毕

```javascript
function* f(){
  yield console.log(1);
  throw new Error('出错');
  yield console.log(2);
  yield console.log(3);
}
function log(ite){
  let v;
  console.log('start');
  try{
    v = ite.next();
    console.log('第一次运行next方法', v);
  } catch(e){
    console.log('捕获错误：' + e);
  }
  try{
    v = ite.next();
    console.log('第二次运行next方法', v);
  } catch(e){
    console.log('捕获错误：' + e);
  }
  try{
    v = ite.next();
    console.log('第三次运行next方法', v);
  } catch(e){
    console.log('捕获错误：' + e);
  }
  console.log('end');
}
const ite = f();
log(ite);

//输出： start
//      1
//      第一次运行next方法  {value: undefined, done: false}
//      捕获错误：Error：出错
//      第三个运行next方法  {value: undefined, done: true}
//      end
```

#### ③ 全局 throw 命令

全局 throw 命令与 Generator 函数的 throw 方法无关，两者互不影响

全局 throw 命令抛出的错误只能被函数体外的 catch 语句捕获

```javascript
function* f(){
  try{
    yield;
  } catch(e){
    console.log('内部捕获：' + e);
  }
}
const ite = f();
ite.next(); //执行函数f内部的yield表达式,并且暂停在此处

try{
  throw new Error('a'); //全局throw命令抛出的错误只能被函数体外的catch语句捕获,此时函数体外的try-catch代码块已经执行完毕
  throw new Error('b'); //函数体外的try-catch代码块已经执行完毕,不会再次捕获全局throw命令抛出的错误
} catch(e){
  console.log('外部捕获：' + e);
}

//输出：外部捕获：Error: a
```

### (5) return()

#### ① 参数

Generator 函数的 return 方法可以`返回参数`，并且终结遍历 Generator 函数

```javascript
function* f(){
  yield 1;
  yield 2;
  yield 3;
}
const ite = f();

console.log(ite.next());        //{value: 1, done: false}
console.log(ite.return('end')); //{value: 'end', done: true}
```

#### ② 执行

若 Generator 函数体内部署 try-finally 代码块，那么`调用return方法时，就开始执行finally代码块`，finally 代码块执行完毕后，再执行 return 方法

```javascript
function* f(){
  yield 1;
  try{
    yield 2;
    yield 3;
  } finally{
    yield 4;
    yield 5;
  }
  yield 6;
}
const ite = f();

console.log(ite.next());        //{value: 1, done: false}
console.log(ite.next());        //{value: 2, done: false},执行finally代码块
console.log(ite.return('end')); //{value: 4, done: false}
console.log(ite.next());        //{value: 5, done: false}
console.log(ite.next());        //{value: 'end', done: true},执行return方法
console.log(ite.next());        //{value: undefined, done: true}
```

### (6) 与Iterator接口关系

任意对象的 Symbol.iterator 属性，等于该对象的遍历器生成函数，由于 Generator 函数就是遍历器生成函数，因此可以将 Generator 函数赋值给对象的 Symbol.iterator 属性，从而使该对象具有 Iterator 接口

```javascript
const obj = {
  name: '张三',
  friends: ['王五', '赵六'],
};
function* f(){
  const props = Reflect.ownKeys(this);
  for(let prop of props){
    yield [prop, obj[prop]];
  }
}
obj[Symbol.iterator] = f;

for(let [key, value] of obj){
  console.log(`${key}: ${value}`); 
}

//输出：name:    '张三'  
//     friends: '王五,赵六'
```

Generator 函数调用后返回的遍历器对象，本身也具有 Symbol.iterator 属性，执行后返回自身，

```javascript
function* f(){}
const ite = f();
console.log(iteSymbol.iterator === ite); //true
```

### (7) Generator函数的this

① Generator 函数返回遍历器，ES6 规定这个遍历器是 Generator 函数的实例，继承了 Generator 函数原型的方法

```javascript
function* f(){}
f.prototype.sayHi = function(){
  console.log('hi');
}
const ite = f();

console.log(ite instanceof f); //true
ite.sayHi(); //'hi'
```

② Generator 函数不是普通的构造函数

Generator 函数返回的是遍历器对象，而非 this 对象

Generator 函数不能和 new 命令一起用，否则会报错

```javascript
function* f(){
  this.a = 1
}
const ite = f();

console.log(ite.a); //undefined
new f(); //TypeError: f is not a constructor
```

③ Generator 函数转换成构造函数

```javascript
function* f(){
  this.a = 1;
  yield this.b = 2;
  yield this.c = 3;
}
function F(){
  return f.call(f.prototype);
}
const ite = new F();

//执行三个next方法,完成内部属性的绑定,此时ite成为F的实例
console.log(ite.next()); //{value: 2, done: false}
console.log(ite.next()); //{value: 3, done: false}
console.log(ite.next()); //{value: undefined, done: true}

console.log(ite.a); //1
console.log(ite.b); //2
console.log(ite.c); //3
```

### (8) Generator函数执行上下文

#### ① 普通函数的执行上下文

JS 引擎执行某个普通函数时，创建该函数的执行上下文，并且压入执行上下文栈，该函数执行完成后，上下文从执行上下文栈中弹出，并且`销毁`该执行上下文

#### ② Generator 函数的执行上下文

JS 引擎执行某个 Generator 函数时，创建该 Generator 函数的执行上下文，并且压入执行上下文栈，一旦遇到 yield 命令，上下文就从执行上下文栈中弹出，但是并不销毁而是暂时`冻结`在当前状态，等到对该 Generator 函数的遍历器对象执行 next 命令时，该上下文重新压入执行上下文栈，冻结的变量和对象恢复执行

```javascript
function* f(){
  yield 1;
  yield 2;
}
const ite = f();
console.log(ite.next()); //第一次执行next,f上下文压入上下文栈,开始执行f内部代码,yield 1执行完毕后,f上下文退出上下文栈,内部状态冻结
console.log(ite.next()); //第二次执行next,f上下文重新压入上下文栈,内部状态解冻,恢复执行
```

### (9) 自动流程管理

Generator 函数不能实现自动执行，只有调用 next 方法才会执行，普通的循环执行不适合异步操作，因为不能保证上一步执行完才执行下一步，

```javascript
function* f(){
  console.log(2);
  yield Promise.resolve(3).then(val => console.log(val)); //异步操作(Promise的then在本轮事件循环末尾)
  console.log(4);
}

const ite = f();
var res = ite.next();
while(!res.done){
  console.log(res.value);
  res = ite.next();
}

//输出：2  4  3
```

自动执行机制：异步操作有了结果，能够自动交回执行权

基于 Promise 对象的 Generator 函数自动执行器：then 方法中交回执行权

```javascript
function runG(f){
  const ite = f();
  const next = function(data){
    let res = ite.next(data);
    if(res.done){
      return;
    }
    res.value.then(function(data){
      next(data);
    });
  }
  next();
}

runG(f); //2 3 4
```

## 4. Async

Async 函数是 Generator 函数的语法糖，使得异步操作变得更加方便，

### (1) await 命令

await 命令表示需要`等待`其后的表达式执行完成，await 命令后跟表达式有如下三种类型

#### ① 原始类型值

await 命令直接返回原始类型值，return 语句将其传递到 Async 函数返回的 Promise 实例的 then 方法的参数函数

```javascript
async function f(){
  return await 1;
}
f().then(val => console.log(val))

//输出：1
```

#### ② Promise 实例

等待 await 命令后的 Promise 实例状态改变

状态变为已成功 (fulfilled)，await 命令返回 resolve 函数的参数，return 语句将其传递到 Async 函数返回的 Promise 实例的 then 方法的参数函数

状态变为已失败 (rejected)，await 命令返回 reject 函数的参数，return 语句将其传递到  Async 函数返回的 Promise 实例的 catch 方法的参数函数

```javascript
async function f(){
  return await new Promise((resolve, reject) => {
    resolve(1); //情况1
    reject(2);  //情况2
  });
}
f().then(val => console.log(val))
   .catch(err => console.log(err));

//输出：1
//     2
```

#### ③ thenable 对象

自动调用 Promise.resolve() 方法将 thenable 对象转化为 Promise 实例，然后立即执行该 Promise 实例的 then 方法

等待该 Promise 实例的 then 方法返回的 Promise 实例的状态改变

状态变为已成功 (fulfilled)，await 命令返回 resolve 函数的参数，传递到 Async 函数返回的 Promise 实例的 then 方法的参数函数

状态变为已失败 (rejected)，await 命令返回 reject 函数的参数，传递到  Async 函数返回的 Promise 实例的 catch 方法的参数函数

```javascript
const thenable = {
  then: function(resolve, reject){
    resolve(1); //情况1
    reject(2);  //情况2
  }
}
async function f(){
  return await thenable;
}
f().then(val => console.log(val))
   .catch(err => console.log(err));

//输出：1
//     2
```

### (2) Async函数的执行

Async 函数返回一个 `Promise 实例`，return 语句返回值将被传递到 Promise 实例对应状态的回调函数，没有 return 语句即返回值为 `undefined`，

① Async 函数内部抛出错误，Async 函数返回的 Promise 实例的状态变为已失败 (rejected)，`无需return语句`，错误对象直接被传递到 Promise 实例的 catch 方法的参数函数

```javascript
async function f(){
  throw new Error('error');
}
f().then(val => console.log(val))
   .catch(err => console.log(err));

//输出：Error: error
```

② 所有 await 命令后跟 Promise 实例状态都变为已成功 (fulfilled)，Async 函数返回的 Promise 实例状态变为已成功 (fulfilled)

任意一个  Promise 实例状态变为已失败 (rejected) ，Async 函数返回的 Promise 实例状态变为已失败 (rejected)，A函数`中断执行`，`无需return语句`，错误对象直接被传递到 Promise 实例的 catch 方法的参数函数，

```javascript
const p1 = Promise.resolve(1);          //情况1
const p1 = Promise.reject(new Error()); //情况2
const p2 = Promise.resolve(2);
const p3 = Promise.resolve(3);

async function f(){
  await p1;
  await p2;
  await p3;
  console.log('complete');
}

f().then(val => console.log(val))
   .catch(err => console.log(err));

//输出：'complete'  undefined
//     Error
```

③ 前一个 await 命令后的 Promise 实例状态变为已失败 (rejected)，仍要执行后面的 await 命令

第一种方式是将前面的 await 命令放在 try-catch 代码块中

第二种方式是前面的 await 命令后跟 Promise 实例加上 catch 方法，用于捕获错误

```javascript
const p1 = Promise.reject(new Error(1)).catch(err => console.log(err)); 
const p2 = Promise.resolve(2).then(val => console.log(val));
const p3 = Promise.resolve(3).then(val => console.log(val));

async function f(){
  await p1;
  await p2;
  await p3;
  console.log('complete');
} 
f().then(val => console.log(val))
   .catch(err => console.log(err));

//输出：'Error: 1'  2  3  'complete'  undefined
```

④ 多个 await 命令后的异步操作，如果不存在继发关系，最好使用 `Promise.all()` 同时触发

```javascript
const p1 = Promise.resolve(1).then(val => console.log(val));
const p2 = Promise.resolve(2).then(val => console.log(val));
const p3 = Promise.resolve(3).then(val => console.log(val));

async function f(){
  await Promise.all([p1, p2, p3]); 
}

f().then(val => console.log(val))
   .catch(err => console.log(err));

//输出：1 2 3 undefined
```

### (3) Async函数的执行上下文

#### ① 普通函数的执行上下文

JS 引擎执行某个普通函数时，创建该函数的执行上下文，并且压入执行上下文栈，该函数执行完成后，上下文从执行上下文栈中弹出，并且`销毁`该执行上下文

#### ② Async 函数的执行上下文

JS 引擎执行某个 Async 函数时，创建该 Async 函数的执行上下文，并且压入执行上下文栈，一旦遇到 await 命令，上下文就从执行上下文栈中弹出，但是并不销毁而是暂时`冻结`在当前状态，等到该 await 命令后的操作执行完毕，该上下文重新压入上下文栈，冻结的变量和对象恢复执行，

```javascript
const p1 = Promise.resolve(1).then(val => console.log(val));
const p2 = Promise.resolve(2).then(val => console.log(val));

async function f(){
  await p1; //执行到当前await命令时,f上下文退出上下文栈,内部状态冻结,p1执行完成后,f上下文重新压入上下文栈,内部状态解冻,恢复执行
  await p2; 
} 
f().then(val => console.log(val))
   .catch(err => console.log(err));

//输出：1 2 undefined
```
