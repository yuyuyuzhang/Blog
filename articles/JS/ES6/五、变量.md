# 五、变量

[[_TOC_]]

## 1. 变量声明

### (1) 块级作用域

#### ① ES5没有块级作用域的缺陷

ES5中只有全局作用域、函数作用域，没有块级作用域，这会导致很多不合理的场景

```javascript
//情况1：内层变量覆盖外层变量
var x = 1;
function f(){
  console.log(x);
  if(true){
    var x = 2;
  }
}
f(); //undefined,代码的本意是if代码块外部使用全局变量x,内部使用内层变量x,但是由于var变量提升,导致内层变量x覆盖全局变量x

//情况2：for循环中的循环变量泄漏为全局变量
var str = 'hello';
for(var i=0; i<str.length; i++){
  console.log(i);
}
console.log(i); //5,代码的本意是循环变量i只用来计数,循环结束后消失,但是由于没有块级作用域,循环变量i泄漏为全局变量
```

#### ② const

ES6新增const命令用于声明具有块级作用域的常量，常量指的是`栈内存中的引用地址不得改变`，而堆内存的数据结构可以改变，这意味着const常量必须`声明且立即初始化`，不得以后再赋值

```javascript
//声明且立即初始化
const a;      //SyntaxError

//基本数据类型值
const a = 1;
a = 2;        //TypeError

//引用数据类型值
const obj = {};
obj.a = 1;    //{a: 1}
obj = {b: 2}; //TypeError
```

#### ③ let

ES6新增let命令用于声明具有块级作用域的变量，从ES6开始，推荐使用let替代var

### (2) 不可重复声明

const、let变量不允许在同一作用域内重复声明

```javascript
//情况1
{
  const a = 1;
  let a = 2; //SyntaxError
}

//情况2
{
  const a = 1;
  var a = 2; //SyntaxError
}

//情况3
function f(arg){
  let arg = 1;
}
```

### (3) 不存在声明提升

const、let变量不允许声明提升，一定要`先声明再使用`，否则就会报错

```javascript
//情况1
{
  console.log(a); //ReferenceError
  const a = 1; 
}

//情况2
{
  console.log(a); //ReferenceError
  let a = 1;
}
```

### (4) 暂时性死区

const、let变量会`绑定并封闭`所在的块级作用域，形成暂时性死区TDZ

**本质**：只要进入当前作用域，所要使用的变量就已经存在，但是不可获取，只能等到声明变量的那行代码出现，才可获取和使用该变量

```javascript
//情况1
{
  console.log(a, b); //ReferenceError


  const a = 1;
  console.log(a); //1

  let b;
  console.log(b); //undefined
}

//情况2
const a = a; //ReferenceError
let b = b; //ReferenceError

//情况3
function f(a=b, b=1){} //ReferenceError
```

## 2. 执行上下文

JS 引擎并非一行一行地分析和执行程序，而是`一段一段地`分析和执行程序，段就是根据可执行代码来划分的

### (1) 可执行代码类型

① 全局代码

② 函数代码

③ eval() 代码

### (2) 执行上下文属性

当 JS 引擎执行一段可执行代码时，会创建对应的执行上下文，每个可执行上下文都有三个重要属性

① 变量对象

② 作用域链

③ this

### (3) 全局上下文

### (4) 函数上下文

执行上下文也叫作用域，是指程序源代码中`定义变量的区域`，规定了如何查找变量，也就是确定当前执行代码对变量的访问权限

#### ① 静态作用域

函数的作用域在`函数定义时`确定，ES采用`静态作用域`，

#### ② 动态作用域

函数的作用域在`函数调用时`才确定，

```javascript
const value = 1;
const f1 = () => console.log(value);
const f2 = () => {
  const value = 2;
  f1();
};
f2(); //静态作用域：1, f1执行时,先查找f1内部是否有局部变量value,没有则根据书写位置,查找全局上下文中是否有全局变量value
      //动态作用域：2, f1执行时,先查找f1内部是否有局部变量value,没有则在调用f1的执行上下文中,即f2内部查找是否有局部变量value
```

## 3. 变量对象

变量对象存储了执行上下文中定义的函数声明和变量声明

#### 全局上下文的变量对象

① 全局上下文的变量对象就是`全局对象`，

② 全局对象是预定义的对象，作为 JS 的全局属性、全局函数的占位符，通过使用全局对象，可以访问其他所有预定义的对象、属性、函数，在顶层 JS 代码中，可以用关键字 this 引用全局对象，因为全局对象是作用域链的头，这意味着所有非限定性的变量和函数名都会作为全局对象的属性来查询

### (1) 初始化函数上下文

**创建活动对象**：用函数的 `Arguments 对象`创建函数上下文的活动对象

**初始化活动对象**：给活动对象添加以下初始属性值

① 函数的所有形参

由名称和对应值组成一个变量对象的属性被创建

没有实参，属性值设为 undefined

② 函数声明

由名称和对应值 (函数对象(function-object)) 组成一个变量对象的属性被创建

如果函数名跟已经声明的函数名相同，则`覆盖`已声明的函数名

③ 变量声明

由名称和对应值 (undefined) 组成一个变量对象的属性被创建

如果变量名跟已经声明的函数名相同，则`忽略`当前变量名

### (2) 执行函数代码

`顺序`执行函数代码，根据代码修改活动对象的对应属性值    

```javascript
function f(a){
  let b = 2;
  function c(){}
  let d = function(){};
  b = 3;
}
f(1);

//创建活动对象
AO = {
  arguments: {
    0: 1,
    length: 1
  },
}

//初始化活动对象
AO = {
  arguments: {
    0: 1,
    length: 1
  },
  a: 1,
  b: undefined,
  c: reference to function c(){},
  d: undefined
}

//执行函数代码
AO = {
  arguments: {
    0: 1,
    length: 1
  },
  a: 1,
  b: 3,
  c: reference to function c(){},
  d: reference to FunctionExpression "d"
}
```

## 4. 作用域链

作用域链就是由多个执行上下文的`变量对象`构成的链表

### (1) 函数创建

函数创建时，保存函数所有父变量对象到函数内部的 `[[scope]]属性`，可以认为 [[scope]] 是函数所有父变量对象的层级链，但 [[scope]] 属性并不代表完整的作用域链

### (2) 初始化函数上下文

初始化函数上下文时，使用 Arguments 对象创建函数活动对象，并初始化活动对象，即给活动对象添加函数形参、函数声明、变量声明等初始属性值，然后将活动对象添加到`作用域链前端`，

```javascript
const a = "global";
function f1(){
  const a = "local";
  const f2 = () => a;
  return f2();
}
f1();

//函数创建
f1.[[scope]] = [
  globalContext.VO
];

//初始化函数上下文
f1Context = {
  AO: {
    arguments: {
      length: 0
    },
    a: undefined,
    f2: reference to function f2(){}
  },
  Scope: [AO, globalContext.VO],
  this: undefined
}
```

## 5. 执行上下文栈

JS 引擎创建执行上下文栈来管理执行上下文

### (1) 情况1

```javascript
const a = "global";
function f1(){
  const a = "local";
  const f2 = () => a;
  return f2();
}
f1();
//ECStack.push(globalContext);
//ECStack.push(<f1> functionContext);
//ECStack.push(<f2> functionContext);
//ECStack.pop();
//ECStack.pop();


//创建全局执行上下文,全局上下文被压入执行上下文栈
ECStack = [
  globalContext
];

//全局上下文初始化
globalContext = {
  VO: [global],
  Scope: [globalContext.VO],
  this: globalContext.VO
}

//同时f1函数被创建,保存作用域链到f1函数内部属性[[scope]]
f1.[[scope]] = [
  globalContext.VO
];

//创建f1函数执行上下文,f1函数上下文被压入执行上下文栈
ECStack = [
  f1Context,
  globalContext
];

//f1函数上下文初始化
//1. 复制函数[[scope]]属性创建作用域链
//2. 用函数Arguments对象创建活动对象
//3. 初始化活动对象,即加入函数形参、函数声明、变量声明
//4. 将活动对象压入函数作用域链顶端
f1Context = {
  AO: {
    arguments: {
      length: 0
    },
    scope: undefined,
    f2: reference to function f2(){}
  },
  Scope: [AO, globalContext.VO],
  this: undefined
}

//同时f2函数被创建,保存当前作用域链到f2函数内部属性[[scope]]
f2.[[scope]] = [
  f1Context.AO,
  globalContext.VO
];

//创建f2函数执行上下文,f2函数上下文被压入执行上下文栈
ECStack = [
  f2Context,
  f1Context,
  globalContext
];

//f2函数上下文初始化
f2Context = {
  AO: {
    arguments: {
      length: 0
    }
  },
  Scope: [AO, f1Context.AO, globalContext.VO],
  this: undefined
}

//f2函数执行,沿着作用域链查找a值,返回a值

//f2函数执行完毕,f2函数上下文从执行上下文栈中弹出
ECStack = [
  f1Context,
  globalContext
];

//f1函数执行完毕,f1函数上下文从执行上下文栈中弹出
ECStack = [
  globalContext
];
```

### (2) 情况2

```javascript
const a = "global";
function f1(){
  const a = "local";
  const f2 = () => a;
  return f2;
}
f1()();
//ECStack.push(globalContext);
//ECStack.push(<f1> functionContext);
//ECStack.pop();
//ECStack.push(<f2> functionContext);
//ECStack.pop();


//创建全局执行上下文,全局上下文被压入执行上下文栈
ECStack = [
  globalContext
];

//全局上下文初始化
globalContext = {
  VO: [global],
  Scope: [globalContext.VO],
  this: globalContext.VO
}

//同时f1函数被创建,保存作用域链到f1函数内部属性[[scope]]
f1.[[scope]] = [
  globalContext.VO
];

//创建f1函数执行上下文,f1函数上下文被压入执行上下文栈
ECStack = [
  f1Context,
  globalContext
];

//f1函数上下文初始化
//1. 复制函数[[scope]]属性创建作用域链
//2. 用函数Arguments对象创建活动对象
//3. 初始化活动对象,即加入函数形参、函数声明、变量声明
//4. 将活动对象压入函数作用域链顶端
f1Context = {
  AO: {
    arguments: {
      length: 0
    },
    scope: undefined,
    f2: reference to function f2(){}
  },
  Scope: [AO, globalContext.VO],
  this: undefined
}

//f1函数执行完毕,f1函数上下文从执行上下文栈中弹出
ECStack = [
  globalContext
];

//f2函数被创建,保存当前作用域链到f2函数内部属性[[scope]]
//虽然f1的执行上下文从执行上下文栈中弹出,但f2的作用域链中仍然存有f1的活动对象
f2.[[scope]] = [
  f1Content.AO,
  globalContext.VO
];

//创建f2函数执行上下文,f2函数上下文被压入执行上下文栈
ECStack = [
  f2Context,
  globalContext
];

//f2函数上下文初始化
f2Context = {
  AO: {
    arguments: {
      length: 0
    }
  },
  Scope: [AO, f1Content.AO, globalContext.VO],
  this: undefined
}

//f2函数执行完毕,f2函数上下文从执行上下文栈中弹出
ECStack = [
  globalContext
]
```
