# 一、数据类型

## 1. 基本数据类型

### (1) any

`任意值 any` 表示允许赋值为任意类型

```typescript
let a: any = undefined;
a = null;
a = 1;
a = 'aaa';
```

* 未声明类型的变量，会被 TS 推论成任意值类型 any

  ```typescript
  let a;
  a = 'aaa';
  a = 111;

  //等价于
  let a: any;
  a = 'aaa';
  a = 111;
  ```

* 在任意值上访问`任何属性和方法`都是允许的

  ```typescript
  const a: any = undefined
  console.log(a.name)
  console.log(a.getName())
  ```

### (2) void

`空值 void` 是 undefined 的子类型

* 变量：只能赋值 undefined
  
  ```typescript
  const a: void = undefined;

  let b: void;
  b = undefined;

  function f(x: void): void {
    console.log(x)
  }
  f();
  f(undefined);
  f(void 1);
  ```

* 函数：必须返回 undefined
  
  ```typescript
  function f(x: number): void {
    console.log(111);
  }
  ```

### (3) never

`永不存在值 never` 

* 变量：表示永不存在的值，可以赋值给`任意类型`的变量
  
  ```typescript
  interface A {
      type: 'a'
  }
  interface B {
      type: 'b'
  }
  type All = A | B;
  function handleValue(val: All) {
      switch (val.type) {
          case 'a':
              break
          case 'b':
              break
          default:
              // val 在这里是 never
              const c: never = val
              break
      }
  }

  //never 值可以赋值给任意类型的变量
  const a: undefined = function f1(): never {
      throw new Error()
  }()
  ```

* 函数：返回 never 的函数必须存在无法到达的终点，例如`抛出异常`或`没有返回值`（不同于返回 undefined）
  
  ```typescript
  function f1(): never {
      throw new Error()
  }

  function f2(): never {
      while (true) {
          console.log(111)
      }
  }
  ```

### (4) undefined

```typescript
const a: undefined = undefined;
```

### (5) null

```typescript
const a: null = null;
```

### (6) Boolean

```typescript
const a: boolean = true;
```

### (7) Number

```typescript
const a: number = NaN;
```

### (8) String

```typescript
const a: string = 'aaa';
```

### (9) Symbol

```typescript
const a: symbol = Symbol.for('name');
```

## 2. 引用数据类型

### (1) Object

TS 中使用`接口 Interface `定义对象的类型

* 变量的形状必须和接口的形状完全一致，不能少属性也不能多属性

  ```typescript
  const propName2: unique symbol = Symbol.for('hhh');

  interface Person {
    name: string;
    age: number;
    job?: string; //可选属性
    readonly id: number; //只读属性
    [propName1: string]: any; //string 任意属性
    // [propname: symbol]: any; //error: 索引签名参数类型必须为 string|number，微软还没有处理这个问题
    [propName2]: any; //勉强达到 symbol 任意属性的效果
  }

  //p 的形状必须和 Person 一致，不能少属性也不能多属性
  const p: Person = {
    name: '张三',
    age: 20,
    id: 1,
    [propName2]: true
  }
  ```

* 一个接口只能定义`一个任意属性`，一旦定义任意属性则`确定属性`和`可选属性`的类型都必须是任意属性类型的`子集`

  ```typescript
  interface Person {
    name: string;
    job?: string; //error: string|undefined 不是 string|number 的子集
    readonly id: number;
    [propName1: string]: string | number;
  }
  ```

### (2) Array

数据合并了相同类型的对象

### (3) Tuple

元组合并了不同类型的对象

### (4) Enum

### (5) Date

### (6) RegExp

### (7) Function

## 3. 联合类型

联合类型表示可以取值为多种类型中的一种，通过`分隔符 |` 分割每个类型

```typescript
let g: string | number;
g = 'aaa';
g = 111;
g = true; //errors: Type 'boolean' is not assignable to type 'string | number'
```

当不确定一个联合类型的变量到底是哪个类型的时候，只能访问该变量上`所有类型共有的属性和方法`

```typescript
function f1(x: string| number) {
  console.log(x.length); //error: Property 'length' does not exist on type 'string | number'
  console.log(x.toString());
}
```

## 4. 类型推论

TS 会在没有明确指定类型时推测出一个类型，这就是类型推论

```typescript
let a = 'ddd';
a = 1; //error: Type 'number' is not assignable to type 'string'

//等价于
let a: string = 'ddd';
a = 1; //error: Type 'number' is not assignable to type 'string'
```

变量声明时未赋值，都会被推论成任意值类型 `any`

```typescript
let a;
a = 'aaa';
a = 111;

//等价于
let a: any;
a = 'aaa';
a = 111;
```

## 5. 

```typescript

```

①②③④⑤⑥⑦⑧⑨⑩
