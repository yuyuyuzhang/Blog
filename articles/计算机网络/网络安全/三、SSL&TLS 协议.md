# 三、SSL/TLS

[[_TOC_]]

## 1. 明文通信的风险

HTTP 通信是不加密的通信，所有信息明文传播，带来了三大风险，SSL/TLS 协议就是为了解决这三大风险而设计的，SSL/TLS 协议采用了加密技术、完整性校验、身份认证技术

### (1) 窃听风险 ( 加密技术 )

第三方可以获知通信内容

### (2) 篡改风险 ( 完整性校验 )

第三方可以修改通信内容

### (3) 冒充风险 ( 身份认证技术 )

第三方可以冒充他人身份参与通信

## 2. SSL/TLS 的加密技术

### (1) 混合加密方式

SSL/TLS 采用`混合加密方式`，即客户端和服务器通过公开密钥加密方式发送共享密钥，然后通过共享密钥加密方式进行安全通信的方式

① 客户端生成一个共享密钥，服务器生成一对公钥私钥

② 服务器将公钥通过 Web 公开或邮件发送给客户端，客户端使用服务器的公钥将自身的共享密钥加密之后再发送，服务器收到密文后，使用自己的私钥将密文解密恢复成共享密钥

③ 客户端将要发送的数据通过自身的共享密钥加密之后再发送，服务器收到密文后，使用客户端的共享密钥将密文解密恢复成原文

![混合加密方式](https://github.com/yuyuyuzhang/Blog/blob/master/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF/%E6%B7%B7%E5%90%88%E5%8A%A0%E5%AF%86%E6%96%B9%E5%BC%8F.png)

### (2) 公钥证书

**由来**：解决加密技术中，公钥在传输过程中可能被篡改或替换的问题，公钥使用公钥证书证明自己的身份

① 数字证书认证机构是处于客户端和服务器双方都信赖的第三方机构的立场

② 首先服务器的运营人员向数字证书认证机构提出公钥申请，数字证书认证机构判明申请者的身份之后，使用自身的私钥对申请的公钥进行数字签名，然后将这个已签名的公钥放入公钥证书后绑定在一起

③ 然后服务器将这份公钥证书发送给客户端，收到证书的客户端，使用数字证书认证机构的公钥 (浏览器开发商发布版本时，事先内部植入常用认证机构的公钥) 对证书上的数字签名进行验证，一旦验证通过，就可以证明这个公钥是可以信赖的

![证书](https://github.com/yuyuyuzhang/Blog/blob/master/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF/%E8%AF%81%E4%B9%A6.png)

## 3. SSL/TLS 的完整性校验

SSL/TLS 使用加密技术，能够避免窃听风险、篡改风险，则无需完整性校验

## 4. SSL/TLS 的身份认证技术

### (1) SSL 服务器认证

#### ① SSL 证书

* SSL 证书一是证明作为通信一方的服务器真实存在且规范
* SSL 证书二是证明该服务器背后运营的企业真实存在

#### ② SSL 服务器认证

SSL 服务器认证是利用 SSL 证书完成认证的方式，客户端凭借 SSL 证书可确认访问的服务器真实存在且规范，并且服务器背后运营的企业真实存在

![SSL服务器认证](https://github.com/yuyuyuzhang/Blog/blob/master/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81%E6%8A%80%E6%9C%AF/SSL%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AE%A4%E8%AF%81.png)

### (2) SSL 客户端认证

#### ① 客户端证书

* 客户端证书只能证明作为通信一方的客户端真实存在且规范
* 客户端证书无法证明用户本人的真实有效性，只要获得了安装有客户端证书的计算机的使用权限，也就意味着同时拥有了客户端证书的使用权限
* 从认证机构购买客户端证书需要支付一定费用

#### ② SSL 客户端认证

SSL 客户端认证是利用客户端证书完成认证的方式，服务器凭借客户端证书可确认访问自己的客户端

* 客户端发送 HTTP 请求，请求需要认证的资源
* 服务器返回 Certificate Request 报文，要求客户端提供客户端证书
* 用户选择将要发送的客户端证书后，客户端将选择好的证书信息以 Client Certificate 报文方式发送给服务器
* 服务器验证客户端证书通过后，领取证书内的`客户端的公钥`，然后开始 HTTPS 加密通信

![SSL客户端认证](https://github.com/yuyuyuzhang/Blog/blob/master/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81%E6%8A%80%E6%9C%AF/SSL%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%AE%A4%E8%AF%81.png)

## 5. 面向有连接

SSL/TLS 协议是面向有连接的协议，使用 SSL/TLS 协议通信之前需要先建立 SSL/TLS 连接

![SSL握手](https://github.com/yuyuyuzhang/Blog/blob/master/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP%E5%8D%8F%E8%AE%AE/HTTPS/SSL%E6%8F%A1%E6%89%8B.png)

① 客户端发送 ClientHello 报文

* Version：客户端支持的 SSL 版本
* Random1：随机数，用于生成共享密钥
* Cipher Suite：客户端支持的加密组件列表，一个加密组件包含 4 个功能：信息摘要算法、身份认证算法、共享密钥加密算法、公开密钥加密算法

② 服务器返回 ServerHello 报文

* Version：确认通信使用的 SSL 版本
* Random2：随机数，用于生成共享密钥
* Cipher Suite：确认通信使用的加密组件，从客户端的加密组件列表中筛选出来的，如果服务器不支持客户端提供的加密组件列表，服务器返回握手故障并且断开连接

③ 服务器发送 Certificate 报文，包含服务器的公钥证书：用于证明服务器的公钥身份

④ 服务器发送 ServerHelloDone 报文，通知客户端 SSL 第一次握手阶段结束

⑤ 客户端发送 ClientKeyExchange 报文，包含客户端的共享密钥 ( 使用 Random1、Random1、协商后的共享密钥加密算法生成 )，该报文已经使用服务器的公钥加密

⑥ 客户端发送 ChangeCipherSpec 报文，通知服务器此报文之后的通信都会采用共享密钥加密

⑦ 客户端发送 Finished 报文，报文包含此次连接至今的全部报文的整体校验值，该报文使用共享密钥加密，这次握手协商能否成功，要以服务器能否正确解密该报文作为判定标准

⑧ 服务器发送 ChangeCipherSpec 报文，通知客户端自己已经获得共享密钥，此报文之后的通信都会采用共享密钥加密，服务器使用自己的私钥解密 ClientKeyExchange 报文获得共享密钥

⑨ 服务器发送 Finished 报文，该报文使用共享密钥加密，客户端和服务器的 Finished 报文交换完毕，SSL 连接就算建立完成

![SSL连接](https://github.com/yuyuyuzhang/Blog/blob/master/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP%E5%8D%8F%E8%AE%AE/HTTPS/SSL%E8%BF%9E%E6%8E%A5.png)
