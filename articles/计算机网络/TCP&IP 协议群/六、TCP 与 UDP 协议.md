# 六、TCP 与 UDP 协议

[[_TOC_]]

## 1. 传输层

### (1) 传输层作用

* 网络层的 IP 地址用来区分子网，数据链路层的 MAC 地址用来寻找计算机，但是大家在计算机上使用的都是应用程序，一台计算机可能同时打开 QQ、爱奇艺等多个应用程序，我们通过端口来标识一台主机上的不同应用程序
* 传输层主要负责`通过端口识别一台计算机上的不同应用程序`

## 2. 端口

### (1) 端口

端口号用来标识一台主机上进行通信的不同应用程序

#### ① 端口的范围

端口号的范围是 `0 ~ 65535`

#### ② 端口的类型

* **知名端口号**：HTTP、FTP 等广为使用的应用层协议使用的端口号，知名端口号是固定的，一般由 `0 ~ 1023` 的数字分配而成
* **注册端口号**：一些被正式注册的端口号，一般由 `1024 ~ 49151` 的数字分配而成，注册端口号可用于任何通信用途
* **操作系统分配端口号**：客户端应用程序无需自己设置端口号，操作系统为每个应用程序分配互不冲突的端口号，这样操作系统就可以动态管理端口号，一般由 `49152 ~ 65535` 的数字分配而成

### (2) 端口号与协议

① 端口号是由传输层协议处理的，数据到达网络层后，先检查 IP 报文首部的协议号，再将数据传到传输层对应的协议模块去做端口号的处理，即使是同一个端口号，由于传输层协议是各自独立地处理，因此相互之间不会影响

② 知名端口号与传输层协议并无关系，知名端口号都将被分配给同一种程序处理，例如 53 端口在 TCP 与 UDP 中都是用于 DNS 服务，80 端口都是用于 HTTP 通信

### (3) 识别同一个通信

TCP/IP 通信中通常采用 5 个信息来识别一个通信，`源 IP`、`目标 IP`、`源端口`、`目标端口`、`协议号`，只有这 5 项全部相同才可以被认为是同一个通信

![识别同一个通信](https://github.com/yuyuyuzhang/Blog/blob/master/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP%26IP%20%E5%8D%8F%E8%AE%AE%E7%BE%A4/%E8%AF%86%E5%88%AB%E5%90%8C%E4%B8%80%E4%B8%AA%E9%80%9A%E4%BF%A1.png)

## 3. UDP 协议

### (1) 面向无连接

① UDP 协议采用面向无连接的传输方式，不提供复杂的控制机制，细节的控制处理只能交由应用层协议处理

② UDP 协议可以随时发送数据，UDP 协议本身的处理简单又高效

### (2) UDP 报文

**① 源端口号**：发送端端口号

**② 目标端口号**：接收端端口号

**③ 包长度**：UDP 报文总字节数

**④ 校验和**：为了提供可靠的 UDP 报文而设计

![UDP报文](https://github.com/yuyuyuzhang/Blog/blob/master/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP%26IP%20%E5%8D%8F%E8%AE%AE%E7%BE%A4/UDP%E6%8A%A5%E6%96%87.png)

### (3) UDP 的应用

UDP 协议采用面向无连接的传输方式，所以可以随时发送数据，UDP 协议本身既简单又高效，适用于那些对高速传输和实时性有较高要求的通信

① 包数量较少的通信

② 限定于局域网等特定网络中的通信

③ 广播、组播通信

④ 视频、音频等多媒体通信：以 IP 电话为例，如果使用 TCP 协议，数据在传输过程中丢失会被重发，那么就无法流畅地传输通话人的声音，就无法正常交流，而采用 UDP 协议，不会进行重发处理，也就不会有声音大幅度延迟到达的问题，即使有部分数据丢失，也只会影响某一小部分的童话

## 4. TCP 协议

### (1) 流协议

TCP 协议是可靠的`流协议` ，采用面向有连接的传输方式

* 流是指不间断的数据结构
* 流协议发送消息，虽然可以保证发送顺序，但还是犹如没有任何间隔的数据流发送给接收端

### (2) 面向有连接

TCP 协议采用面向有连接的传输方式，应用程序不用顾虑网络上可能发生的任何问题，TCP 协议负责控制连接的建立、断开、保持等管理工作

#### ① 确认应答和序列号机制

##### 确认应答

* 发送端主机将数据发出之后，会等待接收端主机的确认应答，接收端主机收到数据会返回一个已收到消息的通知，这个通知就叫做确认应答
* 如果一定时间内接收端主机未收到确认应答，则认为数据已经丢失，进行重发，这种情况下有可能是数据丢失，也有可能是确认应答丢失  
  * 数据丢失
    ![数据丢失](https://github.com/yuyuyuzhang/Blog/blob/master/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP%26IP%20%E5%8D%8F%E8%AE%AE%E7%BE%A4/%E6%95%B0%E6%8D%AE%E4%B8%A2%E5%A4%B1.png)
  * 确认应答丢失
    ![确认应答丢失](https://github.com/yuyuyuzhang/Blog/blob/master/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP%26IP%20%E5%8D%8F%E8%AE%AE%E7%BE%A4/%E7%A1%AE%E8%AE%A4%E5%BA%94%E7%AD%94%E4%B8%A2%E5%A4%B1.png)

##### 序列号

* 如果是确认应答丢失，发送端主机只需要按照机制进行重发，但是接收端主机会反复收到相同的数据，而为了对应用层提供可靠传输，发送端主机必须得放弃重复的数据包
* 序列号是按顺序给发送数据的每个字节都标上的编号，接收端主机查询 TCP 报文首部的序列号和数据长度，将自己下一步应该接收的序号作为确认应答返回，通过确认应答和序列号，TCP 协议就可以实现可靠传输

![TCP可靠传输](https://github.com/yuyuyuzhang/Blog/blob/master/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP%26IP%20%E5%8D%8F%E8%AE%AE%E7%BE%A4/TCP%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93.png)

#### ② 重发超时间隔

* 重发超时间隔是指发送端主机重发数据之前，等待确认应答的那个时间间隔
* 最理想的时间间隔是保证确认应答一定能在这个时间内返回的最小时间，然而这个时间随着网络环境的不同而有所变化，例如在长距离通信中应该比短距离通信中长一些
* TCP 协议在每次发包时都会计算往返时间及其偏差，重发时间间隔就是比往返时间和偏差之和稍大一点的值

![重发时间间隔](https://github.com/yuyuyuzhang/Blog/blob/master/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP%26IP%20%E5%8D%8F%E8%AE%AE%E7%BE%A4/%E9%87%8D%E5%8F%91%E6%97%B6%E9%97%B4%E9%97%B4%E9%9A%94.png)

#### ③ 连接管理

**半双工**

只发送或只接受的通信方式，例如无线电收发器，两端同时说话，听不见对方说话

**全双工**

允许同一时间既可以发送数据也可以接收数据，例如电话，双方可以同时说话，TCP 协议就是采用全双工通信

**三次握手**

* 客户端通过 TCP 报文首部发送 SYN 包请求建立连接
* 服务器收到 SYN 包后，认为可以通信，发送针对 SYN 的确认应答并且同时发送 SYN 包请求建立连接
* 客户端收到确认应答和 SYN 包后，认为可以通信，发送针对 SYN 的确认应答
* 连接建立完成，双方开始通信

**四次挥手**

* 客户端确认数据发送完成后，通过 TCP 报文首部发送 FIN 包请求断开连接，表示自身没有数据要发送了
* 服务器受到 FIN 包后，发送针对 FIN 的确认应答，表示自己收到了请求，但是还没有准备好，还有数据要发送
* 服务器确认数据发送完成后，发送 FIN 包请求断开连接，表示自身没有数据要发送了
* 客户端受到 FIN 后，发送针对 FIN 的确认应答，表示自己收到了请求
* 服务器收到确认应答后断开连接，客户端等待 2 秒后无回复，证明服务器已关闭连接，客户端也就关闭连接

![连接管理](https://github.com/yuyuyuzhang/Blog/blob/master/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP%26IP%20%E5%8D%8F%E8%AE%AE%E7%BE%A4/%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86.png)

#### ④ 最大消息长度 MSS

* 最大消息长度 MSS（Maximum Segment Size） 是指 TCP 发送数据的单位，即 TCP 以 MSS 的大小将数据分割发送，最理想的情况是，MSS 正好是 `IP 报文不会被分片处理的最大长度`
* TCP 三次握手时，在两端主机之间计算得出 MSS，两端主机发出建立连接的请求时，会在 TCP 报文首部写入自身能适应的 MSS，然后在两者之间取较小值作为最终的 MSS

![MSS](https://github.com/yuyuyuzhang/Blog/blob/master/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP%26IP%20%E5%8D%8F%E8%AE%AE%E7%BE%A4/MSS.png)

#### ⑤ 窗口控制

* TCP 传输以一个段（最大消息长度 MSS）为单位，每发一个段就进行一次确认应答的处理，那么包的往返时间越长，通信性能就越低
* 为了解决这个问题，TCP 引入了窗口这个概念，窗口大小就是无需等待确认应答而可以继续发送的数据的最大值，转发时间将大幅度缩短

![窗口控制](https://github.com/yuyuyuzhang/Blog/blob/master/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP%26IP%20%E5%8D%8F%E8%AE%AE%E7%BE%A4/%E7%AA%97%E5%8F%A3%E6%8E%A7%E5%88%B6.png)

#### ⑥ 高速重发控制

* 没有使用窗口控制的时候，未收到确认应答的数据都要重发，使用窗口控制的时候，某些确认应答即使丢失也无需重发，可以通过下一个确认应答进行确认
* 如下图所示，当某一段报文丢失后，发送端会一直收到序号为 1001 的确认应答，如果发送端主机`连续 3 次`收到同一个序号的确认应答，就会重发对应的数据

![高速重发控制](https://github.com/yuyuyuzhang/Blog/blob/master/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP%26IP%20%E5%8D%8F%E8%AE%AE%E7%BE%A4/%E9%AB%98%E9%80%9F%E9%87%8D%E5%8F%91%E6%8E%A7%E5%88%B6.png)

#### ⑦ 流控制

* 接收端主机将自己可以接收的缓冲区大小放入 TCP 报文首部的窗口大小字段通知给发送端主机，接收端主机的缓冲区面临数据溢出时，窗口大小会被设置为一个更小的值通知发送端主机，从而形成一个完整的 TCP 流控制
* 为了避免窗口大小的更新通知在传送途中丢失导致无法继续通信的问题，发送端主机会是不是发送一个叫做`窗口探测`的数据段以获取最新的窗口大小

![流控制](https://github.com/yuyuyuzhang/Blog/blob/master/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCPIP%E5%8D%8F%E8%AE%AE%E7%BE%A4/%E6%B5%81%E6%8E%A7%E5%88%B6.png)

#### ⑧ 拥塞控制

* 计算机网络处于一个共享的环境，有可能因为其他主机的通信使得网络堵塞，网络堵塞时，如果突然发送一个较大量的数据，极有可能导致整个网络瘫痪
* TCP 为了防止该问题的出现，在通信一开始就会通过`慢启动算法`得到的值，对发送数据量进行控制
* TCP 定义了拥塞窗口的概念，慢启动时，将拥塞窗口的大小设置为 `1 MSS`，之后每收到一次确认应答，拥塞窗口的值就加 1，发送数据时，将拥塞窗口与接收端主机通知的窗口大小作比较，发送比较小的值还要小的数据量

![拥塞控制](https://github.com/yuyuyuzhang/Blog/blob/master/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP%26IP%20%E5%8D%8F%E8%AE%AE%E7%BE%A4/%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6.png)

### (3) TCP 报文

**① 源端口号**：发送端端口号

**② 目标端口号**：接收端端口号

**③ 序列号**：发送数据的位置

**④ 确认应答号**：下一次应该收到的数据的序列号

**⑤ 数据偏移**：TCP 报文首部的长度

**⑥ 控制位**：控制标志，如下所示

![控制位](https://github.com/yuyuyuzhang/Blog/blob/master/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP%26IP%20%E5%8D%8F%E8%AE%AE%E7%BE%A4/%E6%8E%A7%E5%88%B6%E4%BD%8D.png)

**⑦ 窗口大小**：接收端主机通知的窗口大小

![TCP报文](https://github.com/yuyuyuzhang/Blog/blob/master/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP%26IP%20%E5%8D%8F%E8%AE%AE%E7%BE%A4/TCP%E6%8A%A5%E6%96%87.png)

## 5. TCP 比 UDP 快

## 6. 传输层多路复用

多路复用就是让多个信号共用一个信道

应用层抽象应用之间通信的模型，例如请求返回模型，一个应用可能同时向服务器发送多个请求，然而建立 TCP 连接是需要开销的，所以可以多个请求复用一个 TCP 连接，一方面可以`节省流量`，另一方面可以`降低延迟`
