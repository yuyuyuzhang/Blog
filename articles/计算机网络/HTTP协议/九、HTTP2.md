# 九、HTTP2

[[_TOC_]]

## 1. HTTP2

### (1) HTTP2 的诞生

**由来**：为了解决 HTTP1.1 的性能瓶颈，诞生了 HTTP2

### (2) HTTP2 的特点

① 流、消息、帧

② 二进制分帧层

③ 首部压缩

④ 多向请求与响应

⑤ 请求优先级

⑥ 流量控制

⑦ 服务器推送

### (3) HTTP2 丢弃的 HTTP1.1 内容

① HTTP1.1 采用如下两种报文编码方式，HTTP2 不再采用报文编码，而是对帧统一采用`二进制编码`

* **内容编码**：服务器对实体资源进行编码来压缩容量，客户端接收内容编码后的实体并解码
* **分块传输编码**：实体资源过大时，服务器通过分块传输编码将实体主体分成多个块，每一块用十六进制标记大小，最后一块用 0 来标记，客户端逐一收到每个分块后，负责解码，恢复到编码前的实体主体

## 2. 流、消息、帧

### (1) 流、消息、帧

所有 HTTP2 通信都在`一个 TCP 连接`上完成，这个 TCP 连接可以承载任意数量的流，每个流都由一对请求消息和响应消息组成，消息由`一或多个帧`组成

* **流**：流是指一对请求消息和响应消息
* **消息**：消息是指 HTTP 请求或 HTTP 响应
* **帧**：帧是指 HTTP2 通信的最小单位

如下图所示，stream1 的流由一对请求消息和响应消息组成，请求消息由一个 HEADERS 帧组成，响应消息由一个 HEADERS 帧和 DATA 帧组成，这三个帧都属于流 stream1

![流、消息、帧](https://github.com/yuyuyuzhang/Blog/blob/master/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP%E5%8D%8F%E8%AE%AE/HTTP2/%E6%B5%81%E3%80%81%E6%B6%88%E6%81%AF%E3%80%81%E5%B8%A7.png)

### (2) 流 ID

① 流 ID 用来唯一标识某个流，客户端会从 1 开始设置流 ID，之后每开启一个新流，流 ID 就加 2，一直使用`奇数`，服务器会从 2 开始设置流 ID，之后每开启一个新流，流 ID 就加 2，一直使用`偶数`

② 这种设计避免了客户端和服务器的流 ID 冲突，可以轻松判断出某个流是客户端发起的还是服务器推送的，0 是保留数字，用于连接级控制信息，不能用于创建新的流

### (3) 帧首部

帧首部一共 `8 字节`，如下所示

![帧首部](https://github.com/yuyuyuzhang/Blog/blob/master/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP%E5%8D%8F%E8%AE%AE/HTTP2/%E5%B8%A7%E9%A6%96%E9%83%A8.png)

* **长度 ( 16 bit )**：当前帧负载的长度，最大可以携带 $2^{16}$ - 1 也就是 65535 字节 64 KB 的数据
* **类型**：当前帧类型
  
  HTTP2 规定了如下的帧类型
  
  * **Data**：客户端和服务器用于传输 HTTP 消息体
  * **HEADERS**：客户端和服务器用于传输额外首部字段
  * **CONTINUATION**：客户端和服务器用于协助 HEADERS 帧传输剩余的首部字段
  * **PRIORITY**：客户端用于指定或重新指定引用资源的优先级
  * **PUSH_PROMISE**：服务器用于通知客户端要推送的要约资源的 HTTP 首部
  * **RST_STREAM**：客户端和服务器用于通知对端流的非正常终止，例如客户端用于拒绝服务器的 PUSH_PROMISE 帧 ( 拒绝服务器推送 )
  * **GOAWAY**：客户端和服务器用于通知对端停止在当前连接中创建流
  * **PING**：客户端和服务器用于计算往返时间，执行活性检查
  * **SETTINGS**：客户端和服务器用于通知对端配置信息，例如自身流量控制窗口的初始大小 ( 一般都是 `65535 字节` )
  * **WINDOW_UPDATE**：客户端和服务器用于通知对端自身流量控制窗口的当前大小，用于实现`流量控制`

* **标志**：当前帧类型的标志
* **流标识符**：当前帧用于`唯一标识所属流`的标识符
* **帧净荷**：当前帧真实内容

## 3. 二进制分帧层

### (1) HTTP1.1 报文

① HTTP1.1 报文分为报文首部和报文主体两部分，两者通过`回车换行符 crlf`区分

② HTTP1.1 报文首部由请求行和首部字段组成，首部字段起到通信过程中传递额外信息的作用，首部字段间使用`回车换行符 crlf` 分割，首部字段由字段名和字段值构成，中间使用`冒号 :` 分割

![HTTP请求报文](https://github.com/yuyuyuzhang/Blog/blob/master/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP%E5%8D%8F%E8%AE%AE/HTTP%E6%8A%A5%E6%96%87/HTTP%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87.png)

### (2) HTTP2 报文

HTTP2 性能增强的核心全在于二进制分帧层，其定义了如何封装 HTTP 消息并在客户端和服务器之间传输

![二进制分帧层](https://github.com/yuyuyuzhang/Blog/blob/master/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP%E5%8D%8F%E8%AE%AE/HTTP2/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%88%86%E5%B8%A7%E5%B1%82.png)

## 4. 首部压缩

### (1) HTTP1.1 首部负荷

HTTP1.1 中报文首部是通过`纯文本形式`发送的，通常会给每个请求增加 500 - 800 字节的负荷，如果算上 Cookie，增加的负荷将会达到上千字节

### (1) HTTP2 首部表

① HTTP2 在客户端和服务器之间使用`首部表`来跟踪和存储之前发送的首部字段键值对，对于相同的键值对，不再通过每次请求和响应发送

② 首部表在 `TCP 连接存续期内`始终存在，由客户端和服务器共同渐进地更新，每个新的首部字段键值对要么被追加到当前首部表的末尾，要么替换首部表中之前的值

③ 如下图所示，第二个请求只需发送变化的首部字段键值对，其他首部字段键值对没有变化则无需发送，这样就可以避免传输冗余的首部，从而减少每个请求的开销

![首部表](https://github.com/yuyuyuzhang/Blog/blob/master/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP%E5%8D%8F%E8%AE%AE/HTTP2/%E9%A6%96%E9%83%A8%E8%A1%A8.png)

## 5. 多向请求与响应

### (1) HTTP1.1 管线化

HTTP1.1 通过持久连接和管线化实现`多向请求`

#### ① 持久连接

只要一端没有明确提出断开连接，则一直保持 TCP 连接状态，支持持久连接旨在建立 1 次 TCP 连接后多次 HTTP 请求和响应的交互
  
![持久连接](https://github.com/yuyuyuzhang/Blog/blob/master/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP%E5%8D%8F%E8%AE%AE/HTTP%E5%8D%8F%E8%AE%AE/%E6%8C%81%E4%B9%85%E8%BF%9E%E6%8E%A5.png)

#### ② 管线化

持久连接使得多数请求以管线化方式发送成为可能，管线化技术出现以后，无需等待响应亦可发送下一个请求
  
* **队头阻塞**：管线化限定了客户端接收响应的顺序必须一一对应客户端发送请求的顺序，如下图所示，如果请求 1 阻塞，即使服务器已经处理完请求 2，也必须等待请求 1 处理完，然后先返回响应 1，再返回响应 2，这就是队头阻塞，第一个请求阻塞，后面的请求都需要等待
  
![管线化](https://github.com/yuyuyuzhang/Blog/blob/master/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP%E5%8D%8F%E8%AE%AE/HTTP%E5%8D%8F%E8%AE%AE/%E7%AE%A1%E7%BA%BF%E5%8C%96.png)

* **解决队头堵塞**：HTTP1.1 想要解决队头阻塞，真正实现并行发送多个请求，必须使用`多个 TCP 连接`，每个 TCP 连接只交付一个 HTTP 响应

### (2) HTTP2 多向请求与响应

HTTP2 通过二进制分帧层实现`多向请求与响应`，突破了 HTTP1.1 管线化的队头堵塞的限制

#### ① 原理

HTTP2 采用二进制分帧层，客户端和服务器可以将 HTTP 消息分解成互不依赖的多个帧，然后乱序发送，最后在另一端根据每个帧的`流标识符`重新组合

如下图所示，一个 TCP 连接上有 3 个请求与响应并行交换，客户端向服务器发送 stream5 的一个 DATA 帧，服务器向客户端乱序返回 stream1 和 stream3 的一系列帧

![多向请求与响应](https://github.com/yuyuyuzhang/Blog/blob/master/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP%E5%8D%8F%E8%AE%AE/HTTP2/%E5%A4%9A%E5%90%91%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94.png)

* 一个 TCP 连接上有 3 个活动的流
* 3 个流的流 ID 都是奇数，说明都是客户端发起的，当前连接上没有服务器推送的流
* 服务器返回的 stream1 包含多个 DATA 帧，说明这是对客户端之前请求的响应数据，说明服务器之前已经发送过 HEADERS 帧了
* 服务器交错返回 stream1 的 DATA 帧和 stream2 的 HEADERS 帧，这就是多向响应，也就是响应的多路复用
* 客户端正在发送 stream5 的 DATA 帧，说明客户端之前已经发送过 HEADERS 帧了

#### ② 性能提升

* 可以并行交错的发送请求，请求之间互不影响
* 可以并行交错的返回响应，响应之间互不影响
* 一个 TCP 连接上可以并行发送多个请求和响应
* 消除不必要的延迟，从而减少页面加载的时间

#### ③ 每个来源一个 TCP 连接

HTTP2 通过二进制分帧层实现`多向请求与响应`，就无需像 HTTP1.1 一样通过多个 TCP 连接实现`多向请求`，因此 HTTP2 中客户端和服务器之间只需要一个 TCP 连接，真正实现了每个来源一个 TCP 连接

* 显著减少了相关资源占用
* 所有数据流的优先次序始终如一
* TCP 连接减少使得网络拥堵情况得以改善
* 慢启动时间减少，拥塞和丢包恢复速度更快

## 6. 请求优先级

HTTP2 的请求优先级决定每个流的`优先级`

### (1) 诞生

HTTP2 通过多向请求与响应，客户端可以一次发出所有资源的请求，假设服务器同时收到 100 个请求，也没有标识哪个更重要，那么服务器将几乎同时返回所有资源，次要资源就可能会影响关键资源的传输，由此 HTTP2 诞生了请求优先级策略

### (2) 原理

HTTP2 通过`流的依赖关系`来解决请求优先级问题，客户端通过 `HEADERS` 帧和 `PRIORITY` 帧通知服务器自身所需的资源以及资源的优先级，也就是说，客户端向服务器声明依赖关系树和树里各个元素的相对权重

HTTP2 没有规定优先级的具体算法，优先级的次序排队策略因浏览器和服务器的具体实现而不同

### (3) 实例

观察如下这个简单的网站所需的所有资源

* index.html
  * header.jpg
  * critical.js
  * less_critical.js
  * style.css
  * ad.js
  * photo.jpg

当客户端从服务器得到 idnex.html 文档后，客户端通过解析 HTML 文档生成如下所示的依赖树，然后给依赖树的每个元素分配权重

* index.html
  * style.css
    * critical.js
      * less_critical.js ( weight: 20 )
      * photo.jpg ( weight: 8 )
      * header.jpg ( weight: 8 )
      * ad.js ( weight: 4 )

由上图依赖树可知，客户端最需要的是 style.css，其次是 critical.js，没有这两个文件就无法渲染页面，等客户端收到 critical.js，就可以得出其余元素的权重，less_critical.js 的权重是 20，而所有元素的权重是 40，因此服务器应当花费大约一半的时间或资源用以传输 less_critical.js

称职的服务器会尽最大努力确保客户端按优先级尽快获得所需资源，但是服务器做什么以及如何处理优先级，还是得靠服务器自己的实现，因此处理优先级的智能水平，是决定 Web 服务器性能优劣的重要因素之一

## 7. 流量控制

HTTP2 的流量控制决定每个流的`占用资源`

### (1) 诞生

HTTP2 通过二进制分帧层实现多向请求和响应，因此一个 TCP 连接上有多个流同时存在，无论是客户端还是服务器还是代理服务器，任意一方的带宽和内存都是有限的，任意一方作为接收方时，都需要确保某个流不会阻塞其他的流，由此诞生了流量控制策略

### (2) 原理

`客户端、服务器、代理服务器`作为接收方时都独立地公布各自的流量控制窗口，作为接收方时也可以禁用流量控制，任意一方作为发送方都遵守对端的流量控制设置

通过帧首部的长度字段可知，每个帧最大可以携带 $2^{16}$ - 1 也就是 65535 字节 64 KB 的数据，因此流量控制窗口的初始大小默认都是 `65535 字节`

HTTP2 没有规定流量控制的具体算法，流量控制策略因浏览器和服务器的具体实现而不同

### (3) 流程

* 流量控制基于`每一跳`进行，而非端到端的控制
* HTTP2 建立 TCP 连接后，客户端与服务器交换 `SETTINGS` 帧，目的是通知对端自身的流量控制窗口的初始大小，一般都是 65535 字节
* 流量控制其实是接收方控制发送方发送的 `DATA` 帧的大小，发送方每发送一个 DATA 帧，接收方的流量控制窗口的大小就会发生变化
* 接收方的流量控制窗口大小更新后，通过 `WINDOW_UPDATE` 帧通知发送方自身流量控制窗口的当前大小

### (4) 实例

以下实例，客户端 A 使用流量控制，服务器 B 禁用流量控制

* 流量控制窗口大小默认都是 65535 字节，假设客户端 A 支持该默认值
* 客户端和服务器建立 TCP 连接后，客户端 A 会发送一个 `SETTINGS` 帧通知服务器 B 自身流量控制窗口的初始大小为 65535 字节
* 服务器 B 发送了 10000 字节
* 当客户端 A 处理了 5000 字节的数据后，客户端 A 会发送一个 `WINDOW_UPDATE` 帧通知服务器 B 自身流量控制窗口的当前大小为 60535 字节
* 此时服务器 B 开始发送一个大文件 1 MB = 1048576 字节，在这种场景下，服务器 B 能发送的数据量就是客户端 A 的流量控制窗口的当前大小 60535 字节
* 通过这种方式，客户端 A 可以控制服务器 B 发送数据的最大速率

## 8. 服务器推送

### (1) 诞生

通常的 Web 应用都由几十个资源组成，客户端需要分析服务器提供的 HTML 文档才能才能逐个找到它们，那为什么不让服务器提前找到它们，然后主动推送给客户端呢？这就是服务器推送策略的诞生

### (2) 原理

HTTP2 新增服务器推送功能，服务器可以针对一个客户端请求返回多个响应，换句话说，除了对最初请求的响应外，服务器还可以额外向客户端推送资源，而无需客户端明确地请求

服务器推送的资源直接进入`客户端缓存`，就像客户端请求了似的，整个过程对于运行在浏览器的 Web 应用来说好像不存在，不存在客户端 API 或 JS 回调函数等通知机制用于确认资源何时到达

![服务器推送](https://github.com/yuyuyuzhang/Blog/blob/master/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP%E5%8D%8F%E8%AE%AE/HTTP2/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8E%A8%E9%80%81.png)

### (3) 机制

服务器如何确定哪些资源可以推送？HTTP2 并没有就此规定某种算法，推送内容因服务器的具体实现而不同，但是服务器推送的所有资源都遵守浏览器的`同源策略`

* 客户端通过`额外的 HTTP 首部`向服务器明确表示希望推送的资源
* 服务器不依赖客户端而是自动学习相关资源，服务器可以解析文档推断出需要推送的资源，服务器也可以根据请求首部字段 Referer 得知引荐人，从而收集依赖数据，自动向客户端推送关键资源

#### ① 服务器推送的限制

* 服务器必须遵守请求-响应的机制，只能借着对请求的响应推送资源，也就是说服务器不能随意发起推送
* 服务器在发起推送之前，必须先发送一个 `PUSH_PROMISE` 帧，包含要约资源的 HTTP 首部，客户端收到这个帧之后，可以视自身需求选择是否拒绝这个流
* PUSH_PROMISE 帧必须在服务器返回针对最初请求的响应之前发送，以免客户端出现`竞态条件`，比如客户端接下来的请求恰好是服务器打算推送的资源

#### ② PUSH_PROMISE 帧

* PUSH_PROMISE 帧首部的`流 ID` 用来响应相关联的请求，推送的响应一定会关联到客户端已发送的某个请求
* 推送的资源必须确保是`可缓存的`

### (4) 性能提升

HTTP2 有了服务器推送策略，HTTP1.1 的嵌入资源做法基本上也就过时了，唯一有必要在 HTML 文档中嵌入资源的情况就是该资源只供那一个页面使用，而且编码代价不大，除此之外的所有情况都应该使用服务器推送

* 客户端可以缓存服务器推送的资源
* 客户端可以拒绝服务器推送的资源
* 服务器推送的资源可以由不同的页面共享
* 服务器可以按照优先级推送资源

## 9. HTTP1.1 升级至 HTTP2

### (1) HTTP2 的升级

升级到 HTTP2 要求 Nginx 的最低版本是 1.10.0，Nginx 提供了 2 种办法升级到 HTTP2，一种是升级操作系统，一种是从源码编译新版本的 Nginx，在此使用第二种方式

① 在 Nginx 服务器上执行以下命令，将低版本的 Nginx 升级到支持 HTTP2 的新版本

```javascript
wget http://nginx.org/download/nginx-1.12.1.tar.gz # 下载
tar -zxvf nginx-1.12.1.tar.gz # 解压
cd nginx-1.12.1
./configure # 确认系统环境，生成make文件
make # 编译
sudo make install #安装
```

② 然后添加 Nginx 配置，在原来的 listen 后面添加 http2

```javascript
//原来
listen 443 ssl;

//现在
listen 443 ssl http2;
```

### (2) 服务器推送的配置

HTTP2 仅有服务器推送功能需要开发者手动配置，其他功能都是浏览器和服务器自动实现

以 Nginx 服务器为例，其实就是最后多了两行 `http2_push` 命令，意思是如果用户请求根路径，服务器就推送 style.css、example.png

```javascript
server {
  listen 443 ssl http2;
  server_name  localhost;

  ssl                  on;
  ssl_certificate      /etc/nginx/certs/example.crt;
  ssl_certificate_key  /etc/nginx/certs/example.key;
  ssl_session_timeout  5m;
  ssl_ciphers HIGH:!aNULL:!MD5;
  ssl_protocols SSLv3 TLSv1 TLSv1.1 TLSv1.2;
  ssl_prefer_server_ciphers   on;

  location / {
    root   /usr/share/nginx/html;
    index  index.html index.htm;
    http2_push /style.css;
    http2_push /example.png;
  }
}
```
