<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>recursion</title>
</head>
<body>
<script>
//递归：函数调用自身
//递归条件：构成递归需具备边界条件、递归前进段、递归返回段,边界条件不满足时递归前进,边界条件满足时递归返回
//递归特点：1.子问题须与原始问题为同样的事且更为简单 2.不能无限制地调用本身,须有个出口,转换为非递归状况处理
//递归缺陷：递归调用时,JS会不停创建执行上下文压入执行上下文栈,内存开销极大
//递归优化：尾调用——


//调用：函数调用会在内存形成一个调用帧,保存调用位置和内部变量等信息,多个函数的连续调用会形成一个调用栈,占用大量内存
const f = x => g(x) + x;

//尾调用：函数的最后一步操作是调用另一个函数,不再用到外层函数的内部变量,则无需保留外层函数的调用帧,可以直接用内层函数的调用帧取代外层函数
const f = x => g(x + 3);

//递归：函数调用自身,递归非常耗费内存,需要同时保存成百上千个调用帧,容易发生栈溢出
const f = n =>  n === 1 ? 1 : n*f(n-1);

//尾递归：函数尾调用自身,尾递归永远只存在一个调用帧,永远不会发生栈溢出
const f = (n, result=1) => n === 1 ? result : f(n-1, n*result); 



</script>
</body>
</html>